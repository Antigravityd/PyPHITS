<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyphits API documentation</title>
<meta name="description" content="This is a Python interface to JAEA&#39;s [Particle Heavy-Ion Transport Code System (PHITS)](https://phits.jaea.go.jp)." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pyphits</code></h1>
</header>
<section id="section-intro">
<p>This is a Python interface to JAEA's <a href="https://phits.jaea.go.jp">Particle Heavy-Ion Transport Code System (PHITS)</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This is a Python interface to JAEA&#39;s [Particle Heavy-Ion Transport Code System (PHITS)](https://phits.jaea.go.jp).&#34;&#34;&#34;

# TODOs:
# Counter/multiplier in tally
# Radioisotope and CosmicRay energy distributions
# Dir = iso for spherical shell sources (necessary for CosmicRay to be used properly)
# readable_remapping
# nuclide-specific library settings
# paper

from pyphits.valspec import *

import sys
import numpy as np
import collections as col
from numpy.linalg import det
from datetime import datetime
import subprocess as sp
import itertools as it
from functools import reduce
import pandas as pd
import tempfile as tf
import re
import os
from copy import deepcopy
from fortranformat import FortranRecordReader
from shutil import copy

# Configuration options
readable_remapping = True
&#34;&#34;&#34;If `True`, use a remapped initialization syntax that&#39;s more informative.
   E.g., `Parameters(control=&#34;output_echo_only&#34;)` instead of `Parameters(icntl=3)`.

   If `False`, use a syntax as close as possible to that specified in the PHITS manual (i.e., the latter form in the above example).
   Note that some identifiers in PHITS do not conform to Python&#39;s identifier syntax (e.g. 2d-type, emin(14));
   these identifiers are sanitized as follows:

       - dashes -&gt; underscores
       - beginning with a number -&gt; that clause moved to the end
       - parentheses -&gt; omitted&#34;&#34;&#34;


## PARAMETERS
class Parameters():
    &#34;&#34;&#34;A &#34;dictionary with an attitude&#34; representing an entry in the [Parameters] section of an input file.
    Any extra keyword arguments to any constructors are minted into parameter objects.


    &gt;&gt;&gt; print(Parameters(ndedx=2, dbcutoff=3.3).definition())
    ndedx = 2
    dbcutoff = 3.3
    &#34;&#34;&#34;
    name = &#34;parameters&#34;
    syntax = {&#34;control&#34;: (&#34;icntl&#34;, FinBij({&#34;normal&#34;: 0, &#34;output_cross-section&#34;: 1, &#34;output_echo_only&#34;: 3, &#34;all_reg_void&#34;: 5,
                                           &#34;source_check&#34;: 6, &#34;show_geometry&#34;: 7, &#34;show_geometry_with_xyz&#34;: 8, &#34;show_regions&#34;: 9,
                                           &#34;show_regions_with_tally&#34;: 10, &#34;show_3d_geometry&#34;: 11, &#34;use_dumpall&#34;: 12, &#34;sum_tally&#34;: 13,
                                           &#34;auto_volume&#34;: 14, &#34;ww_bias_tally&#34;: 15, &#34;analysis_script&#34;: 16, &#34;anatally&#34;: 17}), None),
              &#34;max_histories&#34;: (&#34;maxcas&#34;, PosInt(), None),
              &#34;max_batches&#34;: (&#34;maxbch&#34;, PosInt(), None),
              &#34;nuclear_memory_rescale&#34;: (&#34;xsmemory&#34;, PosReal(), None),
              &#34;timeout&#34;: (&#34;timeout&#34;, NegDisable(), None),
              &#34;stdev_control&#34;: (&#34;istdev&#34;, FinBij({&#34;history_restart&#34;: -2, &#34;batch_restart&#34;: -1, &#34;normal&#34;: 0, &#34;batch&#34;: 1, &#34;history&#34;: 2}), None),
              &#34;share_tallies&#34;: (&#34;italsh&#34;, Choice10(), None),
              &#34;check_consistency&#34;: (&#34;ireschk&#34;, Choice10(c_style=True), None),
              &#34;xor_prng&#34;: (&#34;nrandgen&#34;, Choice10(), None),
              # &#34;seed_skip&#34;: (&#34;irskeep&#34;, Integer(), None),
              &#34;random_seed&#34;: (&#34;rseed&#34;, Real(), None),
              &#34;seed_from_time&#34;: (&#34;itimrand&#34;, Choice10(), None),
              # bitrseed?,

              &#34;proton_e_cutoff&#34;: (&#34;emin(1)&#34;, PosReal(), None),
              &#34;neutron_e_cutoff&#34;: (&#34;emin(2)&#34;, PosReal(), None),
              &#34;pionp_e_cutoff&#34;: (&#34;emin(3)&#34;, PosReal(), None),
              &#34;pion0_e_cutoff&#34;: (&#34;emin(4)&#34;, PosReal(), None),
              &#34;pionm_e_cutoff&#34;: (&#34;emin(5)&#34;, PosReal(), None),
              &#34;muonp_e_cutoff&#34;: (&#34;emin(6)&#34;, PosReal(), None),
              &#34;muonm_e_cutoff&#34;: (&#34;emin(7)&#34;, PosReal(), None),
              &#34;kaonp_e_cutoff&#34;: (&#34;emin(8)&#34;, PosReal(), None),
              &#34;kaon0_e_cutoff&#34;: (&#34;emin(9)&#34;, PosReal(), None),
              &#34;kaonm_e_cutoff&#34;: (&#34;emin(10)&#34;, PosReal(), None),
              &#34;other_e_cutoff&#34;: (&#34;emin(11)&#34;, PosReal(), None),
              &#34;electron_e_cutoff&#34;: (&#34;emin(12)&#34;, PosReal(), None),
              &#34;positron_e_cutoff&#34;: (&#34;emin(13)&#34;, PosReal(), None),
              &#34;photon_e_cutoff&#34;: (&#34;emin(14)&#34;, PosReal(), None),
              &#34;deuteron_e_cutoff&#34;: (&#34;emin(15)&#34;, PosReal(), None),
              &#34;triton_e_cutoff&#34;: (&#34;emin(16)&#34;, PosReal(), None),
              &#34;he3_e_cutoff&#34;: (&#34;emin(17)&#34;, PosReal(), None),
              &#34;he4_e_cutoff&#34;: (&#34;emin(18)&#34;, PosReal(), None),
              &#34;nucleon_e_cutoff&#34;: (&#34;emin(19)&#34;, PosReal(), None),
              &#34;proton_e_max&#34;: (&#34;dmax(1)&#34;, PosReal(), None),
              &#34;neutron_e_max&#34;: (&#34;dmax(2)&#34;, PosReal(), None),
              &#34;electron_e_max&#34;: (&#34;dmax(12)&#34;, PosReal(), None),
              &#34;positron_e_max&#34;: (&#34;dmax(13)&#34;, PosReal(), None),
              &#34;photon_e_max&#34;: (&#34;dmax(14)&#34;, PosReal(), None),
              &#34;deuteron_e_max&#34;: (&#34;dmax(15)&#34;, PosReal(), None),
              &#34;he4_e_max&#34;: (&#34;dmax(18)&#34;, PosReal(), None),
              # &#34;photonuclear_e_max&#34;: (&#34;dpnmax&#34;, PosReal(), None),
              # lib(i)??
                  &#34;proton_react_cutoff&#34;: (&#34;cmin(1)&#34;, PosReal(), None),
              &#34;neutron_react_cutoff&#34;: (&#34;cmin(2)&#34;, PosReal(), None),
              &#34;pionp_react_cutoff&#34;: (&#34;cmin(3)&#34;, PosReal(), None),
              &#34;pion0_react_cutoff&#34;: (&#34;cmin(4)&#34;, PosReal(), None),
              &#34;pionm_react_cutoff&#34;: (&#34;cmin(5)&#34;, PosReal(), None),
              &#34;muonp_react_cutoff&#34;: (&#34;cmin(6)&#34;, PosReal(), None),
              &#34;muonm_react_cutoff&#34;: (&#34;cmin(7)&#34;, PosReal(), None),
              &#34;kaonp_react_cutoff&#34;: (&#34;cmin(8)&#34;, PosReal(), None),
              &#34;kaon0_react_cutoff&#34;: (&#34;cmin(9)&#34;, PosReal(), None),
              &#34;kaonm_react_cutoff&#34;: (&#34;cmin(10)&#34;, PosReal(), None),
              &#34;other_react_cutoff&#34;: (&#34;cmin(11)&#34;, PosReal(), None),
              &#34;electron_react_cutoff&#34;: (&#34;cmin(12)&#34;, PosReal(), None),
              &#34;positron_react_cutoff&#34;: (&#34;cmin(13)&#34;, PosReal(), None),
              &#34;photon_react_cutoff&#34;: (&#34;cmin(14)&#34;, PosReal(), None),
              &#34;deuteron_react_cutoff&#34;: (&#34;cmin(15)&#34;, PosReal(), None),
              &#34;triton_react_cutoff&#34;: (&#34;cmin(16)&#34;, PosReal(), None),
              &#34;he3_react_cutoff&#34;: (&#34;cmin(17)&#34;, PosReal(), None),
              &#34;he4_react_cutoff&#34;: (&#34;cmin(18)&#34;, PosReal(), None),
              &#34;nucleon_react_cutoff&#34;: (&#34;cmin(19)&#34;, PosReal(), None),
              &#34;charged_e_min&#34;: (&#34;esmin&#34;, PosReal(), None),
              &#34;charged_e_max&#34;: (&#34;esmax&#34;, PosReal(), None),
              &#34;electron_positron_track_structure_e_min&#34;: (&#34;etsmin&#34;, PosReal(), None),
              &#34;electron_positron_track_structure_e_max&#34;: (&#34;etsmax&#34;, PosReal(), None),
              &#34;nucleon_track_structure_e_max&#34;: (&#34;tsmax&#34;, PosReal(), None),
              &#34;electric_transport_type&#34;: (&#34;negs&#34;, FinBij({&#34;PHITS&#34;: -1, &#34;ignore&#34;: 0, &#34;EGS5&#34;: 1}), None),
              &#34;automatic_e_bounds&#34;: (&#34;nucdata&#34;, Choice10(), None),
              &#34;electron_positron_adjust_weight_over_e_max&#34;: (&#34;ieleh&#34;, Choice10(), None),
              &#34;nucleon_nucleus_model_switch_e&#34;: (&#34;ejamnu&#34;, PosReal(), None),
              &#34;pion_nucleus_model_switch_e&#34;: (&#34;ejampi&#34;, PosReal(), None),
              &#34;isobar_max_e&#34;: (&#34;eisobar&#34;, PosReal(), None),
              &#34;isobar_model&#34;: (&#34;isobar&#34;, Choice10(), None),
              &#34;bertini_jqmd_switch_e&#34;: (&#34;eqmdnu&#34;, PosReal(), None),
              &#34;jqmd_e_min&#34;: (&#34;eqmdmin&#34;, PosReal(), None),
              &#34;jqmd_jamqmd_switch_e&#34;: (&#34;ejamqmd&#34;, PosReal(), None),
              &#34;incl_control&#34;:  (&#34;inclg&#34;, FinBij({None: 0, &#34;all&#34;: 1, &#34;no_He&#34;: 2}), None),
              &#34;icnl_e_min&#34;: (&#34;einclmin&#34;, PosReal(), None),
              &#34;icnl_e_max&#34;: (&#34;einclmax&#34;, PosReal(), None),
              &#34;inc_elf_control&#34;: (&#34;incelf&#34;, Choice10(), None),
              &#34;icnl_elf_e_min&#34;: (&#34;eielfmin&#34;, PosReal(), None),
              &#34;icnl_elf_e_max&#34;: (&#34;eielfmax&#34;, PosReal(), None),
              &#34;jqmd_2&#34;: (&#34;irqmd&#34;, Choice10(), None),
              &#34;scinful_qmd&#34;: (&#34;iscinful&#34;, Choice10(), None),
              &#34;kerma_mode&#34;: (&#34;kerma&#34;, Choice10(), None),
              &#34;pseudo_reaction_e&#34;: (&#34;epseudo&#34;, PosReal(), None),
              &#34;proton_time_cutoff&#34;: (&#34;tmax(1)&#34;, PosReal(), None),
              &#34;neutron_time_cutoff&#34;: (&#34;tmax(2)&#34;, PosReal(), None),
              &#34;pionp_time_cutoff&#34;: (&#34;tmax(3)&#34;, PosReal(), None),
              &#34;pion0_time_cutoff&#34;: (&#34;tmax(4)&#34;, PosReal(), None),
              &#34;pionm_time_cutoff&#34;: (&#34;tmax(5)&#34;, PosReal(), None),
              &#34;muonp_time_cutoff&#34;: (&#34;tmax(6)&#34;, PosReal(), None),
              &#34;muonm_time_cutoff&#34;: (&#34;tmax(7)&#34;, PosReal(), None),
              &#34;kaonp_time_cutoff&#34;: (&#34;tmax(8)&#34;, PosReal(), None),
              &#34;kaon0_time_cutoff&#34;: (&#34;tmax(9)&#34;, PosReal(), None),
              &#34;kaonm_time_cutoff&#34;: (&#34;tmax(10)&#34;, PosReal(), None),
              &#34;other_time_cutoff&#34;: (&#34;tmax(11)&#34;, PosReal(), None),
              &#34;electron_time_cutoff&#34;: (&#34;tmax(12)&#34;, PosReal(), None),
              &#34;positron_time_cutoff&#34;: (&#34;tmax(13)&#34;, PosReal(), None),
              &#34;photon_time_cutoff&#34;: (&#34;tmax(14)&#34;, PosReal(), None),
              &#34;deuteron_time_cutoff&#34;: (&#34;tmax(15)&#34;, PosReal(), None),
              &#34;triton_time_cutoff&#34;: (&#34;tmax(16)&#34;, PosReal(), None),
              &#34;he3_time_cutoff&#34;: (&#34;tmax(17)&#34;, PosReal(), None),
              &#34;he4_time_cutoff&#34;: (&#34;tmax(18)&#34;, PosReal(), None),
              &#34;nucleon_time_cutoff&#34;: (&#34;tmax(19)&#34;, PosReal(), None),
              &#34;proton_weight_min&#34;: (&#34;wc1(1)&#34;, PosReal(), None),
              &#34;neutron_weight_min&#34;: (&#34;wc1(2)&#34;, PosReal(), None),
              &#34;pionp_weight_min&#34;: (&#34;wc1(3)&#34;, PosReal(), None),
              &#34;pion0_weight_min&#34;: (&#34;wc1(4)&#34;, PosReal(), None),
              &#34;pionm_weight_min&#34;: (&#34;wc1(5)&#34;, PosReal(), None),
              &#34;muonp_weight_min&#34;: (&#34;wc1(6)&#34;, PosReal(), None),
              &#34;muonm_weight_min&#34;: (&#34;wc1(7)&#34;, PosReal(), None),
              &#34;kaonp_weight_min&#34;: (&#34;wc1(8)&#34;, PosReal(), None),
              &#34;kaon0_weight_min&#34;: (&#34;wc1(9)&#34;, PosReal(), None),
              &#34;kaonm_weight_min&#34;: (&#34;wc1(10)&#34;, PosReal(), None),
              &#34;other_weight_min&#34;: (&#34;wc1(11)&#34;, PosReal(), None),
              &#34;electron_weight_min&#34;: (&#34;wc1(12)&#34;, PosReal(), None),
              &#34;positron_weight_min&#34;: (&#34;wc1(13)&#34;, PosReal(), None),
              &#34;photon_weight_min&#34;: (&#34;wc1(14)&#34;, PosReal(), None),
              &#34;deuteron_weight_min&#34;: (&#34;wc1(15)&#34;, PosReal(), None),
              &#34;triton_weight_min&#34;: (&#34;wc1(16)&#34;, PosReal(), None),
              &#34;he3_weight_min&#34;: (&#34;wc1(17)&#34;, PosReal(), None),
              &#34;he4_weight_min&#34;: (&#34;wc1(18)&#34;, PosReal(), None),
              &#34;nucleon_weight_min&#34;: (&#34;wc1(19)&#34;, PosReal(), None),
              &#34;proton_weight_cutoff&#34;: (&#34;wc2(1)&#34;, PosReal(), None),
              &#34;neutron_weight_cutoff&#34;: (&#34;wc2(2)&#34;, PosReal(), None),
              &#34;pionp_weight_cutoff&#34;: (&#34;wc2(3)&#34;, PosReal(), None),
              &#34;pion0_weight_cutoff&#34;: (&#34;wc2(4)&#34;, PosReal(), None),
              &#34;pionm_weight_cutoff&#34;: (&#34;wc2(5)&#34;, PosReal(), None),
              &#34;muonp_weight_cutoff&#34;: (&#34;wc2(6)&#34;, PosReal(), None),
              &#34;muonm_weight_cutoff&#34;: (&#34;wc2(7)&#34;, PosReal(), None),
              &#34;kaonp_weight_cutoff&#34;: (&#34;wc2(8)&#34;, PosReal(), None),
              &#34;kaon0_weight_cutoff&#34;: (&#34;wc2(9)&#34;, PosReal(), None),
              &#34;kaonm_weight_cutoff&#34;: (&#34;wc2(10)&#34;, PosReal(), None),
              &#34;other_weight_cutoff&#34;: (&#34;wc2(11)&#34;, PosReal(), None),
              &#34;electron_weight_cutoff&#34;: (&#34;wc2(12)&#34;, PosReal(), None),
              &#34;positron_weight_cutoff&#34;: (&#34;wc2(13)&#34;, PosReal(), None),
              &#34;photon_weight_cutoff&#34;: (&#34;wc2(14)&#34;, PosReal(), None),
              &#34;deuteron_weight_cutoff&#34;: (&#34;wc2(15)&#34;, PosReal(), None),
              &#34;triton_weight_cutoff&#34;: (&#34;wc2(16)&#34;, PosReal(), None),
              &#34;he3_weight_cutoff&#34;: (&#34;wc2(17)&#34;, PosReal(), None),
              &#34;he4_weight_cutoff&#34;: (&#34;wc2(18)&#34;, PosReal(), None),
              &#34;nucleon_weight_cutoff&#34;: (&#34;wc2(19)&#34;, PosReal(), None),
              # &#34;proton_source_weight_min&#34;: (&#34;swc1(1)&#34;, PosReal(), None),
              # &#34;neutron_source_weight_min&#34;: (&#34;swc1(2)&#34;, PosReal(), None),
              # &#34;pionp_source_weight_min&#34;: (&#34;swc1(3)&#34;, PosReal(), None),
              # &#34;pion0_source_weight_min&#34;: (&#34;swc1(4)&#34;, PosReal(), None),
              # &#34;pionm_source_weight_min&#34;: (&#34;swc1(5)&#34;, PosReal(), None),
              # &#34;muonp_source_weight_min&#34;: (&#34;swc1(6)&#34;, PosReal(), None),
              # &#34;muonm_source_weight_min&#34;: (&#34;swc1(7)&#34;, PosReal(), None),
              # &#34;kaonp_source_weight_min&#34;: (&#34;swc1(8)&#34;, PosReal(), None),
              # &#34;kaon0_source_weight_min&#34;: (&#34;swc1(9)&#34;, PosReal(), None),
              # &#34;kaonm_source_weight_min&#34;: (&#34;swc1(10)&#34;, PosReal(), None),
              # &#34;other_source_weight_min&#34;: (&#34;swc1(11)&#34;, PosReal(), None),
              # &#34;electron_source_weight_min&#34;: (&#34;swc1(12)&#34;, PosReal(), None),
              # &#34;positron_source_weight_min&#34;: (&#34;swc1(13)&#34;, PosReal(), None),
              # &#34;photon_source_weight_min&#34;: (&#34;swc1(14)&#34;, PosReal(), None),
              # &#34;deuteron_source_weight_min&#34;: (&#34;swc1(15)&#34;, PosReal(), None),
              # &#34;triton_source_weight_min&#34;: (&#34;swc1(16)&#34;, PosReal(), None),
              # &#34;he3_source_weight_min&#34;: (&#34;swc1(17)&#34;, PosReal(), None),
              # &#34;he4_source_weight_min&#34;: (&#34;swc1(18)&#34;, PosReal(), None),
              # &#34;nucleon_source_weight_min&#34;: (&#34;swc1(19)&#34;, PosReal(), None),
              &#34;weight_window_max&#34;: (&#34;wupn&#34;, PosReal(), None),
              &#34;survival_weight&#34;: (&#34;wsurvn&#34;, PosReal(), None),
              # &#34;max_split&#34;: (&#34;mxwpln&#34;, PosReal(), None),
              # &#34;window_at&#34;: (&#34;mwhere&#34;, FinBij({&#34;reaction&#34;: -1, &#34;both&#34;: 0, &#34;reg_crossing&#34;: 1}), None),
              &#34;ww_bias&#34;: (&#34;iwwbias&#34;, Choice10(), None),
              &#34;std_cutoff&#34;: (&#34;istdcut&#34;, Choice10(), None),
              # &#34;only_cut_after_batch&#34;: (&#34;istdbat&#34;, PosInt(), None),
              &#34;stopping_model&#34;: (&#34;ndedx&#34;, FinBij({&#34;SPAR_nucleus_only+NTMC&#34;: 0, &#34;ATIMA+NTMC&#34;: 1, &#34;SPAR+NTMC&#34;: 2, &#34;ATIMA&#34;: 3}), None),
              &#34;atima_db_max&#34;: (&#34;mdbatima&#34;, PosInt(), None),
              &#34;atima_e_cutoff&#34;: (&#34;dbcutoff&#34;, PosReal(), None),
              &#34;atima_water_ion_e&#34;: (&#34;ih2o&#34;, NegDisable(), None),
              &#34;atima_effective_charge&#34;: (&#34;ifixchg&#34;, Choice10(), None),
              &#34;restricted_delta_LET&#34;: (&#34;irlet&#34;, Choice10(), None),
              &#34;elastic_scattering&#34;: (&#34;ielas&#34;, FinBij({None: 0, &#34;neutron&#34;: 1, &#34;both&#34;: 2}), None),
              &#34;elastic_angle_groups&#34;: (&#34;ielms&#34;, PosInt(), None),
              &#34;nucleon_model&#34;: (&#34;icxnp&#34;, FinBij({&#34;JAM&#34;: 0, &#34;JENDL&#34;: 1}), None),
              &#34;nucleon_nucleus_model&#34;: (&#34;icxsni&#34;, FinBij({&#34;Perlstein-Niita&#34;: 0, &#34;KUROTAMA&#34;: 1, &#34;Sato&#34;: 2}), None),
              &#34;nucleus_nucleus_model&#34;: (&#34;icrhi&#34;, FinBij({&#34;Shen&#34;: 0, &#34;NASA&#34;: 1, &#34;KUROTAMA&#34;: 2}), None),
              &#34;deuteron_model&#34;: (&#34;icrdm&#34;, FinBij({&#34;nuclear&#34;: 0, &#34;MWO&#34;: 1}), None),
              &#34;pion_induced_model&#34;: (&#34;icxspi&#34;, FinBij({&#34;geometrical&#34;: 0, &#34;Hashimoto&#34;: 1}), None),
              &#34;evap_model&#34;: (&#34;nevap&#34;, FinBij({None: 0, &#34;GEM&#34;: 3}), None),
              &#34;gem_version&#34;: (&#34;ngem&#34;, FinBij({1: 1, 2: 2}), None),
              &#34;fission_model&#34;: (&#34;ifission&#34;, FinBij({&#34;PHITS&#34;: 1, &#34;Iwamoto&#34;: 2}), None),
              &#34;gamma_decay_model&#34;: (&#34;igamma&#34;, FinBij({None: 0, &#34;PHITS&#34;: 1, &#34;EBITEM&#34;: 2, &#34;EBITEM isomer&#34;: 3,
                                                      &#34;PHITS no Doppler&#34;: -1, &#34;EBITEM no Doppler&#34;: -2, &#34;EBITEM no Doppler&#34;: -3}), None),
              &#34;statistical_multifrag_model&#34;: (&#34;ismm&#34;, Choice10(), None),
              &#34;event_generator&#34;: (&#34;e-mode&#34;, FinBij({None: 0, &#34;simple&#34;: 1, &#34;complicated&#34;: 2}), None),
              &#34;event_generator_max_e&#34;: (&#34;em-emode&#34;, PosReal(), None),
              &#34;neutron_kerma&#34;: (&#34;ikerman&#34;, Choice10(c_style=True), None),
              &#34;photon_kerma&#34;: (&#34;ikermap&#34;, Choice10(c_style=True), None),
              &#34;photon_adjoint&#34;: (&#34;iadjoint&#34;, Choice10(), None),
              &#34;bertini_nucleon_cross_section&#34;: (&#34;inmed&#34;, FinBij({&#34;free&#34;: 0, &#34;cugnon_old&#34;: 1, &#34;cugnon_new&#34;: 2}), None),
              &#34;bertini_angular_distribution&#34;: (&#34;andit&#34;,  FinBij({&#34;split&#34;: 0, &#34;isotropic&#34;: 1, &#34;forward&#34;: 2}), None),
              &#34;experimental_neutron_fission&#34;: (&#34;iidfs&#34;, Choice10(c_style=True), None),
              &#34;discrete_dwba_spectra&#34;: (&#34;idwba&#34;, Choice10(), None),
              # &#34;absorb_low_e_neg&#34;: (&#34;npdik&#34;, Choice10(c_style=True), None),
              &#34;neutron_capture_cutoff&#34;: (&#34;emcnf&#34;, PosReal(), None),
              &#34;fission_delayed_neutrons&#34;: (&#34;dnb&#34;, OneOf(FinBij({&#34;natural&#34;: -1, None: 0}), PosReal()), None),
              &#34;fission_neutron_production&#34;: (&#34;nonu&#34;, Choice10(), None),
              &#34;s_matrix_interpolation&#34;: (&#34;isaba&#34;, Choice10(), None),
              &#34;detailed_photon_cutoff&#34;: (&#34;emcpf&#34;, PosReal(), None),
              &#34;photon_coherent_scatter&#34;: (&#34;nocoh&#34;, Choice10(c_style=True), None),
              &#34;simple_brem&#34;: (&#34;ibad&#34;, Choice10(), None),
              &#34;brem_photon_count&#34;: (&#34;bnum&#34;, PosReal(), None),
              &#34;xray_photon_count&#34;: (&#34;xnum&#34;, PosReal(), None),
              &#34;substep_brem&#34;: (&#34;numb&#34;, Choice10(), None),
              # ipegs
              &#34;multiple_scattering&#34;: (&#34;imsegs&#34;, FinBij({&#34;PHITS-EGS5&#34;: 1, &#34;EGS5&#34;: 0}), None),
              # iegsout
              &#34;egs_rand_seed&#34;: (&#34;iegsrand&#34;, PosReal(), None),
              &#34;edge_photons&#34;: (&#34;iedgfl&#34;, Choice10(), None),
              &#34;edge_auger_electrons&#34;: (&#34;iauger&#34;, Choice10(), None),
              &#34;coherent_reyleigh_scattering&#34;: (&#34;iraylr&#34;, Choice10(), None),
              # lpolar
              # iunrst
              &#34;egs_material_size&#34;: (&#34;chard&#34;, Real(), None),
              &#34;icru90_corrections&#34;: (&#34;epstfl&#34;, Choice10(), None),
              &#34;densest_gas&#34;: (&#34;gasegs&#34;, PosReal(), None),
              &#34;compton_incoherent_scattering&#34;: (&#34;incohr&#34;, Choice10(), None),
              &#34;compton_doppler_broadening&#34;: (&#34;iprofr&#34;, Choice10(), None),
              &#34;electron_impact_ionization&#34;: (&#34;impacr&#34;, Choice10(), None),
              &#34;electron_impact_xray_split&#34;: (&#34;ieispl&#34;, Choice10(), None),
              &#34;electron_impact_xray_count&#34;: (&#34;neispl&#34;, PosInt(), None),
              &#34;brem_sample_polar_angle&#34;: (&#34;ibrdst&#34;, Choice10(), None),
              &#34;electron_pair_sample_polar_angle&#34;: (&#34;iprdst&#34;, Choice10(), None),
              &#34;photoelectron_sample_angle&#34;: (&#34;iphter&#34;, Choice10(), None),
              &#34;compton_bound_cross_section&#34;: (&#34;ibound&#34;, Choice10(), None),
              &#34;brem_cross_section_correction&#34;: (&#34;iaprim&#34;, FinBij({None: 2, &#34;modeled&#34;: 1, &#34;empirical&#34;: 0}), None),
              &#34;photonuclear_reactions&#34;: (&#34;ipnint&#34;, FinBij({None: 0, &#34;no_flourescence&#34;: 1, &#34;all&#34;: 2}), None),
              &#34;photonuclear_probability_weight&#34;: (&#34;pnimul&#34;, PosReal(), None),
              &#34;photon_induced_muon_production&#34;: (&#34;igmuppd&#34;, Choice10(), None),
              &#34;muon_capture&#34;: (&#34;imucap&#34;, FinBij({False: 0, True: 1, &#34;custom_xray&#34;: 2}), None),
              &#34;muon_induced_reactions&#34;: (&#34;imuint&#34;, Choice10(), None),
              &#34;muon_induced_brem&#34;: (&#34;imubrm&#34;, Choice10(), None),
              &#34;muon_induced_pairs&#34;: (&#34;imuppd&#34;, Choice10(), None),
              &#34;muon_induced_reaction_min&#34;: (&#34;emumin&#34;, PosReal(), None),
              &#34;muon_induced_reaction_max&#34;: (&#34;emumax&#34;, PosReal(), None),
              &#34;neutrino_induced_reaction&#34;: (&#34;ntrnore&#34;, Choice10(), None),
              &#34;angle_straggling&#34;: (&#34;nspred&#34;, FinBij({&#34;Lynch&#34;: 2, &#34;NTMCC&#34;: 1, None: 0}), None),
              &#34;lynch_params&#34;: ((&#34;ascat1&#34;, &#34;ascat2&#34;), (Real(), Real()), None),
              &#34;energy_straggling&#34;: (&#34;nedisp&#34;, Choice10(), None),
              &#34;gravity&#34;: ((&#34;gravx&#34;, &#34;gravy&#34;, &#34;gravz&#34;), (Real(), Real(), Real()), None),
              # usrmgt, usrelst
              &#34;magnetic_field&#34;: (&#34;imagnf&#34;, Choice10(), None),
              &#34;electromagnetic_field&#34;: (&#34;ielctf&#34;, Choice10(), None),
              # TODO: decide if users can recover output files from work directory (and, accordingly, if output options are necessary)
              # &#34;binary_cells&#34;:   (&#34;icells&#34;, FinBij({False: 3, True: }))
              }

    def restrictions(self):
        wmax = self.weight_window_max if self.weight_window_max is not None else 5
        wgt = self.survival_weight if self.survival_weight is not None else 0.6 * wmax
        if not (1 &lt; wgt &lt; wmax):
            raise ValueError(f&#34;One must have 1 &lt; survival_weight &lt; weight_window_max; got survival_weight={wgt}&#34;
                             f&#34;and weight_window_max={wmax}.&#34;)

        mhist = self.max_histories if self.max_histories is not None else 10
        mbch = self.max_batches if self.max_batches is not None else 10
        if mhist * mbch &gt; 2_147_483_647:
            raise ValueError(f&#34;History and batch maxima ({self.max_histories} and {self.max_batches}) will result in overflow.&#34;)

        for wc1, wc2 in zip(sorted(filter(lambda x: &#34;wc1&#34; in x[1][0], self.syntax.items()),
                                   key=lambda x: re.search(&#34;[1-9][0-9]*&#34;, x[1][0])[0]),
                            sorted(filter(lambda x: &#34;wc2&#34; in x[1][0], self.syntax.items()),
                                   key=lambda x: re.search(&#34;[1-9][0-9]*&#34;, x[1][0])[0])):
            v1 = getattr(self, wc1[0])
            v2 = getattr(self, wc2[0])
            if (v1 is not None and v2 is not None and v1 &lt;= v2) or (v1 is None and v2 is not None and v2 &gt;= 0.5):
                raise ValueError(f&#34;One must have {wc1[1][0]} &gt; {wc2[1][0]}; got {wc1[1][0]}={v1} and {wc2[1][0]}={v1}.&#34;)


    def __init__(self, **kwargs):
        extra = {k: kwargs[k] for k in set(kwargs) - set(self.syntax)}

        assert not extra, f&#34;Unrecognized parameters {extra} in initialization of Parameters object.&#34; \
            &#34;Check that the correct parameters were passed to other objects.&#34;
        for k, (_, spec, _) in self.syntax.items():
            if k in kwargs and kwargs[k] is not None:
                if isinstance(spec, tuple):
                    map(lambda x: spec.phits(x), kwargs[k])
                else:
                    spec.phits(kwargs[k])

                setattr(self, k, kwargs[k])
            else:
                setattr(self, k, None)

        self.restrictions()

    def __getitem__(self, key):
        return self.__dict__[key]

    def empty(self):
        return True if self.__dict__ == {&#34;name&#34;: &#34;parameters&#34;} else False

    def definition(self):
        inp = &#34;&#34;
        for var, val in  self.__dict__.items():
            if val is not None:
                if var in self.syntax:
                    phits_iden, valspec = self.syntax[var][0], self.syntax[var][1]
                    if isinstance(valspec, tuple):
                        for idx, spec in enumerate(valspec):
                            mapped = spec.phits(val[idx])
                            if callable(mapped):
                                raise mapped(var)
                            else:
                                inp += f&#34;{phits_iden[idx]} = {mapped}\n&#34;
                    else:
                        mapped = valspec.phits(val)
                        if callable(mapped):
                            raise mapped(var)
                        else:
                            inp += f&#34;{phits_iden} = {mapped}\n&#34;
        return inp

    def section_title(self) -&gt; str:
        &#34;&#34;&#34;Return the section title under which a PhitsObject belongs.&#34;&#34;&#34;
        sec_name = self.name.replace(&#34;_&#34;, &#34; &#34;).title()
        return f&#34;[{sec_name}]\n&#34;


    @classmethod
    def syntax_desc(self) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of the initialization syntax of the PhitsObject in question.
        Used to generate documentation, but is useful in interactive sessions to &#34;&#34;&#34;
        required = sorted([(k, v) for k, v in self.syntax.items() if v[2] is not None], key=lambda tup: tup[1][2])
        opt = [(k, v) for k, v in self.syntax.items() if v[2] is None]
        r = &#34;&#34;
        def capfirst(st):
            return st[0].upper() + st[1:]

        if required:
            r = &#34;Required arguments:\n\n|Position|Python name|PHITS name|Accepted value|\n|----|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in required:

                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;

        if opt:
            r += &#34;\nOptional arguments:\n\n|Python name|PHITS name|Accepted value|\n|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in opt:
                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;
        return r

    @classmethod
    def syntax_for(self, attr: str) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of a specific initialization parameter of the PhitsObject in question.&#34;&#34;&#34;
        r = &#34;PHITS name\tAccepted value\tPosition\n&#34;
        r += f&#34;{self.syntax[attr][0]}\t{self.syntax[attr][1]}\t{self.syntax[attr][2]}&#34;
        return r

    @classmethod
    def required_args(self):
        &#34;&#34;&#34;The required arguments from `self.syntax`, in order.&#34;&#34;&#34;
        return list(sorted(((k, v) for k, v in self.syntax.items() if v[2] is not None), key=lambda t: t[1][2]))

    @classmethod
    def optional_args(self):
        &#34;&#34;&#34;The optional arguments from `self.syntax`.&#34;&#34;&#34;
        return list(filter(lambda t: t[1][2] is None, self.syntax.items()))


def _tuplify(xs: list) -&gt; tuple:
    &#34;&#34;&#34;Convert lists to tuples for hashability purposes.&#34;&#34;&#34;
    return tuple(map(lambda x: _tuplify(x) if isinstance(x, list) else x, xs))

def _continue_lines(inp: str) -&gt; str:
    &#34;&#34;&#34;If a line is too long for PHITS to handle, attempt to line-break at whitespace.
    Works only for [Surface] and [Cell].&#34;&#34;&#34;
    r = &#34;&#34;
    for line in inp.split(&#34;\n&#34;):
        if len(line) &gt; 175:
            words = line.split(&#34; &#34;)
            length = 0

            remain = list(it.takewhile(lambda x: len(x[1]) &lt; 175, enumerate(it.accumulate(words, lambda x, y: x + &#34; &#34; + y))))
            contin = &#34; &#34;.join(words[remain[-1][0]+1:])
            remain = remain[-1][1]
            if contin == &#34;&#34; or contin.isspace():
                r += remain + &#34;\n&#34;
            else:
                r += remain + &#34;\n     &#34; + _continue_lines(contin)
        else:
            r += line + &#34;\n&#34;


    return r



## BASE
class PhitsObject:
    &#34;&#34;&#34;The base factory class distinguishing objects that are intended to end up in some section of a `.inp` file,
    and defining equality and hashability of such objects in sensible ways.

    PhitsObject values always correspond to some section of an input file.
    &#34;&#34;&#34;

    name = None
    &#34;&#34;&#34;A string corresponding to the PHITS .inp section an object appears in. See `PhitsObject.names`&#34;&#34;&#34;

    syntax = dict()
    &#34;&#34;&#34;A dictionary with entries of the form `&#34;python_identifier&#34;: (&#34;PHITS_identifier&#34;, acceptable_ValSpec, arg_position, Optional(none_val))`.
    The key is the attribute on the Python PhitsObject instance, and the keyword argument necessary to set it.
    The second is what type the object must be, as a ValSpec.
    The third is what index in `*args` the argument must have; if it is set to `None`, the argument is optional.
    The last is a value to put in the .inp if the attribute is `None` at compile-time; ordinarily, it&#39;s just nothing.
    The first two arguments can be tuples, in which case the passed value must be a tuple of the specified type;
    the single Python assignment corresponds to the entrywise assignments of this tuple to the PHITS identifiers in the .inp.&#34;&#34;&#34;

    shape = tuple()
    &#34;&#34;&#34;A tuple that details how the object is to be represented in the .inp file.
    The syntax is inspired by Emacs Lisp skeletons, with some optimizations to tailor it for this use-case.
    In general, the strings in the tuple are inserted verbatim, with a newline in between them.
    If an entry is the name of an attribute of the instance, say `&#34;attr&#34;` whose value is not `None`,
    then the string `PHITS_identifier = acceptable_ValSpec.phits(self.attr)`, based on a lookup of `attr` in `PhitsObject.syntax`, is inserted.
    If an entry is `self`, then `self.index` is inserted.
    To avoid the above two behaviors, and insert a string verbatim, prepend a quote `&#39;`.
    If an entry is another tuple, that tuple gets evaluated as above, but the `identifier = ` is not inserted,
    and a mere space separates the entries.
    Appending a `\\` to any string disables the insertion of the spacing that would otherwise follow;
    similarly, having `\\` as the last string of a tuple entry disables the newline that would otherwise follow.

    If this attribute is callable, it gets called on the instance of the PhitsObject, and the result is processed according to the rules above.
    &#34;&#34;&#34;

    index = None
    &#34;&#34;&#34;The compile-time assigned number of an object. Should not be set directly.&#34;&#34;&#34;

    # no_hash = {&#34;index&#34;, &#34;value_map&#34;, &#34;ident_map&#34;, &#34;nones&#34;, &#34;shape&#34;, &#34;subobjects&#34;, &#34;required&#34;, &#34;positional&#34;, &#34;optional&#34;,
    #            &#34;group_by&#34;, &#34;separator&#34;, &#34;prelude&#34;, &#34;max_groups&#34;, &#34;group_size&#34;, &#34;parser&#34;, &#34;validator&#34;}
    # &#34;&#34;&#34;Attributes that don&#39;t affect the identity of a PhitsObject.&#34;&#34;&#34;

    names = {&#34;parameters&#34;, &#34;source&#34;, &#34;material&#34;, &#34;surface&#34;, &#34;cell&#34;, &#34;transform&#34;, &#34;temperature&#34;,&#34;mat_time_change&#34;,&#34;magnetic_field&#34;,
             &#34;electromagnetic_field&#34;, &#34;frag_data&#34;, &#34;data_max&#34;,
             &#34;delta_ray&#34;, &#34;track_structure&#34;, &#34;super_mirror&#34;, &#34;elastic_option&#34;, &#34;importance&#34;, &#34;weight_window&#34;, &#34;ww_bias&#34;,
             &#34;forced_collisions&#34;, &#34;repeated_collisions&#34;, &#34;volume&#34;, &#34;multiplier&#34;, &#34;mat_name_color&#34;, &#34;reg_name&#34;, &#34;counter&#34;, &#34;timer&#34;,
             &#34;t-track&#34;, &#34;t-cross&#34;, &#34;t-point&#34;, &#34;t-adjoint&#34;, &#34;t-deposit&#34;, &#34;t-deposit2&#34;, &#34;t-heat&#34;, &#34;t-yield&#34;, &#34;t-product&#34;, &#34;t-dpa&#34;,
             &#34;t-let&#34;, &#34;t-sed&#34;, &#34;t-time&#34;, &#34;t-interact&#34;, &#34;t-dchain&#34;, &#34;t-wwg&#34;, &#34;t-wwbg&#34;, &#34;t-volume&#34;, &#34;t-gshow&#34;, &#34;t-rshow&#34;,&#34;t-3dshow&#34;}
    &#34;&#34;&#34;The permissible `PhitsObject.name`s.&#34;&#34;&#34;

    group_by = None
    &#34;&#34;&#34;A key function by which to group PhitsObjects together.
    These groups are necessary, for instance, in the `Importance` section, where one can set different importances for different particles
    in the same cell.&#34;&#34;&#34;

    separator = None
    &#34;&#34;&#34;A function returning a string to be placed between the definitions of the groups; see `PhitsObject.group_by`.&#34;&#34;&#34;

    max_groups = None
    &#34;&#34;&#34;The maximum number of groups of objects of a given type; see `PhitsObject.group_by`.&#34;&#34;&#34;

    prelude = tuple()
    &#34;&#34;&#34;A skeleton just like `PhitsObject.shape`, but inserted before all definitions of the `PhitsObject` subclass in question.&#34;&#34;&#34;
    subobjects = []
    &#34;&#34;&#34;A list of all `PhitsObject.name`s that can appear as attributes of the object in question.&#34;&#34;&#34;
    superobjects = []
    &#34;&#34;&#34;A list of all `PhitsObject.name`s that this object ought to be defined from.&#34;&#34;&#34;
    restrictions = lambda self: tuple()
    &#34;&#34;&#34;A function that&#39;s called right at the end of initialization. Should be used to raise errors for any combination of values
    that is incorect but not easily expressible via `ValSpec`s.&#34;&#34;&#34;
    def __init__(self, *args,  **kwargs):
        &#34;&#34;&#34;Arguments are interpreted according to `PhitsObject.syntax`, and then any leftovers in `kwargs` are used to create a `Parameters`
        object, which is then assigned to a `parameters` attribute.&#34;&#34;&#34;
        assert self.name in self.names, f&#34;Unrecognized PHITS type {self.name} in PhitsObject initialization.&#34;

        # Handle required args
        required = list(map(lambda tup: tup[0], self.required_args()))

        assert len(args) == len(required), f&#34;Wrong number of positional arguments specified in the definition of {self} object.&#34;
        for idx, arg in enumerate(args):
            # Validate first
            details = self.syntax[required[idx]]
            valspec = details[1]
            if isinstance(valspec, tuple):
                for id2, spec in enumerate(valspec):
                    mapped = spec.phits(arg[id2])
                    if callable(mapped):
                        raise mapped(required[idx])
            else:
                mapped = valspec.phits(arg)
                if callable(mapped):
                    raise mapped(required[idx])

            # Then set the attribute
            setattr(self, required[idx], arg if not isinstance(arg, list) else _tuplify(arg))

        # Handle optional args
        for arg in self.syntax:
            valspec, position = self.syntax[arg][1], self.syntax[arg][2]
            if position == None:
                if arg in kwargs:
                    # Validate first
                    if kwargs[arg] is not None:
                        if isinstance(valspec, tuple):
                            for idx, spec in enumerate(valspec):
                                mapped = spec.phits(kwargs[arg][idx])
                                if callable(mapped):
                                    raise mapped(arg)
                        else:
                            mapped = valspec.phits(kwargs[arg])
                            if callable(mapped):
                                raise mapped(arg)

                        # Then set the attribute
                        setattr(self, arg, kwargs[arg] if not isinstance(kwargs[arg], list) else _tuplify(kwargs[arg]))
                    else:
                        setattr(self, arg, None)
                else:
                    # Handle unpassed
                    setattr(self, arg, None)


        for attr in self.subobjects:
            if hasattr(self, attr):
                child = getattr(self, attr)
                if child is not None:
                    setattr(child, self.name, self)

        # for attr in self.superobjects:
        #     setattr(self, attr, None) # subobjects are instantiated before superobjects

        remaining = {k: v for k, v in kwargs.items() if k not in self.syntax and k not in self.subobjects}
        if remaining:
            self.parameters = Parameters(**remaining)

        # check restrictions satisfied
        self.restrictions()

    def _add_definition(self, how: tuple, to: str, assignments: bool = True) -&gt; str:
        &#34;&#34;&#34;Recursively performs skeleton insertions according to `how` at the end of `to`.&#34;&#34;&#34;
        if callable(how):
            how = how()

        for attr in how:

            endstr = &#34;\n&#34; if assignments else &#34; &#34;
            spacing = &#34; &#34;

            if isinstance(attr, str) and len(attr) &gt; 0 and attr[0] == &#34;&#39;&#34;:
                to += attr[1:]
                to += endstr
                continue

            if isinstance(attr, str) and len(attr) &gt; 0 and attr[-1] == &#34;\\&#34;:
                endstr = &#34; &#34;
                spacing = &#34;&#34;
                attr = attr[:-1]

            if isinstance(attr, tuple):
                to += self._add_definition(attr, &#34;&#34;, assignments=False)
                if attr[-1] == &#34;\\&#34;:
                    to += &#34; &#34;
                else:
                    to += &#34;\n&#34;

            elif attr in self.syntax:
                val = getattr(self, attr)
                phits_iden = self.syntax[attr][0]
                valspec = self.syntax[attr][1]
                noneval = &#34;&#34;
                if len(self.syntax[attr]) &gt; 3:
                    noneval = self.syntax[attr][3]

                if val is not None:
                    if isinstance(phits_iden, tuple):
                        for i, (phits, spec) in enumerate(zip(phits_iden, valspec)):
                            assign = f&#34;{phits}{spacing}={spacing}&#34; if assignments else &#34;&#34;
                            v = spec.phits(val[i])
                            if callable(v):
                                raise v(attr)
                            else:
                                to += f&#34;{assign}{v}{endstr}&#34;
                    else:
                        assign = f&#34;{phits_iden}{spacing}={spacing}&#34; if assignments else &#34;&#34;
                        v = valspec.phits(val)
                        if callable(v):
                            raise v(attr)
                        else:
                            to += f&#34;{assign}{v}{endstr}&#34;

                elif noneval != &#34;&#34; and noneval is not None: # I think we don&#39;t use nones for anything except the simplest case
                    to += str(noneval)
                    to += endstr


            else:
                if attr == &#34;self&#34;:
                    to += str(self.index)
                    to += endstr

                elif attr in self.superobjects: # can&#39;t use syntax because impredicativity in module imports
                    to += str(getattr(self, attr).index)
                    to += endstr
                else:
                    to += attr
                    to += endstr
        return to

    def prelude_str(self) -&gt; str:
        &#34;&#34;&#34;Return a string to appear before the collection of all definitions of subclass instances in an `.inp` file.&#34;&#34;&#34;
        inp = self._add_definition(self.prelude, &#34;&#34;)

        return inp

    def definition(self) -&gt; str:
        &#34;&#34;&#34;Return the string representing the particular PhitsObject in an `.inp` file.&#34;&#34;&#34;
        inp = self._add_definition(self.shape, &#34;&#34;)
        if self.name in [&#34;surface&#34;, &#34;cell&#34;]:
            return _continue_lines(inp)
        else:
            return inp

    def section_title(self) -&gt; str:
        &#34;&#34;&#34;Return the section title under which a PhitsObject belongs.&#34;&#34;&#34;
        sec_name = self.name.replace(&#34;_&#34;, &#34; &#34;).title()
        return f&#34;[{sec_name}]\n&#34;

    @classmethod
    def syntax_desc(self) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of the initialization syntax of the PhitsObject in question.
        Used to generate documentation, but is useful in interactive sessions to &#34;&#34;&#34;
        required = sorted([(k, v) for k, v in self.syntax.items() if v[2] is not None], key=lambda tup: tup[1][2])
        opt = [(k, v) for k, v in self.syntax.items() if v[2] is None]
        r = &#34;&#34;
        def capfirst(st):
            return st[0].upper() + st[1:]

        if required:
            r = &#34;Required arguments:\n\n|Position|Python name|PHITS name|Accepted value|\n|----|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in required:

                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;

        if opt:
            r += &#34;\nOptional arguments:\n\n|Python name|PHITS name|Accepted value|\n|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in opt:
                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;
        return r


    @classmethod
    def syntax_for(self, attr: str, phits=False) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of a specific initialization parameter of the PhitsObject in question.&#34;&#34;&#34;
        if phits:
            rev = self._syntax_reversed()
            r = &#34;Python name\tAccepted value\tPosition\n&#34;
            r += f&#34;{rev[attr][0]}\t{rev[attr][1]}\t{rev[attr][2]}&#34;
            return r
        else:
            r = &#34;PHITS name\tAccepted value\tPosition\n&#34;
            r += f&#34;{self.syntax[attr][0]}\t{self.syntax[attr][1]}\t{self.syntax[attr][2]}&#34;
            return r

    def _sanitize(self, iden: str) -&gt; str:
        &#34;&#34;&#34;Make a PHITS identifier Python-acceptable.
        See `readable_syntax`.
        &#34;&#34;&#34;
        r = iden.replace(&#34;-&#34;, &#34;_&#34;)
        r = r.replace(&#34;(&#34;, &#34;&#34;)
        r = r.replace(&#34;)&#34;, &#34;&#34;)
        if r[0].isdigit():
            if m := re.match(&#34;.*?_&#34;, r):
                r = r[m.end():] + &#34;_&#34; + r[:m.end() - 1]

        return r

    def _syntax_reversed(self):
        &#34;&#34;&#34;Produce a dictionary analogous to `PhitsObject.syntax` but using PHITS&#39;s names.&#34;&#34;&#34;
        return {v[0]: (k, *v[1:]) for k, v in self.syntax.items()}

    def __eq__(self, other: &#34;PhitsObject&#34;) -&gt; bool:
        &#34;&#34;&#34;PhitsObjects should be equal if their definitions would be the same.&#34;&#34;&#34;
        if type(self) != type(other):
            return False
        elif hasattr(self, &#34;__dict__&#34;) and hasattr(other, &#34;__dict__&#34;):
            d1 = {k: v for k, v in self.__dict__.items() if k in self.syntax}
            d2 = {k: v for k, v in other.__dict__.items() if k in self.syntax}
            return d1 == d2

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;PhitsObjects have the hash of their identity-defining attributes.&#34;&#34;&#34;
        return hash(tuple(v for k, v in sorted(self.__dict__.items())
                          if k in self.syntax and (self not in v.__dict__.values() if hasattr(v, &#34;__dict__&#34;) else True)))

    def _repr_pretty_(self, p, cycle) -&gt; str:
        &#34;&#34;&#34;Hypothesis uses this when printing failing cases.&#34;&#34;&#34;
        try:
            p.text(str(self.__dict__) + &#34;\n\n&#34; + self.definition())
        except:
            p.text(str(self.__dict__))

    @classmethod
    def required_args(self):
        &#34;&#34;&#34;The required arguments from `self.syntax`, in order.&#34;&#34;&#34;
        return list(sorted(((k, v) for k, v in self.syntax.items() if v[2] is not None), key=lambda t: t[1][2]))

    @classmethod
    def optional_args(self):
        &#34;&#34;&#34;The optional arguments from `self.syntax`.&#34;&#34;&#34;
        return list(filter(lambda t: t[1][2] is None, self.syntax.items()))


## DISTRIBUTION
class TimeDistribution(PhitsObject):
    &#34;&#34;&#34;An arbitrary distribution of source weights over time.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = {&#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal())), 0),
              &#34;last_bin&#34;: (None, PosReal(), 1),
              &#34;particle_production&#34;: (None, List(PosReal()), None)}

    shape = lambda slf: (&#34;t-type = 4&#34; if slf.particle_production else &#34;t-type = 3&#34;,
                         f&#34;ntt = {len(slf.bins)}&#34;,
                         &#34;\n&#34;.join(zastr(j[0]) + &#34; &#34; + str(j[1]) for j in slf.bins),
                         (&#34;last_bin&#34;,),
                         &#34;o-type = 1\n&#34; + &#34; &#34;.join((str(i) for i in slf.particle_production)) if slf.particle_production else &#34;&#34;)


class AngleDistribution(PhitsObject):
    &#34;&#34;&#34;An arbitrary distribution of source weights over angle.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = {&#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal())), 0),
              &#34;last_bin&#34;: (None, PosReal(), 1),
              &#34;unit&#34;: (&#34;a-type&#34;, FinBij({&#34;cos&#34;: 1, &#34;degree&#34;: 11}), None),
              &#34;particle_production&#34;: (None, List(PosReal()), None)}

    shape = lambda self: (&#34;a-type = 14&#34; if self.unit == &#34;degree&#34; else &#34;a-type = 4&#34;,
                          f&#34;na = {len(self.bins)}&#34;,
                          &#34;\n&#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.bins) + f&#34;\n{self.last_bin}&#34;,
                          &#34;q-type = 1\n&#34; + &#34; &#34;.join((str(i) for i in self.particle_production)) if self.particle_production \
                          else &#34;&#34;)

    def restrictions(self):
        if self.particle_production is not None and len(self.bins) != len(self.particle_production):
            raise ValueError(&#34;For EnergyDistribution: len(bins) must equal len(particle_production).&#34;)



class EnergyDistribution(PhitsObject):
    &#34;&#34;&#34;An arbitrary distribution of source weights over energy.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = {&#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal(), PosReal())), 0),
              &#34;adjust&#34;: (None, FinBij({&#34;particles&#34;: &#34;particles&#34;, &#34;weights&#34;: &#34;weights&#34;}), None),
              &#34;units&#34;: (None, FinBij({&#34;MeV&#34;: &#34;MeV&#34;, &#34;Angstrom&#34;: &#34;Angstrom&#34;}), None),
              &#34;normalize&#34;: (None, FinBij({&#34;1/Lethargy&#34;: -1, &#34;1/MeV&#34;: 1}), None), # TODO: check 1/MeV
              &#34;particle_production&#34;: (None, List(PosReal()), None)
              }

    shape = lambda slf: ((&#34;e-type = 22&#34; if slf.units == &#34;MeV&#34; else &#34;e-type = 32&#34;) if slf.adjust == &#34;particles&#34; else \
                          (&#34;e-type = 23&#34; if slf.units == &#34;MeV&#34; else &#34;e-type = 33&#34;),
                          f&#34;ne = -{len(slf.bins)}&#34; if slf.normalize == &#34;1/Lethargy&#34; else f&#34;ne = {len(slf.bins)}&#34;,
                          &#34;\n&#34;.join(&#34; &#34;.join(str(j) for j in i) for i in slf.bins),
                          &#34;p-type = 1\n&#34; + &#34; &#34;.join((str(i) for i in slf.particle_production)) if slf.particle_production else &#34;&#34;)
    def restrictions(self):
        if self.particle_production is not None and len(self.bins) != len(self.particle_production):
            raise ValueError(&#34;For EnergyDistribution: len(bins) must equal len(particle_production).&#34;)

# TODO: radioisotope, cosmicray

## TRANSFORM


class Transform(PhitsObject): #
    &#34;&#34;&#34;An \\(\\mathbb{R}^3\\) isometry represented by a translation vector and a rotation matrix.
    &#34;&#34;&#34;
    name = &#34;transform&#34;
    syntax = {&#34;translation&#34;: (None, Tuple(Real(), Real(), Real()), 0),
              &#34;rotation&#34;: (None, Tuple(Real(), Real(), Real()), 1),
              &#34;rotate_first&#34;: (None, FinBij({True: 2, False: -2}), None, -2),
              &#34;units&#34;: (None, FinBij({&#34;degrees&#34;: &#34;degrees&#34;, &#34;radians&#34;: &#34;radians&#34;}), None)}
    shape = lambda self: ((f&#34;*TR{self.index}&#34; if self.units == &#34;degrees&#34; else f&#34;TR{self.index}&#34;,
                           &#34; &#34;.join(str(i) for i in self.translation),
                           &#34; &#34;.join(str(i) for i in self.rotation),
                           &#34;0 0 0 0 0 0&#34;,
                           &#34;rotate_first&#34;),)

## SURFACE

surface_common = {&#34;reflective&#34;: (None, Choice10(), None),
          &#34;white&#34;: (None, Choice10(), None),
          &#34;transform&#34;: (None, IsA(Transform, index=True), None),
          &#34;inside&#34;: (None, Choice10(), None)}


class Plane(PhitsObject):
    &#34;&#34;&#34;A plane of the form Ax + By + Cz - D = 0.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;A&#34;: (None, Real(), 0),
                       &#34;B&#34;: (None, Real(), 1),
                       &#34;C&#34;: (None, Real(), 2),
                       &#34;D&#34;: (None, Real(), 3)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;P&#34;, &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;),)

    def restrictions(self):
        if self.A == 0 and self.B == 0 and self.C == 0:
            raise ValueError(&#34;For Plane: at least one of A, B, or C must be nonzero.&#34;)


# TODO: consider obliterating the next 2
class PointPlane(PhitsObject):
    &#34;&#34;&#34;A plane specified by three points.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;p1&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;p2&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;p3&#34;: (None, Tuple(Real(), Real(), Real()), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;P&#34;,
                           f&#34;{self.p1[0]}&#34;, f&#34;{self.p1[1]}&#34;, f&#34;{self.p1[2]}&#34;,
                           f&#34;{self.p2[0]}&#34;, f&#34;{self.p2[1]}&#34;, f&#34;{self.p2[2]}&#34;,
                           f&#34;{self.p3[0]}&#34;, f&#34;{self.p3[1]}&#34;, f&#34;{self.p3[2]}&#34;),)

    def restrictions(self):
        if self.p1[0] * (self.p2[1] - self.p3[1]) + self.p2[0] * (self.p3[1] - self.p1[1]) \
           + self.p3[0] * (self.p1[1] - self.p2[1]) == 0: # i.e. points are colinear
            raise ValueError(&#34;For PointPlane: p1, p2, and p3 must not line on a line;&#34;
                             f&#34; got p1={self.p1}, p2={self.p2}, and p3={self.p3}.&#34;)


class ParallelPlane(PhitsObject):
    &#34;&#34;&#34;A plane of the form x_i = D.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;parallel&#34;: (None, FinBij({&#34;x&#34;: &#34;X&#34;, &#34;y&#34;: &#34;Y&#34;, &#34;z&#34;:&#34;Z&#34;}), 0),
                       &#34;D&#34;: (None, Real(), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, f&#34;P{self.parallel}&#34;, &#34;D&#34;),)


class Sphere(PhitsObject):
    &#34;A sphere of radius R centered on (x0, y0, z0).&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;radius&#34;: (None, PosReal(), 0),
                       &#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;SPH&#34;, f&#34;{self.center[0]}&#34;, f&#34;{self.center[1]}&#34;, f&#34;{self.center[2]}&#34;, &#34;radius&#34;),)


class Cylinder(PhitsObject):
    &#34;&#34;&#34;A right-circular cylinder with center of the bottom face (x_0, y_0, z_0), height vector from the bottom to top face (H_x, H_y, H_z),
    and radius R.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;height&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;radius&#34;: (None, PosReal(), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;RCC&#34;, &#34; &#34;.join(str(i) for i in self.center), &#34; &#34;.join(str(i) for i in self.height), &#34;radius&#34;),)

    def restrictions(self):
        if self.height == (0, 0, 0):
            raise ValueError(&#34;Cylinder must have a nonzero height vector.&#34;)

class Cone(PhitsObject):
    &#34;&#34;&#34;A truncated right-angle cone with bottom-face center (x_0, y_0, z_0), height vector (H_x, H_y, H_z), and bottom and top radii
    R_1 and R_2 respectively.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                               &#34;height&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                               &#34;radii&#34;: ((&#34;top&#34;, &#34;bottom&#34;), Interval(0), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;TRC&#34;, &#34;center&#34;, &#34;height&#34;, &#34;radii&#34;),)

    def restrictions(self):
        if self.height == (0, 0, 0):
            raise ValueError(&#34;Cone must have a nonzero height vector.&#34;)




class SimpleConic(PhitsObject): # ellipsoid, hyperboloid, or paraboloid parallel to an axis of the form
                   # A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+2D(x-x0)+2E(y-y0)+2F(z-z0)+G = 0
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;quadratic&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;linear&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;constant&#34;: (None, Real(), 2),
                       &#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 3)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;SQ&#34;, &#34;quadratic&#34;, &#34;linear&#34;, &#34;constant&#34;, &#34;center&#34;),)



class GeneralConic(PhitsObject): # ellipsoid, hyperboloid, or paraboloid of the form
                    # A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+Dxy+Eyz+Fzx+Gx+Hy+Jz+K = 0
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;quadratic&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;mixed&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;linear&#34;: ((None, None, None), (Real(), Real(), Real()), 2),
                       &#34;constant&#34;: (None, Real(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;GQ&#34;, &#34;quadratic&#34;, &#34;mixed&#34;, &#34;linear&#34;, &#34;constant&#34;),)

# TODO: I don&#39;t know what &#34;skewed&#34; means for transfomations on tori, so disabling for now.
class Torus(PhitsObject): # torus parallel to an axis of the form
             # (axisvar - axis0)^2/B^2 + (quadrature(&lt;non-axis displacements&gt;) - A)^2 - 1 = 0
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;axis&#34;: (None, FinBij({&#34;x&#34;: &#34;X&#34;, &#34;y&#34;: &#34;Y&#34;, &#34;z&#34;:&#34;Z&#34;}), 0),
                       &#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;scales&#34;: ((None, None, None), (PosReal(), PosReal(), PosReal()), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           f&#34;T{self.axis}&#34;, &#34;center&#34;, &#34;scales&#34;),)



class Box(PhitsObject): # box formed by three vectors with tails at a given base point, or cross product of 3 intervals,
           # stored in the form x0 y0 z0 Ax Ay Az Bx By Bz Cx Cy Cz
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;base&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;walls&#34;: (None, OrthogonalMatrix(), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;BOX&#34;, &#34;base&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.walls)),)


# Too complicated to generate
# class HexagonalPrism(PhitsObject):
#     name = &#34;surface&#34;
#     syntax = surface_common | {&#34;base&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
#                        &#34;height&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
#                        &#34;s1&#34;: ((None, None, None), (Real(), Real(), Real()), 2),
#                        &#34;s2&#34;: ((None, None, None), (Real(), Real(), Real()), 3),
#                        &#34;s3&#34;: ((None, None, None), (Real(), Real(), Real()), 4)}

#     shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
#                            (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
#                            &#34;transform&#34;, &#34;HEX&#34;, &#34;base&#34;, &#34;height&#34;, &#34;s1&#34;, &#34;s2&#34;, &#34;s3&#34;),)

#     def restrictions(self):
#         if self.height == (0, 0, 0) or self.s1 == (0, 0, 0) or self.s2 == (0, 0, 0) or self.s3 == (0, 0, 0):
#             raise ValueError(&#34;HexagonalPrism must have a nonzero height vector.&#34;)


class EllipticalCylinder(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;axes&#34;: (None, OrthogonalMatrix(), 1)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;REC&#34;, &#34;center&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.axes)),)



class Spheroid(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;focus1&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;focus2&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;major_axis&#34;: (None, Real(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;ELL&#34;, &#34;focus1&#34;, &#34;focus2&#34;, &#34;major_axis&#34;),)
    def restrictions(self):
        if self.focus1 == self.focus2:
            raise ValueError(f&#34;Spheroid must have distinct foci; got focus1={self.focus1} and focus2={self.focus2}.&#34;)

        if self.major_axis == 0:
            raise ValueError(&#34;Spheroid must have a nonzero major axis length.&#34;)

        if self.major_axis - np.linalg.norm(np.array(self.focus1) - np.array(self.focus2)) &lt;= 0:
            raise ValueError(&#34;Spheroid must have nonzero major axis length larger than the distance betwen its foci;&#34;
                             f&#34; got major_axis={self.major_axis}, focus1={self.focus1}, and focus2={self.focus2}.&#34;)


class Wedge(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;tip&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;sides&#34;: (None, OrthogonalMatrix(), 1)}


    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;WED&#34;, &#34;tip&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.sides)),)



class TetrahedronBox(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;xrange&#34;: ((None, None), Interval(), 0),
                               &#34;yrange&#34;: ((None, None), Interval(), 1),
                               &#34;zrange&#34;: ((None, None), Interval(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                            (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                            &#34;transform&#34;, &#34;RPP&#34;, &#34;xrange&#34;, &#34;yrange&#34;, &#34;zrange&#34;),)



_surface_spec = OneOf(IsA(Plane, index=True), IsA(PointPlane, index=True), IsA(ParallelPlane, index=True),
                     IsA(Sphere, index=True), IsA(Cylinder, index=True), IsA(Cone, index=True), IsA(SimpleConic, index=True),
                     IsA(GeneralConic, index=True), IsA(Box, index=True), # IsA(Torus, index=True), IsA(HexagonalPrism, index=True),
                     IsA(EllipticalCylinder, index=True), IsA(Spheroid, index=True), IsA(Wedge, index=True), IsA(TetrahedronBox, index=True))

## MISC

class MagneticField(PhitsObject):
    &#34;&#34;&#34;A uniform magnetic field in a region, affecting charged particles.&#34;&#34;&#34;
    name = &#34;magnetic_field&#34;
    syntax = {&#34;typ&#34;: (None, FinBij({&#34;dipole&#34;: 2, &#34;quadrupole&#34;: 4}), 0),
              &#34;strength&#34;: (None, Real(), 1),
              &#34;calc_freq&#34;: (None, PosReal(), None, 0.0),
              &#34;transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;time&#34;: (None, PosReal(), None, &#34;non&#34;),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;&#39;typ&#34;, &#34;&#39;gap&#34;, &#34;mgf&#34;, &#34;trcl&#34;, &#34;&#39;time&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ&#34;, &#34;calc_freq&#34;, &#34;strength&#34;, &#34;transform&#34;, &#34;time&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()

class NeutronMagneticField(PhitsObject):
    &#34;&#34;&#34;A uniform magnetic field in a region, affecting neutrons via spin.&#34;&#34;&#34;
    name = &#34;magnetic_field&#34;
    syntax = {&#34;typ&#34;: (None, FinBij({&#34;identified&#34;: 60, &#34;nograv&#34;: 61, &#34;dipole&#34;: 102,
                                    &#34;quadrupole&#34;: 104, &#34;sextupole&#34;: 106}), 0),
              &#34;strength&#34;: (None, Real(), 1),
              &#34;calc_freq&#34;: (None, PosReal(), None, 0.0),
              &#34;polarization&#34;: (None, Real(), None, &#34;non&#34;),
              &#34;transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;time&#34;: (None, PosReal(), None, &#34;non&#34;),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;&#39;typ&#34;, &#34;&#39;gap&#34;, &#34;mgf&#34;, &#34;trcl&#34;, &#34;polar&#34;, &#34;&#39;time&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ&#34;, &#34;calc_freq&#34;, &#34;strength&#34;, &#34;transform&#34;, &#34;polarization&#34;, &#34;time&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()


class MappedMagneticField(PhitsObject):
    &#34;&#34;&#34;A non-uniform magnetic field in a region, affecting charged particles, given by a file.&#34;&#34;&#34;
    name = &#34;magnetic_field&#34;
    syntax = {&#34;typ&#34;: (None, FinBij({&#34;xyz_list_charged&#34;: -1, &#34;rz_list_charged&#34;: -2, &#34;xyz_map_charged&#34;: -3, &#34;rz_map_charged&#34;: -4,
                                    &#34;xyz_list_neutron&#34;: -101, &#34;rz_list_neutron&#34;: -102, &#34;xyz_map_neutron&#34;: -103, &#34;rz_map_neutron&#34;: -104}), 0),
              &#34;normalization&#34;: (None, Real(), 1),
              &#34;calc_freq&#34;: (None, PosReal(), 2),
              &#34;m_file&#34;: (None, Path(), 3),
              &#34;transform&#34;: (None, IsA(Transform, index=True), None, 0),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;&#39;typ&#34;, &#34;gap&#34;, &#34;mgf&#34;, &#34;trcl&#34;, &#34;file&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ&#34;, &#34;calc_freq&#34;, &#34;normalization&#34;, &#34;transform&#34;, &#34;m_file&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()



class ElectromagneticField(PhitsObject):
    &#34;&#34;&#34;A uniform electromagnetic field within a region, affecting charged particles.&#34;&#34;&#34;
    name = &#34;electromagnetic_field&#34;
    syntax = {&#34;e_strength&#34;: (None, Real(), 0),
              &#34;m_strength&#34;: (None, Real(), 1),
              &#34;e_transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;m_transform&#34;: (None, IsA(Transform, index=True), None, 0),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;elf&#34;, &#34;mgf&#34;, &#34;trcle&#34;, &#34;trclm&#34;),)
    shape = ((&#34;cell&#34;, &#34;e_strength&#34;, &#34;m_strength&#34;, &#34;e_transform&#34;, &#34;m_transform&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()



class MappedElectromagneticField(PhitsObject):
    &#34;&#34;&#34;A non-unifrom electromagnetic field within a region, affecting charged particles, given by a file.&#34;&#34;&#34;
    name = &#34;electromagnetic_field&#34;
    syntax = {&#34;typ_e&#34;: (None, FinBij({&#34;xyz_list_charged&#34;: -1, &#34;rz_list_charged&#34;: -2, &#34;xyz_map_charged&#34;: -3, &#34;rz_map_charged&#34;: -4}), 0),
              &#34;typ_m&#34;: (None, FinBij({&#34;xyz_list_charged&#34;: -1, &#34;rz_list_charged&#34;: -2, &#34;xyz_map_charged&#34;: -3, &#34;rz_map_charged&#34;: -4}), 1),
              &#34;calc_freq&#34;: (None, PosReal(), 2),
              &#34;e_normalization&#34;: (None, Real(), 3),
              &#34;m_normalization&#34;: (None, Real(), 4),
              &#34;e_file&#34;: (None, Path(), 5),
              &#34;m_file&#34;: (None, Path(), 6),
              &#34;e_transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;m_transform&#34;: (None, IsA(Transform, index=True), None, 0)}
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;type&#34;, &#34;typm&#34;, &#34;gap&#34;, &#34;elf&#34;, &#34;mgf&#34;, &#34;trcle&#34;, &#34;trclm&#34;, &#34;filee&#34;, &#34;filem&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ_e&#34;, &#34;typ_m&#34;, &#34;calc_freq&#34;, &#34;e_normalization&#34;, &#34;m_normalization&#34;, &#34;e_transform&#34;, &#34;m_transform&#34;, &#34;e_file&#34;, &#34;m_file&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()



class DeltaRay(PhitsObject):
    &#34;&#34;&#34;A threshold energy fo each cell, above which delta rays are to be produced.&#34;&#34;&#34;
    name = &#34;delta_ray&#34;
    syntax = {&#34;threshold&#34;: (None, RealBetween(1, None), 0),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;del&#34;),)
    shape = ((&#34;cell&#34;, &#34;threshold&#34;),)



class TrackStructure(PhitsObject):
    &#34;&#34;&#34;Cell-by-cell setting of the track-structure model used for electrons/positrons.&#34;&#34;&#34;
    name = &#34;track_structure&#34;
    syntax = {&#34;model&#34;: (None, FinBij({&#34;none&#34;: 0, &#34;general&#34;: -1, &#34;optimized&#34;: 1}), 0)}
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;mID&#34;),)
    shape = lambda self: ((&#34;cell&#34;, &#34;model&#34;),)




class ElasticOption(PhitsObject):
    &#34;&#34;&#34;Parameters for the user-specified elastic scattering law Fortran subroutines.&#34;&#34;&#34;
    name = &#34;elastic_option&#34;
    syntax = {&#34;c1&#34;: (None, PosReal(), 1),
              &#34;c2&#34;: (None, PosReal(), 2),
              &#34;c3&#34;: (None, PosReal(), 3),
              &#34;c4&#34;: (None, PosReal(), 4)}

    prelude = ((&#34;reg&#34;, &#34;&#39;c1&#34;, &#34;&#39;c2&#34;, &#34;&#39;c3&#34;, &#34;&#39;c4&#34;),)
    shape = ((&#34;cell&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;c3&#34;, &#34;c4&#34;),)
    superobjects = [&#34;cell&#34;]



class FragData(PhitsObject):
    &#34;&#34;&#34;Enables user-defined cross-sections for a particular interaction in a cell.&#34;&#34;&#34;
    name = &#34;frag_data&#34;
    syntax = {&#34;semantics&#34;: (None, FinBij({&#34;histogram&#34;: 1, &#34;extrapolated&#34;: 4, &#34;interpolated&#34;: 5}), 0),
              &#34;projectile&#34;: (None, OneOf(FinBij({&#34;proton&#34;: &#34;proton&#34;, &#34;neutron&#34;: &#34;neutron&#34;}), Nuclide(fake=True)), 1),
              &#34;target&#34;: (None, Nuclide(fake=True), 2),
              &#34;file&#34;: (None, Path(), 3)}
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;opt&#34;, &#34;proj&#34;, &#34;targ&#34;, &#34;&#39;file&#34;),)
    shape = ((&#34;semantics&#34;, &#34;projectile&#34;, &#34;target&#34;, &#34;file&#34;),)



class Importance(PhitsObject):
    &#34;&#34;&#34;Change the relative tally weight of certain particles in a cell.&#34;&#34;&#34;
    name = &#34;importance&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;importance&#34;: (None, PosReal(), 1),
              }
    superobjects = [&#34;cell&#34;]
    prelude = (&#34;particles&#34;, (&#34;reg&#34;, &#34;imp&#34;))
    shape = ((&#34;cell&#34;, &#34;importance&#34;),)
    group_by = lambda self: self.particles
    separator = lambda self: self.section_title()
    max_groups = 6

    @classmethod
    def global_restrictions(self, type_divided):
        all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;importance&#34;])))
        if len(set(all_particles)) &lt; len(all_particles):
            raise ValueError(&#34;Integration problem: all Importances must have mutually disjoint lists of particles.&#34;)


class WeightWindow(PhitsObject):
    &#34;&#34;&#34;Makes the tally weight of some particle(s) in a region a function of time or energy.&#34;&#34;&#34;
    name = &#34;weight_window&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;variable&#34;: (None, FinBij({&#34;energy&#34;: &#34;energy&#34;, &#34;time&#34;: &#34;time&#34;}), 2),
              &#34;windows&#34;: (None, List(Tuple(PosReal(), PosReal())), 1),
              }
    superobjects = [&#34;cell&#34;]
    prelude = lambda self: (&#34;mesh = reg&#34;, &#34;particles&#34;,
                            f&#34;eng = {len(self.windows)}&#34; if self.variable == &#34;energy&#34; else f&#34;tim = {len(self.windows)}&#34;,
                            &#34; &#34;.join(map(lambda t: str(t[0]), self.windows)),
                            (&#34;reg&#34;, &#34; &#34;.join(f&#34;ww{i}&#34; for i in range(1, len(self.windows) + 1))))
    shape = lambda self: ((&#34;cell&#34;, &#34; &#34;.join(map(lambda t: str(t[1]), self.windows))),)
    group_by = lambda self: (self.particles, self.variable)
    separator = lambda self: self.section_title()
    max_groups = 6

    @classmethod
    def global_restrictions(self, type_divided):
        all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;weight_window&#34;])))
        if len(set(all_particles)) &lt; len(all_particles):
            raise ValueError(&#34;Integration problem: all WeightWindows must have mutually disjoint lists of particles.&#34;)



class WWBias(PhitsObject):
    &#34;&#34;&#34;Some magic with regards to the &#34;variance reduction tecnique.&#34;&#34;&#34;
    name = &#34;ww_bias&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;biases&#34;: (None, List(Tuple(PosReal(), PosReal())), 1),
              }
    superobjects = [&#34;cell&#34;]
    prelude = lambda self: (&#34;particles&#34;, f&#34;eng = {len(self.biases)}&#34;, &#34; &#34;.join(map(lambda t: str(t[0]), self.biases)),
                            (&#34;reg&#34;, &#34; &#34;.join(f&#34;wwb{i}&#34; for i in range(1, len(self.biases) + 1))))
    shape = lambda self: ((&#34;cell&#34;, &#34; &#34;.join(map(lambda t: str(t[1]), self.biases))),)
    group_by = lambda self: self.particles
    separator = lambda self: self.section_title()
    max_groups = 6






class ForcedCollisions(PhitsObject):
    &#34;&#34;&#34;Changes the way tallies are calculated in a region for better measurement of low-probability interactions, \
    such as thin targets, or for improving statistics.&#34;&#34;&#34;
    name = &#34;forced_collisions&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;factor&#34;: (None, RealBetween(-1, 1), 1),
              &#34;force_secondaries&#34;: (None, FinBij({True: 1, False: -1}), None),
              }

    superobjects = [&#34;cell&#34;]
    prelude = (&#34;particles&#34;, (&#34;reg&#34;, &#34;fcl&#34;))
    shape = lambda self: ((&#34;cell&#34;, f&#34;{self.force_secondaries * self.factor}&#34; if self.force_secondaries is not None \
                           else str(self.factor)),)

    group_by = lambda self: self.particles

    separator = lambda self: self.section_title()
    max_groups = 6

    def restrictions(self):
        if &#34;electron&#34; in self.particles or &#34;positron&#34; in self.particles:
            raise ValueError(f&#34;ForcedCollision does not accept electrons or positrons; got {self.particles}.&#34;)

    def global_restrictions(self, type_divided):
        all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;forced_collisions&#34;])))
        if len(set(all_particles)) &lt; len(all_particles):
            raise ValueError(&#34;Integration problem: all ForcedCollisions must have mutually disjoint lists of particles.&#34;)



class RepeatedCollisions(PhitsObject):
    &#34;&#34;&#34;Similar to `ForcedCollisions`, changes tally calculation in a region for low-probability interactions, \
    but with an eye towards rare, secondary-particle-producing reactions.&#34;&#34;&#34;
    name = &#34;repeated_collisions&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(fake=True), unique=True), 0),
              &#34;collision_reps&#34;: (None, PosInt(), 1),
              &#34;evaporation_reps&#34;:  (None, PosInt(), 2),
              &#34;mother&#34;: (None, List(Nuclide(fake=True)), 3),
              &#34;ebounds&#34;: ((&#34;emin&#34;, &#34;emax&#34;), (PosReal(), PosReal()), None),

              }

    superobjects = [&#34;cell&#34;]
    prelude = lambda self: (&#34;particles&#34;,
                            f&#34;mother = {len(self.mother)}&#34; if self.mother else &#34;&#34;,
                            (&#34;mother&#34;,),
                            &#34;ebounds&#34;, (&#34;reg&#34;, &#34;n-coll&#34;, &#34;n-evap&#34;))
    shape = ((&#34;cell&#34;, &#34;collision_reps&#34;, &#34;evaporation_reps&#34;),)

    group_by = lambda self: (self.particles, self.mother)
    separator = lambda self: self.section_title()
    max_groups = 6

    def restrictions(self):
        if self.collision_reps * self.evaporation_reps &lt;= 1 or self.collision_reps * self.evaporation_reps &gt;= 2_147_483_647:
            raise ValueError(f&#34;RepeatedCollisions&#39; product of repititions must be more than 1 as an int32;&#34;
                             f&#34; got collsion_reps={self.collision_reps} and evaporation_reps={self.evaporation_reps}.&#34;)
        if self.ebounds is not None and self.ebounds[0] &gt;= self.ebounds[1]:

            raise ValueError(f&#34;RepeatedCollisions&#39; ebounds must be ordered; got {self.ebounds}.&#34;)

    @classmethod
    def global_restrictions(self, type_divided):
        for rc in type_divided[&#34;repeated_collisions&#34;]:
            possible = set(map(lambda x: kf_encode(x[0]), rc.cell.material.composition))
            if any(kf_encode(x) not in possible for x in rc.mother):
                raise ValueError(f&#34;Integration problem: RepeatedCollisions&#39; mother nuclei must be among its cell&#39;s material&#39;s nuclei;&#34;
                                 f&#34; got {set(rc.mother) - possible} extra.&#34;)


# Relevant only for tallies we don&#39;t support.
# class Multiplier(PhitsObject):
#     name = &#34;multiplier&#34;
#     syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True, max_len=6), 0),
#               &#34;semantics&#34;: (&#34;interpolation&#34;, FinBij({&#34;linear&#34;: &#34;lin&#34;, &#34;log&#34;: &#34;log&#34;, &#34;left_histogram&#34;: &#34;glow&#34;,
#                                                      &#34;right_histogram&#34;: &#34;ghigh&#34;}), 1),
#               &#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal())), 2)}
#     shape = lambda self: (f&#34;number = -{200 + self.index}&#34;, &#34;semantics&#34;, &#34;particles&#34;, f&#34;ne = {len(self.bins)}&#34;,
#                           &#34;\n&#34;.join(map(lambda t: f&#34;{t[0]} {t[1]}&#34;, self.bins)))



class RegionName(PhitsObject):
    &#34;&#34;&#34;Names a region in graphical output. Useful when `make_input`ing to visualise geometries.&#34;&#34;&#34;
    name = &#34;reg_name&#34;
    syntax = {&#34;reg_name&#34;: (None, Text(), 0),
              &#34;size&#34;: (None, PosReal(), 1),
              }
    superobjects = [&#34;cell&#34;]
    shape = ((&#34;cell&#34;, &#34;reg_name&#34;, &#34;size&#34;),)



# TODO: optional arguments?
class Counter(PhitsObject):
    &#34;&#34;&#34;Configures one of three counters, which can track all manner of things. Results accessible through tallies.&#34;&#34;&#34;
    name = &#34;counter&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(OneOf(Particle(), Nuclide()), max_len=20, unique=True), 0),
              &#34;entry&#34;: (None, Between(-9999, 10000), 1),
              &#34;exit&#34;: (None, Between(-9999, 10000), 2),
              &#34;collision&#34;: (None, Between(-9999, 10000), 3),
              &#34;reflection&#34;: (None, Between(-9999, 10000), 4),
              }

    superobjects = [&#34;cell&#34;]
    prelude = (&#34;particles&#34;, (&#34;reg&#34;, &#34;in&#34;, &#34;out&#34;, &#34;coll&#34;, &#34;ref&#34;))
    shape = ((&#34;cell&#34;, &#34;entry&#34;, &#34;exit&#34;, &#34;collision&#34;, &#34;reflection&#34;),)

    group_by = lambda self: self.particles
    separator = lambda self: self.section_title() + f&#34;counter = {self.index}\n&#34;
    max_groups = 3



class Timer(PhitsObject):
    &#34;&#34;&#34;Configures the way time-of-flight is calculated within a region&#34;&#34;&#34;
    name = &#34;timer&#34;
    syntax = {&#34;entry&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 1),
              &#34;exit&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 2),
              &#34;collision&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 3),
              &#34;reflection&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 4),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;in&#34;, &#34;out&#34;, &#34;coll&#34;, &#34;ref&#34;),)
    shape = ((&#34;cell&#34;, &#34;entry&#34;, &#34;exit&#34;, &#34;collision&#34;, &#34;reflection&#34;),)

## MATERIAL
_tester = Nuclide()
def _decomposition(composition):
    &#34;&#34;&#34;Turns a composition list into PHITS input form.&#34;&#34;&#34;
    r = &#34;&#34;
    for nuc, ratio in composition:
        conv = _tester.phits(nuc)
        if callable(conv):
            raise conv(&#34;composition&#34;)
        else:
            r += f&#34;{conv} {ratio} &#34;
    return r

class DataMax(PhitsObject):
    &#34;&#34;&#34;Sets the maximum energy for an interaction between particles and nucleus in the material.&#34;&#34;&#34;
    name = &#34;data_max&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(FinBij({&#34;proton&#34;: &#34;proton&#34;, &#34;neutron&#34;: &#34;neutron&#34;}), unique=True), 0),
              &#34;nucleus&#34;: (None, Nuclide(fake=True), 1),
              &#34;max_energy&#34;: (None, PosReal(), 2)}
    superobjects = [&#34;material&#34;]
    prelude = (&#34;particles&#34;, (&#34;mat&#34;, &#34;&#39;nucleus&#34;, &#34;dmax&#34;))
    # Manual lies about accepting the usual syntax for nuclides
    shape = lambda self: ((&#34;material&#34;, &#34;nucleus&#34;, &#34;max_energy&#34;),)
    group_by = lambda self: (self.particles,)
    separator = lambda self: self.section_title()
    max_groups = 6

class MatNameColor(PhitsObject):
    &#34;&#34;&#34;Sets a name and color of a material. Useful when `make_input`ing to visualise geometries.&#34;&#34;&#34;
    name = &#34;mat_name_color&#34;
    syntax = {&#34;mat_name&#34;: (None, Text(), 0),
              &#34;size&#34;: (None, PosReal(), 1),
              &#34;color&#34;: (None, Color(), 2)} # TODO: color

    superobjects = [&#34;material&#34;]
    prelude = ((&#34;mat&#34;, &#34;name&#34;, &#34;&#39;size&#34;, &#34;&#39;color&#34;),)
    shape = ((&#34;material&#34;, &#34;mat_name&#34;, &#34;size&#34;, &#34;color&#34;),)


# TODO: temporarily setting the composition to be integer-only to cut down on length.
# TODO: also temporarily setting JENDL4Nuclide() to enable testing; it looks like Parameters() can change this error behavior,
# so should be set back to Nuclide() in production
# TODO: Nuclide-by-nuclide library setting
class Material(PhitsObject): # Composition is a list of pairs of (&lt;element name string&gt;, &lt;ratio&gt;) e.g. (&#34;8Li&#34;, 0.5)
    &#34;&#34;&#34;Sets up a material with which a `Cell` will be filled, including all relevant nuclear information.&#34;&#34;&#34;
    name = &#34;material&#34;
    syntax = {&#34;composition&#34;: (None, List(Tuple(JENDL4Nuclide(), PosInt()), unique_by=lambda x: kf_encode(x[0])), 0),
              &#34;gas&#34;: (&#34;GAS&#34;, Choice10(), None),
              &#34;electron_step&#34;: (&#34;ESTEP&#34;, PosInt(), None), # TODO: check integer right
              &#34;neutron_lib&#34;: (&#34;NLIB&#34;, LibraryID(), None),
              &#34;photon_lib&#34;: (&#34;PLIB&#34;, LibraryID(), None),
              &#34;electron_lib&#34;: (&#34;ELIB&#34;, LibraryID(), None),
              &#34;proton_lib&#34;: (&#34;HLIB&#34;, LibraryID(), None),
              &#34;conductor&#34;: (&#34;COND&#34;, FinBij({False: -1, True: 1}), None),
              &#34;thermal_lib&#34;: (None, ThermalLib(), None),
              &#34;chemical&#34;: (&#34;chem&#34;, List(Tuple(Chemical(), PosInt())), None),
              &#34;data_max&#34;: (None, IsA(DataMax, index=True), None),
              &#34;mat_name_color&#34;: (None, IsA(MatNameColor, index=True), None)
              }
    subobjects = [&#34;data_max&#34;, &#34;mat_time_change&#34;, &#34;mat_name_color&#34;]
    shape = lambda self: (f&#34;MAT[{self.index}]&#34;,
                          _decomposition(self.composition),
                          &#34;gas&#34;, &#34;electron_step&#34;, # &#34;neutron_lib&#34;, &#34;photon_lib&#34;, &#34;electron_lib&#34;, &#34;proton_lib&#34;,
                          &#34;conductor&#34;,
                          &#34;chem = &#34; + &#34; &#34;.join(ch + &#34; &#34; + str(den) for ch, den in self.chemical) \
                          if self.chemical is not None else &#34;&#34;,
                          f&#34;MT{self.index} &#34; + self.syntax[&#34;thermal_lib&#34;][1].phits(self.thermal_lib) \
                          if self.thermal_lib is not None else &#34;&#34;
                          )

    def restrictions(self):
        if any(map(lambda x: int(str(_tester.phits(x[0]))[:-3]) &gt; 92, self.composition)) and \
           (not hasattr(self, &#34;parameters&#34;) or not hasattr(self.parameters, &#34;stoping_model&#34;) or \
            &#34;ATIMA&#34; in self.parameters.stopping_model):
            raise ValueError(&#34;Material cannot have nuclei with Z &gt; 92 and ATIMA set at the same time;&#34;
                             &#34; please pass stopping_model=SPAR+NTMC to the material.&#34;)




## SURFACE

surface_common = {&#34;reflective&#34;: (None, Choice10(), None),
          &#34;white&#34;: (None, Choice10(), None),
          &#34;transform&#34;: (None, IsA(Transform, index=True), None),
          &#34;inside&#34;: (None, Choice10(), None)}


class Plane(PhitsObject):
    &#34;&#34;&#34;A plane of the form Ax + By + Cz - D = 0.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;A&#34;: (None, Real(), 0),
                       &#34;B&#34;: (None, Real(), 1),
                       &#34;C&#34;: (None, Real(), 2),
                       &#34;D&#34;: (None, Real(), 3)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;P&#34;, &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;),)

    def restrictions(self):
        if self.A == 0 and self.B == 0 and self.C == 0:
            raise ValueError(&#34;For Plane: at least one of A, B, or C must be nonzero.&#34;)


# TODO: consider obliterating the next 2
class PointPlane(PhitsObject):
    &#34;&#34;&#34;A plane specified by three points.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;p1&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;p2&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;p3&#34;: (None, Tuple(Real(), Real(), Real()), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;P&#34;,
                           f&#34;{self.p1[0]}&#34;, f&#34;{self.p1[1]}&#34;, f&#34;{self.p1[2]}&#34;,
                           f&#34;{self.p2[0]}&#34;, f&#34;{self.p2[1]}&#34;, f&#34;{self.p2[2]}&#34;,
                           f&#34;{self.p3[0]}&#34;, f&#34;{self.p3[1]}&#34;, f&#34;{self.p3[2]}&#34;),)

    def restrictions(self):
        if self.p1[0] * (self.p2[1] - self.p3[1]) + self.p2[0] * (self.p3[1] - self.p1[1]) \
           + self.p3[0] * (self.p1[1] - self.p2[1]) == 0: # i.e. points are colinear
            raise ValueError(&#34;For PointPlane: p1, p2, and p3 must not line on a line;&#34;
                             f&#34; got p1={self.p1}, p2={self.p2}, and p3={self.p3}.&#34;)


class ParallelPlane(PhitsObject):
    &#34;&#34;&#34;A plane of the form x_i = D.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;parallel&#34;: (None, FinBij({&#34;x&#34;: &#34;X&#34;, &#34;y&#34;: &#34;Y&#34;, &#34;z&#34;:&#34;Z&#34;}), 0),
                       &#34;D&#34;: (None, Real(), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, f&#34;P{self.parallel}&#34;, &#34;D&#34;),)


class Sphere(PhitsObject):
    &#34;A sphere of radius R centered on (x0, y0, z0).&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;radius&#34;: (None, PosReal(), 0),
                       &#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;SPH&#34;, f&#34;{self.center[0]}&#34;, f&#34;{self.center[1]}&#34;, f&#34;{self.center[2]}&#34;, &#34;radius&#34;),)


class Cylinder(PhitsObject):
    &#34;&#34;&#34;A right-circular cylinder with center of the bottom face (x_0, y_0, z_0), height vector from the bottom to top face (H_x, H_y, H_z),
    and radius R.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;height&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;radius&#34;: (None, PosReal(), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;RCC&#34;, &#34; &#34;.join(str(i) for i in self.center), &#34; &#34;.join(str(i) for i in self.height), &#34;radius&#34;),)

    def restrictions(self):
        if self.height == (0, 0, 0):
            raise ValueError(&#34;Cylinder must have a nonzero height vector.&#34;)

class Cone(PhitsObject):
    &#34;&#34;&#34;A truncated right-angle cone with bottom-face center (x_0, y_0, z_0), height vector (H_x, H_y, H_z), and bottom and top radii
    R_1 and R_2 respectively.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;height&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;bottom_r&#34;: (None, PosReal(), 2),
                       &#34;top_r&#34;: (None, PosReal(), 3)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;TRC&#34;, &#34; &#34;.join(str(i) for i in self.center), &#34; &#34;.join(str(i) for i in self.height), &#34;bottom_r&#34;, &#34;top_r&#34;),)

    def restrictions(self):
        if self.height == (0, 0, 0):
            raise ValueError(&#34;Cone must have a nonzero height vector.&#34;)

        if self.bottom_r &lt;= self.top_r:
            raise ValueError(&#34;Cone must have a top radius smaller than its bottom radius;&#34;
                             f&#34; got bottom_r={self.bottom_r} and top_r={self.top_r}.&#34;)




class SimpleConic(PhitsObject):
    &#34;&#34;&#34;An ellipsoid, hyperboloid, or paraboloid parallel to an axis, of the mathematical form \
    \\(A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+2D(x-x0)+2E(y-y0)+2F(z-z0)+G = 0\\).&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;quadratic&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;linear&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;constant&#34;: (None, Real(), 2),
                       &#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 3)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;SQ&#34;, &#34;quadratic&#34;, &#34;linear&#34;, &#34;constant&#34;, &#34;center&#34;),)



class GeneralConic(PhitsObject): # ellipsoid, hyperboloid, or paraboloid of the form
                    # A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+Dxy+Eyz+Fzx+Gx+Hy+Jz+K = 0
    &#34;&#34;&#34;An arbitrary ellipsoid, hyperboloid, or paraboloid, of the mathematical form \
    \\(A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+Dxy+Eyz+Fzx+Gx+Hy+Jz+K = 0\\).&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;quadratic&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;mixed&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;linear&#34;: ((None, None, None), (Real(), Real(), Real()), 2),
                       &#34;constant&#34;: (None, Real(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;GQ&#34;, &#34;quadratic&#34;, &#34;mixed&#34;, &#34;linear&#34;, &#34;constant&#34;),)


class Torus(PhitsObject):
    &#34;&#34;&#34;A torus parallel to an axis, of the mathematical form \
    \\((x - x_0)^2/B^2 + (\sqrt{(y - y_0)^2 + (z - z_0)^2} - A)^2 - 1 = 0\\) (where the variable quantities may be permuted).&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;axis&#34;: (None, FinBij({&#34;x&#34;: &#34;X&#34;, &#34;y&#34;: &#34;Y&#34;, &#34;z&#34;:&#34;Z&#34;}), 0),
                       &#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;scales&#34;: ((None, None, None), (Real(), PosReal(), PosReal()), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           f&#34;T{self.axis}&#34;, &#34;center&#34;, &#34;scales&#34;),)

    def restrictions(self):
        if self.scales[0] == 0 or self.scales[1] == 0 or self.scales[2] == 0:
            raise ValueError(f&#34;Torus&#39;s scales must be nonzero; got {self.scales}&#34;)
        # if self.transform is not None and not self.transform.rotate_first: # skew
        #     raise ValueError()


class Box(PhitsObject): # box formed by three vectors with tails at a given base point, or cross product of 3 intervals,
           # stored in the form x0 y0 z0 Ax Ay Az Bx By Bz Cx Cy Cz
    &#34;&#34;&#34;A box given by a displacement vector to a corner and three orthogonal vectors defining its walls.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;base&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;walls&#34;: (None, OrthogonalMatrix(), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;BOX&#34;, &#34;base&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.walls)),)


# Too complicated to generate
# class HexagonalPrism(PhitsObject):
#     name = &#34;surface&#34;
#     syntax = surface_common | {&#34;base&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
#                        &#34;height&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
#                        &#34;s1&#34;: ((None, None, None), (Real(), Real(), Real()), 2),
#                        &#34;s2&#34;: ((None, None, None), (Real(), Real(), Real()), 3),
#                        &#34;s3&#34;: ((None, None, None), (Real(), Real(), Real()), 4)}

#     shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
#                            (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
#                            &#34;transform&#34;, &#34;HEX&#34;, &#34;base&#34;, &#34;height&#34;, &#34;s1&#34;, &#34;s2&#34;, &#34;s3&#34;),)

#     def restrictions(self):
#         if self.height == (0, 0, 0) or self.s1 == (0, 0, 0) or self.s2 == (0, 0, 0) or self.s3 == (0, 0, 0):
#             raise ValueError(&#34;HexagonalPrism must have a nonzero height vector.&#34;)


class EllipticalCylinder(PhitsObject):
    &#34;&#34;&#34;An ellipse extruded into a cylinder, given by a center point and a three orthogonal vectors defining the extrusion and axes.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;axes&#34;: (None, OrthogonalMatrix(), 1)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;REC&#34;, &#34;center&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.axes)),)



class Spheroid(PhitsObject):
    &#34;&#34;&#34;An ellipsoid of revolution given by two foci and an axis length (major is positive, minor is negative).&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;focus1&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;focus2&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;major_axis&#34;: (None, Real(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;ELL&#34;, &#34;focus1&#34;, &#34;focus2&#34;, &#34;major_axis&#34;),)
    def restrictions(self):
        if self.focus1 == self.focus2:
            raise ValueError(f&#34;Spheroid must have distinct foci; got focus1={self.focus1} and focus2={self.focus2}.&#34;)

        if self.major_axis == 0:
            raise ValueError(&#34;Spheroid must have a nonzero axis length.&#34;)

        if self.major_axis - np.linalg.norm(np.array(self.focus1) - np.array(self.focus2)) &lt;= 0:
            raise ValueError(&#34;Spheroid must have nonzero axis length larger than the distance betwen its foci;&#34;
                             f&#34; got major_axis={self.major_axis}, focus1={self.focus1}, and focus2={self.focus2}.&#34;)


class Wedge(PhitsObject):
    &#34;&#34;&#34;A (right-triangle) wedge shape given by a tip point and three orthogonal vectors forming the sides.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;tip&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;sides&#34;: (None, OrthogonalMatrix(), 1)}


    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;WED&#34;, &#34;tip&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.sides)),)



class TetrahedronBox(PhitsObject):
    &#34;&#34;&#34;An especially simple `Box` whose sides are parallel to the axes; required as the surface containing `Tetrahedral`&#39;s \
    tetrahedrons.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;xrange&#34;: ((None, None), (Real(), Real()), 0),
                       &#34;yrange&#34;: ((None, None), (Real(), Real()), 1),
                       &#34;zrange&#34;: ((None, None), (Real(), Real()), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                            (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                            &#34;transform&#34;, &#34;RPP&#34;, &#34;xrange&#34;, &#34;yrange&#34;, &#34;zrange&#34;),)

    def restrictions(self):
        if self.xrange[0] &gt;= self.xrange[1] or self.yrange[0] &gt;= self.yrange[1] or self.zrange[0] &gt;= self.zrange[1]:
            raise ValueError(&#34;EllipticalCylinder must have well-formed range intevals;&#34;
                             f&#34; got xrange={self.xrange}, yrange={self.yrange}, zrange={self.zrange}.&#34;)

# TODO: Torus, HexagonalPrism
_surface_spec = OneOf(IsA(Plane, index=True), IsA(PointPlane, index=True), IsA(ParallelPlane, index=True),
                     IsA(Sphere, index=True), IsA(Cylinder, index=True), IsA(Cone, index=True), IsA(SimpleConic, index=True),
                     IsA(GeneralConic, index=True), IsA(Box, index=True), # IsA(Torus, index=True), IsA(HexagonalPrism, index=True),
                     IsA(EllipticalCylinder, index=True), IsA(Spheroid, index=True), IsA(Wedge, index=True),
                     IsA(TetrahedronBox, index=True))


## CELL

_subobject_syntax = {&#34;magnetic_field&#34;: (None, OneOf(IsA(MagneticField, index=True), IsA(NeutronMagneticField, index=True), ), None),
                                                   # IsA(MappedMagneticField, index=True)), None),
                    &#34;electromagnetic_field&#34;: (None, OneOf(IsA(ElectromagneticField, index=True),), None),
                                                          # IsA(MappedElectromagneticField, index=True)), None),
                    &#34;delta_ray&#34;: (None, IsA(DeltaRay, index=True), None),
                    &#34;track_structure&#34;: (None, IsA(TrackStructure, index=True), None),
                    &#34;elastic_option&#34;: (None, IsA(ElasticOption, index=True), None),
                    &#34;importance&#34;: (None, IsA(Importance, index=True), None),
                    &#34;weight_window&#34;: (None, IsA(WeightWindow, index=True), None),
                    &#34;ww_bias&#34;: (None, IsA(WWBias, index=True), None),
                    &#34;forced_collisions&#34;: (None, IsA(ForcedCollisions, index=True), None),
                    &#34;repeated_collisions&#34;: (None, IsA(RepeatedCollisions, index=True), None),
                    &#34;reg_name&#34;: (None, IsA(RegionName, index=True), None),
                    &#34;counter&#34;: (None, IsA(Counter, index=True), None),
                    &#34;timer&#34;: (None, IsA(Timer, index=True), None)}

_cell_common_syntax = _subobject_syntax | {&#34;volume&#34;: (&#34;VOL&#34;, PosReal(), None),
                                           &#34;temperature&#34;: (&#34;TMP&#34;, PosReal(), None),
                                           &#34;transform&#34;: (&#34;TRCL&#34;, IsA(Transform, index=True), None)}

class Tetrahedral(PhitsObject):
    &#34;&#34;&#34;A `Cell` that&#39;s a box filled with tetrahedrons from a file. Extremely computationally efficient.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, IsA(TetrahedronBox, index=True), 0),
                              &#34;material&#34;: (None, IsA(Material, index=True), 1),
                              &#34;density&#34;: (None, PosReal(), 2),
                              &#34;tet_format&#34;: (None, FinBij({&#34;tetgen&#34;: &#34;tetgen&#34;, &#34;NASTRAN&#34;: &#34;NASTRAN&#34;}), 1),
                              &#34;tet_file&#34;: (None, Path(), 2),
                              &#34;scale_factor&#34;: (&#34;TSFAC&#34;, PosReal(), None)}

    shape = lambda self: ((&#34;self&#34;, &#34;material&#34;, &#34;density&#34;, &#34;regions&#34;, &#34;\\&#34;),
                          &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;LAT=3\\&#34;,
                          f&#34;tfile={self.tet_file}&#34; if self.tet_format == &#34;tetgen&#34; else f&#34;nfile={self.tet_file}&#34;, &#34;scale_factor&#34;)

    subobjects = set(_subobject_syntax.keys())

    # def restrictions(self):
    #     if len(self.regions) != 1:
    #         raise ValueError(f&#34;Tetrahedral cells may have only one TetrahedronBox region; got {self.regions}&#34;)
        # if self.forced_collisions is not None and self.repeated_collisions is not None:
        #     raise ValueError(f&#34;Cannot set both forced_collisions and repeated_collisions on a Tetrahedral cell.&#34;)

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r
    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r



class Void(PhitsObject):
    &#34;&#34;&#34;A `Cell` with no material, just vacuum.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, RegionTuple(_surface_spec), 0)}
    shape = lambda self: ((&#34;self&#34;, &#34;0&#34;, &#34;regions&#34;, &#34;\\&#34;), &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;&#34;)
    subobjects = set(_subobject_syntax.keys())

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r

    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r



class OuterVoid(PhitsObject):
    &#34;&#34;&#34;Void, but different for some reason. Probably shouldn&#39;t be used directly;
    `run_phits` creates the required OuterVoid for you automatically.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, RegionTuple(_surface_spec), 0)}
    shape = lambda self: ((&#34;self&#34;, &#34;-1&#34;, &#34;regions&#34;, &#34;\\&#34;), &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;&#34;)
    subobjects = set(_subobject_syntax.keys())

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r
    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r


class Cell(PhitsObject):
    &#34;&#34;&#34;The prototypical `Cell`, consisting of the intersection of several regions defined by surfaces with a material of some density.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, RegionTuple(_surface_spec), 0),
                              &#34;material&#34;: (None, IsA(Material, index=True), 1),
                              &#34;density&#34;: (None, PosReal(), 2)}
    shape = lambda self: ((&#34;self&#34;, &#34;material&#34;, &#34;density&#34;, &#34;regions&#34;, &#34;\\&#34;),
                          &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;&#34;)

    subobjects = set(_subobject_syntax.keys())

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r

    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r

_cell_spec = OneOf(IsA(Cell, index=True), IsA(Tetrahedral, index=True), IsA(Void, index=True))
# idea: generate a UUID for the universe/fill, and then map UUIDs -&gt; index at runtime
# other idea: make a Universe class, define an __init__, and make a call to super() for the normal __init__,
# but use the rest of __init__ to set the right attributes on the underlying cells, and marshall definitions
# def fill_universe(mask: Cell, contents: list[Cell]):
#     pass

## MISC 2

class SuperMirror(PhitsObject):
    &#34;&#34;&#34;Enables calculation of low-energy neutron super-mirror reflections off the boundary between two `Cell`s via an empirical formula.\
    &#34;&#34;&#34;
    name = &#34;super_mirror&#34;
    syntax = {&#34;into&#34;: (&#34;r-in&#34;, IsA(Cell, index=True), 0),
              &#34;from&#34;: (&#34;r-out&#34;, IsA(Cell, index=True), 1),
              &#34;reflection_surface&#34;: ((None, None), (_surface_spec, _surface_spec), 2),
              &#34;material_constant&#34;: (None, Real(), 3),
              &#34;reflectivity&#34;: (None, Real(), 4),
              &#34;critical_q&#34;: (None, Real(), 5),
              &#34;falloff_rate&#34;: (None, Real(), 6),
              &#34;cutoff_width&#34;: (None, PosReal(), 7)}

    prelude = ((&#34;r-in&#34;, &#34;r-out&#34;, &#34;mm&#34;, &#34;r0&#34;, &#34;qc&#34;, &#34;am&#34;, &#34;wm&#34;),)
    shape = ((&#34;reflection_surface&#34;, &#34;material_constant&#34;, &#34;reflectivity&#34;, &#34;critical_q&#34;, &#34;falloff_rate&#34;, &#34;cutoff_width&#34;),)

class MatTimeChange(PhitsObject):
    &#34;&#34;&#34;At a certain time, change the material old to material new.&#34;&#34;&#34;
    name = &#34;mat_time_change&#34;
    syntax = {&#34;time&#34;: (None, PosReal(), 0),
              &#34;new&#34;: (None, IsA(Material, index=True), 1),
              &#34;old&#34;: (None, IsA(Material, index=True), 2)}
    prelude = ((&#34;mat&#34;, &#34;&#39;time&#34;, &#34;change&#34;),)
    shape = ((&#34;old&#34;, &#34;time&#34;, &#34;new&#34;),)



## SOURCE

# TODO: global scaling factor totfact, and correlation option iscorr. Something with group_by?

# removed from projectile spec: FinBij({&#34;all&#34;: &#34;all&#34;})
_source_common = {&#34;projectile&#34;: (&#34;proj&#34;, List(OneOf(Particle(), Nuclide())), 0),
          &#34;spin&#34;: ((&#34;sx&#34;, &#34;sy&#34;, &#34;sz&#34;), (PosReal(), PosReal(), PosReal()), None),
          &#34;mask&#34;: ((&#34;reg&#34;, &#34;ntmax&#34;), (IsA(Cell, index=True), PosInt()), None),
          &#34;transform&#34;: (&#34;trcl&#34;, IsA(Transform, index=True), None),
          &#34;weight&#34;: (&#34;wgt&#34;, PosReal(), None),
          &#34;charge_override&#34;: (&#34;izst&#34;, PosReal(), None),
          &#34;counter_start&#34;: ((&#34;cnt(1)&#34;, &#34;cnt(2)&#34;, &#34;cnt(3)&#34;), (PosInt(), PosInt(), PosInt()), None),
          &#34;fissile&#34;: (&#34;ispfs&#34;, FinBij({False: 0, &#34;fissions&#34;: 1, &#34;neutrons&#34;: 2}), None)
          # ibatch?
          }

_source_semi_common = {&#34;elevation&#34;: (&#34;dir&#34;, OneOf(RealBetween(0.0, 1.0), FinBij({&#34;isotropic&#34;: &#34;all&#34;}), IsA(AngleDistribution)), None),
               &#34;azimuth&#34;: (&#34;phi&#34;, PosReal(), None),
               &#34;dispersion&#34;: (&#34;dom&#34;, OneOf(PosReal(), FinBij({&#34;cos^2&#34;: -1})), None),
               # &#34;energy&#34;: (&#34;e0&#34;, PosReal(), 1), unsupported; just use a uniform energy distribution
               &#34;spectrum&#34;: (None, IsA(EnergyDistribution), 1)}



class Cylindrical(PhitsObject):
    &#34;&#34;&#34;A cylindrical solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                        &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                        &#34;radius&#34;: (&#34;r0&#34;, PosReal(), None),
                        &#34;cutout_radius&#34;: (&#34;r1&#34;, PosReal(), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 1&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;charge_override&#34;, &#34;counter_start&#34;,
                          &#34;fissile&#34;, &#34;center&#34;, &#34;zbounds&#34;, &#34;radius&#34;, &#34;cutout_radius&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if (self.radius is None or self.radius == 0) and self.cutout_radius is not None:
            raise ValueError(&#34;Cylindrical sources that specify a cutout radius must also specify a nonzero radius;&#34;
                             &#34;got cutout_radius={self.cutout_radius}.&#34;)
        if self.radius is not None and self.cutout_radius is not None and self.radius &lt; self.cutout_radius:
            raise ValueError(&#34;Cylindrical sources cannot have cutouts larger than their radius;&#34;
                             f&#34;got radius={self.radius} and cutout_radius={self.cutout_radius}.&#34;)

class Rectangular(PhitsObject):
    &#34;&#34;&#34;A rectangular solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;xbounds&#34;: ((&#34;x0&#34;, &#34;x1&#34;), (Real(), Real()), None),
                       &#34;ybounds&#34;: ((&#34;x0&#34;, &#34;x1&#34;), (Real(), Real()), None),
                       &#34;zbounds&#34;: ((&#34;x0&#34;, &#34;x1&#34;), (Real(), Real()), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 2&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;charge_override&#34;, &#34;counter_start&#34;,
                          &#34;fissile&#34;, &#34;xbounds&#34;, &#34;ybounds&#34;, &#34;zbounds&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))




class Gaussian(PhitsObject):
    &#34;&#34;&#34;A Gaussian source from every direction.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;fwhms&#34;: ((&#34;x1&#34;, &#34;y1&#34;, &#34;z1&#34;), (PosReal(), PosReal(), PosReal()), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 3&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;fwhms&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                          else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

class GaussianSlices(PhitsObject):
    &#34;&#34;&#34;A 2D Gaussian source, uniform in the \\(z\\)-axis.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;fwhm&#34;: (&#34;r1&#34;, PosReal(), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 13&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;fwhm&#34;, &#34;zbounds&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                          else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))




class Parabolic(PhitsObject):
    &#34;&#34;&#34;A parabolic source from every direction.&#34;&#34;&#34;
    name = &#34;source&#34;

    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;width&#34;: ((&#34;x1&#34;, &#34;y1&#34;), (PosReal(), PosReal()), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                       &#34;order&#34;: (&#34;rn&#34;, Between(2, 2147483647), None) # PHITS&#39;s default INTEGER is 32-bit; if something&#39;s bigger,
                                                                     # their  0 (mod 2) check of multiplying and dividing by 2 fails.
                       } | _source_semi_common
    shape = lambda self: (&#34;s-type = 7&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;width&#34;, &#34;zbounds&#34;, &#34;order&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if self.order is not None and self.order % 2 != 0:
            raise ValueError(f&#34;The order of a Parabolic source must be even; got order={self.order}.&#34;) # TODO: needed?
        if self.zbounds is not None and self.zbounds[0] &gt; self.zbounds[1]:
            raise ValueError(f&#34;The the zbounds of a Parabolic source must be a well-formed interval; got zbounds={self.zbounds}.&#34;)


class ParabolicSlices(PhitsObject):
    &#34;&#34;&#34;A parabolic source, uniform along the \\(z\\)-axis.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;width&#34;: (&#34;r1&#34;, Real(), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                       &#34;order&#34;: (&#34;rn&#34;, Between(2, 2147483647), None)
                       } | _source_semi_common
    shape = lambda self: (&#34;s-type = 15&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;width&#34;, &#34;zbounds&#34;, &#34;order&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if self.order is not None and self.order % 2 != 0:
            raise ValueError(f&#34;The order of a ParabolicPrism source must be even; got order={self.order}.&#34;) # TODO: needed?
        if self.zbounds is not None and self.zbounds[0] &gt; self.zbounds[1]:
            raise ValueError(f&#34;The the zbounds of a ParabolicPrism source must be a well-formed interval; got zbounds={self.zbounds}.&#34;)


# dir = iso not supported
class Spherical(PhitsObject):
    &#34;&#34;&#34;A spherical or spherical-shell solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;r_in&#34;: (&#34;r1&#34;, PosReal(), None),
                       &#34;r_out&#34;: (&#34;r2&#34;, PosReal(), None),
                       # &#34;elevation_bounds&#34;: ((&#34;ag1&#34;, &#34;ag2&#34;), (Real(), Real()), None),
                       # &#34;azimuth_bounds&#34;: ((&#34;pg1&#34;, &#34;pg2&#34;), (Real(), Real()), None),
                       &#34;elevation&#34;: (&#34;dir&#34;, OneOf(RealBetween(0.0, 1.0), FinBij({&#34;all&#34;: &#34;all&#34;}), IsA(AngleDistribution)), None),
                       # TODO: this elevation and this elevation only doesn&#39;t work if I set FinBij({&#34;isotropic&#34;: &#34;all&#34;}).
                       &#34;resample_cutoff&#34;: (&#34;isbias&#34;, Choice10(), None),
                       &#34;spectrum&#34;: (None, IsA(EnergyDistribution), 1)}
    shape = lambda self: (&#34;s-type = 9&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;r_in&#34;, &#34;r_out&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;resample_cutoff&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if (self.elevation == &#34;isotropic&#34; and self.r_in is not None and (self.r_out is None or self.r_out == 0)) \
           or (self.elevation == &#34;isotropic&#34; and self.r_in is not None and self.r_out is not None and self.r_in &lt;= self.r_out):
            raise ValueError(&#34;Spherical sources with isotropic elevation must have greater inner radius than outer radius;&#34;
                             f&#34;got r_in={self.r_in} and r_out={self.r_out}.&#34;)


        if (self.elevation != &#34;isotropic&#34; and self.r_in is not None and (self.r_out is None or self.r_out == 0)) \
           or (self.elevation != &#34;isotropic&#34; and self.r_in is not None and self.r_out is not None and self.r_in &gt; self.r_out):
            raise ValueError(&#34;Spherical sources that specify an inner radius must also specify a greater outer radius;&#34;
                             f&#34;got r_in={self.r_in} and r_out={self.r_out}.&#34;)


class Beam(PhitsObject): # I don&#39;t understand what this is trying to do
    &#34;&#34;&#34;A beam-like source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;eccentricity&#34;: ((&#34;x1&#34;, &#34;y1&#34;), (Real(), Real()), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                       &#34;phase_gradients&#34;: ((&#34;rx&#34;, &#34;ry&#34;), (Real(), Real()), None),
                       &#34;sampling&#34;: (&#34;wem&#34;, OneOf(FinBij({&#34;gaussian&#34;: 0}), PosReal()), None),
                       &#34;dispersion&#34;: ((&#34;x1&#34;, &#34;y1&#34;), (Real(), Real()), None),
                       &#34;angle_dispersion&#34;: ((&#34;xmrad1&#34;, &#34;ymrad1&#34;), (PosReal(), PosReal()), None),
                       &#34;phase_center&#34;: ((&#34;x2&#34;, &#34;y2&#34;), (Real(), Real()), None),
                       &#34;phase_angle_center&#34;: ((&#34;xmrad2&#34;, &#34;ymrad2&#34;), (Real(), Real()), None),
                       &#34;positive&#34;: (&#34;dir&#34;, FinBij({True: 1, False: -1}), None),
                       &#34;spectrum&#34;: (None, IsA(EnergyDistribution), 1)}

    shape = (&#34;s-type = 11&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
             &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;eccentricity&#34;, &#34;zbounds&#34;, &#34;phase_gradients&#34;, &#34;sampling&#34;, &#34;dispersion&#34;,
             &#34;angle_dispersion&#34;, &#34;phase_center&#34;, &#34;phase_angle_center&#34;, &#34;positive&#34;, (&#34;spectrum&#34;,))


# decay-turtle??????


class Conical(PhitsObject):
    &#34;&#34;&#34;A conical solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;top&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;altitude&#34;: ((&#34;x1&#34;, &#34;y1&#34;, &#34;z1&#34;), (Real(), Real(), Real()), None),
                       &#34;trim&#34;: ((&#34;r0&#34;, &#34;r1&#34;), (Real(), Real()), None),
                       &#34;angle&#34;: (&#34;r2&#34;, PosReal(), None)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 18&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;top&#34;, &#34;altitude&#34;, &#34;trim&#34;, &#34;angle&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;,
                          &#34;dispersion&#34;, (&#34;spectrum&#34;,))



class TriangularPrism(PhitsObject):
    &#34;&#34;&#34;A triangular-prism solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;origin&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;side1&#34;: ((&#34;x1&#34;, &#34;y1&#34;, &#34;z1&#34;), (Real(), Real(), Real()), None),
                       &#34;side2&#34;: ((&#34;x2&#34;, &#34;y2&#34;, &#34;z2&#34;), (Real(), Real(), Real()), None),
                       &#34;extrusion&#34;: ((&#34;x3&#34;, &#34;y3&#34;, &#34;z3&#34;), (Real(), Real(), Real()), None),
                       &#34;attenuation&#34;: (&#34;exa&#34;, PosReal(), None)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 20&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;origin&#34;, &#34;side1&#34;, &#34;side2&#34;, &#34;extrusion&#34;, &#34;attenuation&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;,
                          &#34;dispersion&#34;, (&#34;spectrum&#34;,))


class TetrahedralSource(PhitsObject): # TODO: subobjects
    &#34;&#34;&#34;A `Tetrahedral`ly-defined solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;cell&#34;: (&#34;tetreg&#34;, IsA(Tetrahedral, index=True), 2)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 24&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;cell&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))


class SurfaceSource(PhitsObject):
    &#34;&#34;&#34;A solid source defined by some part of a surface.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;surface&#34;: (&#34;suf&#34;, _surface_spec, 2),
                               &#34;cut&#34;: (&#34;cut&#34;, List(_surface_spec, max_len=8), 3)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 26&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;surface&#34;, &#34;cut&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

_source_spec = OneOf(IsA(Cylindrical, index=True), IsA(Rectangular, index=True), IsA(Gaussian, index=True),
                    IsA(GaussianSlices, index=True), IsA(Parabolic, index=True), IsA(ParabolicSlices, index=True),
                    IsA(Spherical, index=True), IsA(Beam, index=True), IsA(Conical, index=True), IsA(TriangularPrism, index=True),
                    IsA(TetrahedralSource, index=True), IsA(SurfaceSource, index=True))

# No dump file or user source (for the latter, you can write your own PhitsObject)
# TODO: dom = -10 for Cylindrical and Rectangular

## TALLY

# counters? multiplier?
class DumpFluence(PhitsObject):
    &#34;&#34;&#34;Tally that counts some quantity whenever a particle crosses from one region to another.&#34;&#34;&#34;
    name = &#34;t-cross&#34;
    syntax = {&#34;out&#34;: (None, IsA(Cell, index=True), 0),
              &#34;into&#34;: (None, IsA(Cell, index=True), 1),
              &#34;area&#34;: (None, PosReal(), 2),
              &#34;data&#34;: (&#34;dump&#34;, List(FinBij({&#34;particle&#34;: 1, &#34;x&#34;: 2, &#34;y&#34;: 3, &#34;z&#34;: 4, &#34;u&#34;: 5, &#34;v&#34;: 6, &#34;w&#34;: 7, &#34;energy&#34;: 8, &#34;weight&#34;: 9,
                                            &#34;time&#34;: 10, &#34;counter1&#34;: 11, &#34;counter2&#34;: 12, &#34;counter3&#34;: 13, &#34;spinx&#34;: 14, &#34;spiny&#34;: 15,
                                            &#34;spinz&#34;: 16, &#34;collision_number&#34;: 17, &#34;history_number&#34;: 18, &#34;batch_number&#34;: 19,
                                            &#34;cascade_id&#34;: 20}), unique=True), 3),
              &#34;output&#34;: (&#34;output&#34;, FinBij({&#34;current&#34;: &#34;current&#34;, &#34;a_current&#34;: &#34;a-curr&#34;, &#34;oa_current&#34;: &#34;oa-curr&#34;}), 4),
              &#34;particles&#34;: (&#34;part&#34;, List(Particle(), max_len=6, unique=True), None),
              &#34;factor&#34;: (&#34;factor&#34;, PosReal(), None),
              # &#34;counter&#34;: ()
              &#34;maximum_error&#34;: (&#34;stdcut&#34;, PosReal(), None),
              # &#34;multiplier&#34;: ()
              # TODO: set Between() back to PosInt; done because otherwise memory overflows on my machine during tests
              &#34;energy_mesh&#34;: ((&#34;emin&#34;, &#34;emax&#34;, &#34;ne&#34;), (Interval(0), Between(1, 50)), 5),
              &#34;angle_mesh&#34;: ((&#34;amin&#34;, &#34;amax&#34;, &#34;na&#34;), (Interval(-1, 1), Between(1, 50)), 6),
              &#34;angle_semantics&#34;: (&#34;iangform&#34;, FinBij({&#34;to_normal&#34;: 0, &#34;to_x&#34;: 1, &#34;to_y&#34;: 2, &#34;to_z&#34;: 3}), None),
              &#34;time_mesh&#34;: ((&#34;tmin&#34;, &#34;tmax&#34;, &#34;nt&#34;), (Interval(0), Between(1, 50)), None)}

    prelude = lambda self: (&#34;particles&#34;, &#34;unit = 1&#34;, &#34;axis = reg&#34;, f&#34;file = cross{self.index}&#34;, &#34;factor&#34;, &#34;output&#34;, &#34;maximum_error&#34;,
                            f&#34;dump = -{len(self.data)}&#34;, (&#34;data&#34;,),
                            &#34;e-type = 2&#34;, f&#34;emin = {self.energy_mesh[0][0]}&#34;, f&#34;emax = {self.energy_mesh[0][1]}&#34;,
                            f&#34;ne = {self.energy_mesh[1]}&#34;,
                            f&#34;a-type = 2\namin = {self.angle_mesh[0][0]}\namax = {self.angle_mesh[0][1]}\nna = {self.angle_mesh[1]}&#34; \
                            if self.angle_mesh is not None else &#34;&#34;, &#34;angle_semantics&#34;,
                            f&#34;t-type = 2\ntmin = {self.angle_mesh[0][0]}\ntmax = {self.time_mesh[0][1]}\nnt = {self.time_mesh[1]}&#34; \
                            if self.time_mesh is not None else &#34;&#34;,
                            &#34;mesh = reg&#34;, f&#34;reg = {self.group_size}&#34;,
                            (&#34;r-from&#34;, &#34;r-to&#34;, &#34;&#39;area&#34;))

    shape = lambda self: ((f&#34;{self.out.index}&#34;, f&#34;{self.into.index}&#34;, &#34;area&#34;),)

    group_by = lambda self: (self.particles, self.data, self.output, self.factor, self.energy_mesh, self.angle_mesh,
                             self.time_mesh)
    separator = lambda self: self.section_title()


class DumpProduction(PhitsObject):
    &#34;&#34;&#34;Tally that counts how many particles of some type are created within a `Cell`.&#34;&#34;&#34;
    name = &#34;t-product&#34;
    syntax = {&#34;cell&#34;: (&#34;reg&#34;, IsA(Cell, index=True), 0),
              &#34;data&#34;: (&#34;dump&#34;, List(FinBij({&#34;particle&#34;: 1, &#34;x&#34;: 2, &#34;y&#34;: 3, &#34;z&#34;: 4, &#34;u&#34;: 5, &#34;v&#34;: 6, &#34;w&#34;: 7, &#34;energy&#34;: 8, &#34;weight&#34;: 9,
                                            &#34;time&#34;: 10, &#34;counter1&#34;: 11, &#34;counter2&#34;: 12, &#34;counter3&#34;: 13, &#34;spinx&#34;: 14, &#34;spiny&#34;: 15,
                                            &#34;spinz&#34;: 16, &#34;collision_number&#34;: 17, &#34;history_number&#34;: 18, &#34;batch_number&#34;: 19,
                                            &#34;cascade_id&#34;: 20}), unique=True), 1),
              &#34;output&#34;: (&#34;output&#34;, FinBij({&#34;source&#34;: &#34;source&#34;, &#34;nuclear&#34;: &#34;nuclear&#34;, &#34;nonela&#34;: &#34;nonela&#34;, &#34;elastic&#34;: &#34;elastic&#34;,
                                           &#34;decay&#34;: &#34;decay&#34;, &#34;fission&#34;: &#34;fission&#34;, &#34;atomic&#34;: &#34;atomic&#34;}), 2),
              &#34;particles&#34;: (&#34;part&#34;, List(Particle(), max_len=6, unique=True), None),
              &#34;materials&#34;: (&#34;material&#34;, List(IsA(Material, index=True)), None),
              &#34;mother&#34;: (&#34;material&#34;, List(Nuclide(fake=True)), None),
              &#34;factor&#34;: (&#34;factor&#34;, PosReal(), None),
              # counter
              &#34;maximum_error&#34;: (&#34;stdcut&#34;, PosReal(), None),
              # &#34;multiplier&#34;: ()
              # TODO: set Between() back to PosInt; done because otherwise the memory overflows
              &#34;energy_mesh&#34;: ((&#34;emin&#34;, &#34;emax&#34;, &#34;ne&#34;), (Interval(0), Between(1, 50)), 3),
              &#34;time_mesh&#34;: ((&#34;tmin&#34;, &#34;tmax&#34;, &#34;nt&#34;), (Interval(0), Between(1, 50)), None)}


    prelude = lambda self: (&#34;particles&#34;, &#34;unit = 1&#34;, &#34;axis = reg&#34;, f&#34;file = product{self.index}&#34;, &#34;factor&#34;, &#34;output&#34;, &#34;maximum_error&#34;,
                            f&#34;material = {len(self.materials)}&#34; if self.materials is not None else &#34;&#34;, (&#34;materials&#34;,),
                            f&#34;mother = {len(self.mother)}&#34; if self.mother is not None else &#34;&#34;, (&#34;mother&#34;,),
                            f&#34;dump = -{len(self.data)}&#34;, (&#34;data&#34;,),
                            &#34;e-type = 2&#34;, f&#34;emin = {self.energy_mesh[0][0]}&#34;, f&#34;emax = {self.energy_mesh[0][1]}&#34;,
                            f&#34;ne = {self.energy_mesh[1]}&#34;,
                            f&#34;t-type = 2\ntmin = {self.time_mesh[0][0]}\ntmax = {self.time_mesh[0][1]}\nnt = {self.time_mesh[1]}&#34; \
                            if self.time_mesh is not None else &#34;&#34;,
                            &#34;mesh = reg&#34;)

    shape = (&#34;cell&#34;,)

    group_by = lambda self: (self.particles, self.data, self.output, self.factor, self.energy_mesh, self.time_mesh)
    separator = lambda self: self.section_title()


class DumpTime(PhitsObject):
    &#34;&#34;&#34;Tally that records how particles&#39; disappearance (via energy cutoff, escape, decay) changes over time in a `Cell`.&#34;&#34;&#34;
    name = &#34;t-time&#34;
    syntax = {&#34;cell&#34;: (&#34;reg&#34;, IsA(Cell, index=True), 0),
              &#34;data&#34;: (&#34;dump&#34;, List(FinBij({&#34;particle&#34;: 1, &#34;x&#34;: 2, &#34;y&#34;: 3, &#34;z&#34;: 4, &#34;u&#34;: 5, &#34;v&#34;: 6, &#34;w&#34;: 7, &#34;energy&#34;: 8, &#34;weight&#34;: 9,
                                            &#34;time&#34;: 10, &#34;counter1&#34;: 11, &#34;counter2&#34;: 12, &#34;counter3&#34;: 13, &#34;spinx&#34;: 14, &#34;spiny&#34;: 15,
                                            &#34;spinz&#34;: 16, &#34;collision_number&#34;: 17, &#34;history_number&#34;: 18, &#34;batch_number&#34;: 19,
                                            &#34;cascade_id&#34;: 20}), unique=True), 1),
              &#34;output&#34;: (&#34;output&#34;, FinBij({&#34;all&#34;: &#34;all&#34;, &#34;cutoff&#34;: &#34;cutoff&#34;, &#34;escape&#34;: &#34;escape&#34;, &#34;decay&#34;: &#34;decay&#34;}), 2),
              &#34;particles&#34;: (&#34;part&#34;, List(Particle(), max_len=6, unique=True), None),
              &#34;materials&#34;: (&#34;material&#34;, List(IsA(Material, index=True)), None),
              &#34;factor&#34;: (&#34;factor&#34;, PosReal(), None),
              # counter
              &#34;maximum_error&#34;: (&#34;stdcut&#34;, PosReal(), None),
              # &#34;multiplier&#34;: ()
              &#34;energy_mesh&#34;: ((&#34;emin&#34;, &#34;emax&#34;, &#34;ne&#34;), (Interval(0), Between(1, 50)), 3),
              &#34;time_mesh&#34;: ((&#34;tmin&#34;, &#34;tmax&#34;, &#34;nt&#34;), (Interval(0), Between(1, 50)), 4)}


    prelude = lambda self: (&#34;particles&#34;, &#34;unit = 1&#34;, &#34;axis = reg&#34;, f&#34;file = time{self.index}&#34;, &#34;factor&#34;, &#34;output&#34;, &#34;maximum_error&#34;,
                            f&#34;material = {len(self.materials)}&#34; if self.materials is not None else &#34;&#34;, (&#34;materials&#34;,),
                            f&#34;dump = -{len(self.data)}&#34;, (&#34;data&#34;,),
                            &#34;e-type = 2&#34;, f&#34;emin = {self.energy_mesh[0][0]}&#34;, f&#34;emax = {self.energy_mesh[0][1]}&#34;,
                            f&#34;ne = {self.energy_mesh[1]}&#34;,
                            &#34;t-type = 2&#34;, f&#34;tmin = {self.time_mesh[0][0]}&#34;, f&#34;tmax = {self.time_mesh[0][1]}&#34;,
                            f&#34;nt = {self.time_mesh[1]}&#34;, &#34;mesh = reg&#34;)

    shape = (&#34;cell&#34;,)

    group_by = lambda self: (self.particles, self.data, self.output, self.factor, self.energy_mesh, self.time_mesh)
    separator = lambda self: self.section_title()

_tally_spec = OneOf(IsA(DumpFluence, index=True), IsA(DumpProduction, index=True), IsA(DumpTime, index=True))



## DMP-READER

def read_dump(name: str, columns: list[str], return_type: str) -&gt; dict:
    &#34;&#34;&#34;Given a path to a PHITS dump file and names of the record entries in order,
    produce a semantically equivalent dictionary of lists/numpy array/Pandas dataframe of the contents.&#34;&#34;&#34;
    rd = FortranRecordReader(&#39;(30(1p1d24.15))&#39;) # PHITS documentation says e, but code says d---latter is consistent with behavior
    acc = dict.fromkeys(columns)
    with open(name, &#39;r&#39;) as dmp:
        for line in dmp:
            for i, val in enumerate(rd.read(line)):
                if val is not None:
                    col = columns[i]
                    if acc[col] is None:
                        acc[col] = [val if col != &#34;particle&#34; else kf_decode(val)]
                    else:
                        acc[col] += val if col != &#34;particle&#34; else kf_decode(val)

    if return_type == &#34;dict&#34;:
        return acc
    elif return_type == &#34;numpy&#34;:
        return np.fromiter(acc.items())
    elif return_type == &#34;pandas&#34;:
        return DataFrame.from_dict(acc)


    return acc



## RUN-PHITS


def make_input(cells, sources, tallies, title: str = str(datetime.now()), cross_sections=[], multipliers=[], super_mirrors=[],
               mat_time_changes=[], raw=&#34;&#34;, outer_void_properties: dict = dict(), **kwargs) -&gt; str:
    &#34;&#34;&#34;Given a situation, produces a corresponding input file.

    Required arguments:

    | Name | Position | Description |
    | ---- | -------- | ----------- |
    | cells | 0 | A list of `PhitsObject`s with `name == &#34;cell&#34;`.|
    | sources | 1 | Either a single `PhitsObject` with `name == &#34;source&#34;`, or a list of tuples (&lt;source object&gt;, &lt;weight&gt;).|
    | tallies | 2 | A list of objects of type `DumpFluence`, `DumpProduction`, or `DumpTime`.|

    Optional arguments:

    | Name | Description |
    | ---- | ----------- |
    | title | A string to paste in the `[Title]` section. |
    | parameters | Some globally-passed options, fed directly into a `Parameters` object. |
    | cross_sections | A list of `FragData` objects. |
    | raw | A string that&#39;s appended to the end of the .inp---do unsupported stuff manually with this.|
    | kwargs | Anything extra is used to create a Parameters() object. |
    &#34;&#34;&#34;
    assert (isinstance(cells, PhitsObject) and cells.name == &#34;cell&#34;) \
        or (len(cells) &gt;= 1 and all(map(lambda x: x.name == &#34;cell&#34;, cells))), \
    f&#34;`cells` must be either a cell object or a list of cell objects; got {cells}.&#34;

    assert (isinstance(sources, PhitsObject) and sources.name == &#34;source&#34;) \
        or (len(sources) &gt;= 1 and all(map(lambda x: x.name == &#34;source&#34;, sources))), \
    f&#34;`sources` must be either a sources object or a list of source objects; got {sources}.&#34;

    assert (isinstance(tallies, PhitsObject) and &#34;t-&#34; in tallies.name) \
        or (all(map(lambda x: &#34;t-&#34; in x.name, tallies))), \
    f&#34;`tallies` must be either a tally object or a list of tally objects; got {tallies}.&#34;

    assert (isinstance(cross_sections, PhitsObject) and cross_sections.name == &#34;frag_data&#34;) \
        or (all(map(lambda x: x.name == &#34;frag_data&#34;, cross_sections))), \
    f&#34;`cross_sections` must be either a FragData object or a list of FragData objects; got {cross_sections}.&#34;

    assert (isinstance(super_mirrors, PhitsObject) and super_mirrors.name == &#34;super_mirror&#34;) \
        or (all(map(lambda x: x.name == &#34;super_mirror&#34;, super_mirrors))), \
    f&#34;`super_mirror` must be either a SuperMirror object or a list of SuperMirror objects; got {super_mirrors}.&#34;

    assert (isinstance(mat_time_changes, PhitsObject) and mat_time_changes.name == &#34;mat_time_change&#34;) \
        or (all(map(lambda x: x.name == &#34;mat_time_change&#34;, mat_time_changes))), \
    &#34;`mat_time_change` must be either a MatTimeChange object or a list of MatTimeChange objects; &#34;
    f&#34;got {mat_time_changes}.&#34;

    # Problem: you can have different objects that are &#34;essentially the same&#34; appearing in the object tree.
    # Solution: exploit the __eq__ and __hash__ defined on PhitsObject
    unique = set()

    def add_to_set(an_obj, the_set, prev=None):  # Recursively add subtypes to set if they represent an &#34;entry&#34; in one of the sections
        if isinstance(an_obj, list) or isinstance(an_obj, tuple):
            for ob in an_obj:
                if ob is not prev:
                    add_to_set(ob, the_set)
        if isinstance(an_obj, PhitsObject):
            the_set.add(an_obj)
            for name, child in an_obj.__dict__.items():
                if child is not prev:
                    add_to_set(child, the_set, an_obj)

    add_to_set(cells, unique)
    add_to_set(sources, unique)
    add_to_set(tallies, unique)
    add_to_set(cross_sections, unique)
    add_to_set(multipliers, unique)
    add_to_set(super_mirrors, unique)
    add_to_set(mat_time_changes, unique)


    # We now have that if any two PHITS objects A and B have attributes C and D (respectively) such that C == D, C /is/ D.


    # Problem: before this function is invoked, we can&#39;t give objects an ID number by which they&#39;re referenced in the .inp---so
    # they don&#39;t have IDs yet.
    # Solution: put all the objects in an indexed structure; index + 1 := ID.
    type_divided = {&#34;parameters&#34;: [],
                    &#34;source&#34;: [],
                    &#34;material&#34;: [],
                    &#34;surface&#34;: [],
                    &#34;cell&#34;: [],
                    &#34;transform&#34;: [],
                    &#34;temperature&#34;: [],
                    &#34;mat_time_change&#34;: [],
                    &#34;magnetic_field&#34;: [],
                    &#34;electromagnetic_field&#34;: [],
                    &#34;delta_ray&#34;: [],
                    &#34;track_structure&#34;: [],
                    &#34;super_mirror&#34;: [],
                    &#34;elastic_option&#34;: [],
                    &#34;data_max&#34;: [],
                    &#34;frag_data&#34;: [],
                    &#34;importance&#34;: [],
                    &#34;weight_window&#34;: [],
                    &#34;ww_bias&#34;: [],
                    &#34;forced_collisions&#34;: [],
                    &#34;repeated_collisions&#34;: [],
                    &#34;volume&#34;: [],
                    &#34;multiplier&#34;: [],
                    &#34;mat_name_color&#34;: [],
                    &#34;reg_name&#34;: [],
                    &#34;counter&#34;: [],
                    &#34;timer&#34;: [],
                    # &#34;t-track&#34;: [],
                    &#34;t-cross&#34;: [],
                    # &#34;t-point&#34;: [],
                    # &#34;t-adjoint&#34;: [],
                    # &#34;t-deposit&#34;: [],
                    # &#34;t-deposit2&#34;: [],
                    # &#34;t-heat&#34;: [],
                    # &#34;t-yield&#34;: [],
                    &#34;t-product&#34;: [],
                    # &#34;t-dpa&#34;: [],
                    # &#34;t-let&#34;: [],
                    # &#34;t-sed&#34;: [],
                    &#34;t-time&#34;: [],
                    # &#34;t-interact&#34;: [],
                    # &#34;t-dchain&#34;: [],
                    # &#34;t-wwg&#34;: [],
                    # &#34;t-wwbg&#34;: [],
                    # &#34;t-volume&#34;: [],
                    # &#34;t-gshow&#34;: [],
                    # &#34;t-rshow&#34;: [],
                    # &#34;t-3dshow&#34;: []
                    }
    if kwargs:
        type_divided[&#34;parameters&#34;].append(Parameters(**kwargs))
    for node in unique:
        type_divided[node.name].append(node)

    toset = OuterVoid((~reduce(lambda c1, c2: c1 | c2, type_divided[&#34;cell&#34;])).regions, **outer_void_properties)

    type_divided[&#34;cell&#34;].append(toset)


    for section, entries in type_divided.items():
        for idx, value in enumerate(entries):
            value.index = idx+1

    # Problem: while we&#39;ve chosen a set of representatives for equivalence classes under PhitsObject.__eq__, the objects themselves
    # don&#39;t have subobjects with index attributes pointing to the representative---there will be None showing up all over the output.
    # Solution: replace all members of an equivalence class in the object tree with their representative (whose index is defined above).
    representatives = {n: n for n in it.chain.from_iterable(type_divided.values())} # necessary because `unique` doesn&#39;t have idx

    def replace(this, that, inside):
        if inside is this:
            return that
        elif isinstance(inside, list) or isinstance(inside, tuple):
            replaced = tuple()
            for el in inside:
                if el is this:
                    replaced += (that,)
                else:
                    replaced += (replace(this, that, el),)
            return replaced
        else:
            return this

    def adjust_subobjects(an_obj, ason=(None, None)): # Recursively replace redundant subtypes with the representative in the dict
        if isinstance(an_obj, tuple) or isinstance(an_obj, list):
            for ob in an_obj:
                if ob is not ason[1]:
                    adjust_subobjects(ob, ason=ason)

        elif isinstance(an_obj, PhitsObject):
            if ason != (None, None):
                representative = representatives[an_obj]
                to_check = getattr(ason[1], ason[0])
                setattr(ason[1], ason[0], replace(an_obj, representatives[an_obj], to_check))
                
            for name, child in an_obj.__dict__.items():
                if child is not ason[1]:
                    adjust_subobjects(child, ason=(name, an_obj))

    adjust_subobjects(cells)
    adjust_subobjects(sources)
    adjust_subobjects(tallies)
    adjust_subobjects(cross_sections)
    adjust_subobjects(multipliers)
    adjust_subobjects(super_mirrors)
    adjust_subobjects(mat_time_changes)


    # Check that the whole shebang is valid together
    for _, v in type_divided.items():
        if len(v) &gt; 0 and hasattr(type(v[0]), &#34;global_restrictions&#34;):
            v[0].global_restrictions(type_divided)

    # Now, we can make the input file.
    inp = &#34;&#34;
    def add_defs(obj_type):
        nonlocal inp
        if obj_type in type_divided:
            if type_divided[obj_type]:
                objs = type_divided[obj_type]
                type_rep = objs[0]
                if hasattr(type_rep, &#34;group_by&#34;) and callable(type_rep.group_by):
                    grouped = [(k, list(v)) for k, v in it.groupby(sorted(objs, key=lambda x: x.group_by()), lambda x: x.group_by())]
                    if hasattr(type_rep, &#34;max_groups&#34;) and type_rep.max_groups is not None:
                        assert len(grouped) &lt;= type_rep.max_groups, ValueError(f&#34;Too many {obj_type} groups.&#34;)
                    for key, group in grouped:
                        group = list(group)
                        inp += group[0].separator()
                        gs = len(group)
                        for obj in group:
                            obj.group_size = gs
                        if hasattr(group[0], &#34;prelude&#34;):
                            inp += group[0].prelude_str()
                        for obj in group:
                            inp += obj.definition()
                else:
                    inp += type_rep.section_title()
                    if hasattr(type_rep, &#34;prelude&#34;):
                        inp += type_rep.prelude_str()
                    for obj in objs:
                        inp += obj.definition()



    inp += &#34;[Title]\n&#34;
    inp += title + &#39;\n&#39;

    if any(not param.empty() for param in type_divided[&#34;parameters&#34;]):
        add_defs(&#34;parameters&#34;) # parameters associated with object declarations, but that need to be in this global context.
        # for var, val in parameters.items(): # directly passed global parameters
        #     if var not in {&#34;totfact&#34;, &#34;iscorr&#34;}: # TODO: document these two
        #         inp += f&#34;{var} = {val}\n&#34;




    inp += &#34;[Source]\n&#34;
    if &#34;totfact&#34; in kwargs:
        val = kwargs[&#34;totfact&#34;]
        inp += f&#34;totfact = {val}\n&#34;
    if &#34;iscorr&#34; in kwargs:
        val = kwargs[&#34;iscorr&#34;]
        inp += f&#34;iscorr = {val}\n&#34;

    if isinstance(sources, col.Iterable):
        for source, weight in sources:
            inp += f&#34;&lt;source&gt; = {weight}\n&#34;
            inp += source.definition()
    else:
        inp += sources.definition()


    add_defs(&#34;material&#34;)
    add_defs(&#34;surface&#34;)
    add_defs(&#34;cell&#34;)
    add_defs(&#34;transform&#34;)
    add_defs(&#34;mat_time_change&#34;)
    add_defs(&#34;magnetic_field&#34;)
    add_defs(&#34;electromagnetic_field&#34;)
    add_defs(&#34;delta_ray&#34;)
    add_defs(&#34;track_structure&#34;)
    add_defs(&#34;super_mirror&#34;)
    add_defs(&#34;elastic_option&#34;)
    add_defs(&#34;data_max&#34;)
    add_defs(&#34;frag_data&#34;)
    add_defs(&#34;importance&#34;)
    add_defs(&#34;weight_window&#34;)
    add_defs(&#34;ww_bias&#34;)
    add_defs(&#34;forced_collisions&#34;)
    add_defs(&#34;repeated_collisions&#34;)
    add_defs(&#34;multiplier&#34;)
    add_defs(&#34;mat_name_color&#34;)
    add_defs(&#34;reg_name&#34;)
    add_defs(&#34;counter&#34;)
    add_defs(&#34;timer&#34;)
    add_defs(&#34;t-cross&#34;)
    add_defs(&#34;t-product&#34;)
    add_defs(&#34;t-time&#34;)

    inp += raw

    if max(map(len, inp.split(&#34;\n&#34;))) &gt; 200:
        print(inp)
        raise RuntimeError(&#34;PHITS line limit reached.&#34;)
    else:
        return inp





def run_phits(cells, sources, tallies, command: str = &#34;phits&#34;, hard_error: bool = True, filename: str = &#34;phits.inp&#34;,
              return_type: str = &#34;dict&#34;, injected_files=[], yanked_files=[], yank_to=os.getcwd(), **make_input_kwargs):
    &#34;&#34;&#34;Given a scenario, calls `make_input` to generate a corresponding input file, runs PHITS on it in a temporary directory,
    and then collects and returns the resulting output as nice Python objects.

    Required arguments:

    | Name | Position | Description |
    | ---- | -------- | ----------- |
    | `cells` | 0 | A list of `PhitsObject`s with `name == &#34;cell&#34;`.|
    | `sources` | 1 | Either a single `PhitsObject` with `name == &#34;source&#34;`, or a list of tuples (&lt;source object&gt;, &lt;weight&gt;).|
    | `tallies` | 2 | A list of objects of type `DumpFluence`, `DumpProduction`, or `DumpTime`.|

    Optional arguments:

    | Name | Description |
    | ---- | ----------- |
    | `command` | The shell command to invoke on the generated file. |
    | `hard_error` | If truthy, raise an error and halt if PHITS encounters one. Otherwise, simply print the error and continue
    (helpful in avoiding &#34;I let it run all night and it crashed the minute I left the room&#34; scenarios). |
    | `filename` | The name of the input file on which to call PHITS. Of little utility except for debugging. |
    | `return_type` | Either &#34;dict&#34;, &#34;numpy&#34;, or &#34;pandas&#34;, corresponding to the desired result format. |
    | `injected_files` | A list of path- or file-like objects to `shutil.copy`/`shutil.copyfileobj` to the temporary directory. |
    | `yanked_files` | A list of paths relative to the temporary directory which will be copied out to `yank_to` before cleanup. |
    | `yank_to` | A path to which `yanked_files` will be saved. |
    &#34;&#34;&#34;
    with tf.TemporaryDirectory() as newdir:
        inp = make_input(cells, sources, tallies, **make_input_kwargs)
        name = os.path.join(newdir, filename)
        with open(os.path.join(newdir, filename), &#34;w&#34;) as inp_file:
            inp_file.write(inp)

        for path in injected_files:
            copy(path, os.path.join(newdir, os.path.basename(path)))

        try:
            # TODO: PHITS actualy **DOESN&#39;T FKING SET EXIT CODES ON ERROR** so will have to grep the output for &#34;Error&#34;...
            out = sp.run([&#34;phits&#34;, filename], capture_output=True, text=True, cwd=newdir)
            assert not re.search(&#34;(?i:Error)&#34;, out.stdout), &#34;PHITS Error.&#34; # this REALLY sucks. Thank PHITS.
            assert out.returncode == 0, &#34;PHITS Error&#34;

        except AssertionError as error:
            r = f&#34;PHITS exited with code {out.returncode}.\n&#34;
            r += f&#34;stdout: {out.stdout}\n&#34;
            r += f&#34;stderr: {out.stderr}\n&#34;
            r += &#34;Offending input file:\n&#34;
            for idx, line in enumerate(inp.split(&#34;\n&#34;)):
                r += f&#34;{idx}:    {line}\n&#34;

            if hard_error:
                raise RuntimeError(r)
            else:
                print(r)

        result = dict()
        for t in tallies:

            dfile = &#34;&#34;
            if t.name == &#34;t-cross&#34;:
                dfile = os.path.join(newdir, f&#34;cross{t.index}_dmp&#34;)
            elif t.name == &#34;t-product&#34;:
                dfile = os.path.join(newdir, f&#34;product{t.index}_dmp&#34;)
            elif t.name == &#34;t-time&#34;:
                dfile = os.path.join(newdir, f&#34;time{t.index}_dmp&#34;)
            result[t] = read_dump(dfile, t.data, return_type)


        if yanked_files != []:
            for name in yanked_files:
                copy(os.path.join(newdir, name), yank_to)

        return result

__pdoc__ = dict()
__pdoc__[&#34;builds&#34;] = False
__pdoc__[&#34;slices&#34;] = False
__pdoc__[&#34;builds_right&#34;] = False
for name, cl in list(sys.modules[__name__].__dict__.items()):
    if type(cl) == type and issubclass(cl, PhitsObject) and cl != PhitsObject:
        __pdoc__[cl.__name__] = cl.__doc__ + cl.syntax_desc() if cl.__doc__ else cl.syntax_desc()

__pdoc__[&#34;Parameters&#34;] = Parameters.__doc__ + Parameters.syntax_desc()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyphits.valspec" href="valspec.html">pyphits.valspec</a></code></dt>
<dd>
<div class="desc"><p>Type definitions used to streamline: class definitions, error handling and reporting, and testing.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pyphits.readable_remapping"><code class="name">var <span class="ident">readable_remapping</span></code></dt>
<dd>
<div class="desc"><p>If <code>True</code>, use a remapped initialization syntax that's more informative.
E.g., <code>Parameters(control="output_echo_only")</code> instead of <code>Parameters(icntl=3)</code>.</p>
<p>If <code>False</code>, use a syntax as close as possible to that specified in the PHITS manual (i.e., the latter form in the above example).
Note that some identifiers in PHITS do not conform to Python's identifier syntax (e.g. 2d-type, emin(14));
these identifiers are sanitized as follows:</p>
<pre><code>- dashes -&gt; underscores
- beginning with a number -&gt; that clause moved to the end
- parentheses -&gt; omitted
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyphits.interval"><code class="name flex">
<span>def <span class="ident">interval</span></span>(<span>lbd, ubd)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyphits.make_input"><code class="name flex">
<span>def <span class="ident">make_input</span></span>(<span>cells, sources, tallies, title:str='2023-05-12 17:16:11.794157', cross_sections=[], multipliers=[], super_mirrors=[], mat_time_changes=[], raw='', outer_void_properties:dict={}, **kwargs) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Given a situation, produces a corresponding input file.</p>
<p>Required arguments:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Position</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>cells</td>
<td>0</td>
<td>A list of <code><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></code>s with <code>name == "cell"</code>.</td>
</tr>
<tr>
<td>sources</td>
<td>1</td>
<td>Either a single <code><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></code> with <code>name == "source"</code>, or a list of tuples (<source object>, <weight>).</td>
</tr>
<tr>
<td>tallies</td>
<td>2</td>
<td>A list of objects of type <code><a title="pyphits.DumpFluence" href="#pyphits.DumpFluence">DumpFluence</a></code>, <code><a title="pyphits.DumpProduction" href="#pyphits.DumpProduction">DumpProduction</a></code>, or <code><a title="pyphits.DumpTime" href="#pyphits.DumpTime">DumpTime</a></code>.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>A string to paste in the <code>[Title]</code> section.</td>
</tr>
<tr>
<td>parameters</td>
<td>Some globally-passed options, fed directly into a <code><a title="pyphits.Parameters" href="#pyphits.Parameters">Parameters</a></code> object.</td>
</tr>
<tr>
<td>cross_sections</td>
<td>A list of <code><a title="pyphits.FragData" href="#pyphits.FragData">FragData</a></code> objects.</td>
</tr>
<tr>
<td>raw</td>
<td>A string that's appended to the end of the .inp&mdash;do unsupported stuff manually with this.</td>
</tr>
<tr>
<td>kwargs</td>
<td>Anything extra is used to create a Parameters() object.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_input(cells, sources, tallies, title: str = str(datetime.now()), cross_sections=[], multipliers=[], super_mirrors=[],
               mat_time_changes=[], raw=&#34;&#34;, outer_void_properties: dict = dict(), **kwargs) -&gt; str:
    &#34;&#34;&#34;Given a situation, produces a corresponding input file.

    Required arguments:

    | Name | Position | Description |
    | ---- | -------- | ----------- |
    | cells | 0 | A list of `PhitsObject`s with `name == &#34;cell&#34;`.|
    | sources | 1 | Either a single `PhitsObject` with `name == &#34;source&#34;`, or a list of tuples (&lt;source object&gt;, &lt;weight&gt;).|
    | tallies | 2 | A list of objects of type `DumpFluence`, `DumpProduction`, or `DumpTime`.|

    Optional arguments:

    | Name | Description |
    | ---- | ----------- |
    | title | A string to paste in the `[Title]` section. |
    | parameters | Some globally-passed options, fed directly into a `Parameters` object. |
    | cross_sections | A list of `FragData` objects. |
    | raw | A string that&#39;s appended to the end of the .inp---do unsupported stuff manually with this.|
    | kwargs | Anything extra is used to create a Parameters() object. |
    &#34;&#34;&#34;
    assert (isinstance(cells, PhitsObject) and cells.name == &#34;cell&#34;) \
        or (len(cells) &gt;= 1 and all(map(lambda x: x.name == &#34;cell&#34;, cells))), \
    f&#34;`cells` must be either a cell object or a list of cell objects; got {cells}.&#34;

    assert (isinstance(sources, PhitsObject) and sources.name == &#34;source&#34;) \
        or (len(sources) &gt;= 1 and all(map(lambda x: x.name == &#34;source&#34;, sources))), \
    f&#34;`sources` must be either a sources object or a list of source objects; got {sources}.&#34;

    assert (isinstance(tallies, PhitsObject) and &#34;t-&#34; in tallies.name) \
        or (all(map(lambda x: &#34;t-&#34; in x.name, tallies))), \
    f&#34;`tallies` must be either a tally object or a list of tally objects; got {tallies}.&#34;

    assert (isinstance(cross_sections, PhitsObject) and cross_sections.name == &#34;frag_data&#34;) \
        or (all(map(lambda x: x.name == &#34;frag_data&#34;, cross_sections))), \
    f&#34;`cross_sections` must be either a FragData object or a list of FragData objects; got {cross_sections}.&#34;

    assert (isinstance(super_mirrors, PhitsObject) and super_mirrors.name == &#34;super_mirror&#34;) \
        or (all(map(lambda x: x.name == &#34;super_mirror&#34;, super_mirrors))), \
    f&#34;`super_mirror` must be either a SuperMirror object or a list of SuperMirror objects; got {super_mirrors}.&#34;

    assert (isinstance(mat_time_changes, PhitsObject) and mat_time_changes.name == &#34;mat_time_change&#34;) \
        or (all(map(lambda x: x.name == &#34;mat_time_change&#34;, mat_time_changes))), \
    &#34;`mat_time_change` must be either a MatTimeChange object or a list of MatTimeChange objects; &#34;
    f&#34;got {mat_time_changes}.&#34;

    # Problem: you can have different objects that are &#34;essentially the same&#34; appearing in the object tree.
    # Solution: exploit the __eq__ and __hash__ defined on PhitsObject
    unique = set()

    def add_to_set(an_obj, the_set, prev=None):  # Recursively add subtypes to set if they represent an &#34;entry&#34; in one of the sections
        if isinstance(an_obj, list) or isinstance(an_obj, tuple):
            for ob in an_obj:
                if ob is not prev:
                    add_to_set(ob, the_set)
        if isinstance(an_obj, PhitsObject):
            the_set.add(an_obj)
            for name, child in an_obj.__dict__.items():
                if child is not prev:
                    add_to_set(child, the_set, an_obj)

    add_to_set(cells, unique)
    add_to_set(sources, unique)
    add_to_set(tallies, unique)
    add_to_set(cross_sections, unique)
    add_to_set(multipliers, unique)
    add_to_set(super_mirrors, unique)
    add_to_set(mat_time_changes, unique)


    # We now have that if any two PHITS objects A and B have attributes C and D (respectively) such that C == D, C /is/ D.


    # Problem: before this function is invoked, we can&#39;t give objects an ID number by which they&#39;re referenced in the .inp---so
    # they don&#39;t have IDs yet.
    # Solution: put all the objects in an indexed structure; index + 1 := ID.
    type_divided = {&#34;parameters&#34;: [],
                    &#34;source&#34;: [],
                    &#34;material&#34;: [],
                    &#34;surface&#34;: [],
                    &#34;cell&#34;: [],
                    &#34;transform&#34;: [],
                    &#34;temperature&#34;: [],
                    &#34;mat_time_change&#34;: [],
                    &#34;magnetic_field&#34;: [],
                    &#34;electromagnetic_field&#34;: [],
                    &#34;delta_ray&#34;: [],
                    &#34;track_structure&#34;: [],
                    &#34;super_mirror&#34;: [],
                    &#34;elastic_option&#34;: [],
                    &#34;data_max&#34;: [],
                    &#34;frag_data&#34;: [],
                    &#34;importance&#34;: [],
                    &#34;weight_window&#34;: [],
                    &#34;ww_bias&#34;: [],
                    &#34;forced_collisions&#34;: [],
                    &#34;repeated_collisions&#34;: [],
                    &#34;volume&#34;: [],
                    &#34;multiplier&#34;: [],
                    &#34;mat_name_color&#34;: [],
                    &#34;reg_name&#34;: [],
                    &#34;counter&#34;: [],
                    &#34;timer&#34;: [],
                    # &#34;t-track&#34;: [],
                    &#34;t-cross&#34;: [],
                    # &#34;t-point&#34;: [],
                    # &#34;t-adjoint&#34;: [],
                    # &#34;t-deposit&#34;: [],
                    # &#34;t-deposit2&#34;: [],
                    # &#34;t-heat&#34;: [],
                    # &#34;t-yield&#34;: [],
                    &#34;t-product&#34;: [],
                    # &#34;t-dpa&#34;: [],
                    # &#34;t-let&#34;: [],
                    # &#34;t-sed&#34;: [],
                    &#34;t-time&#34;: [],
                    # &#34;t-interact&#34;: [],
                    # &#34;t-dchain&#34;: [],
                    # &#34;t-wwg&#34;: [],
                    # &#34;t-wwbg&#34;: [],
                    # &#34;t-volume&#34;: [],
                    # &#34;t-gshow&#34;: [],
                    # &#34;t-rshow&#34;: [],
                    # &#34;t-3dshow&#34;: []
                    }
    if kwargs:
        type_divided[&#34;parameters&#34;].append(Parameters(**kwargs))
    for node in unique:
        type_divided[node.name].append(node)

    toset = OuterVoid((~reduce(lambda c1, c2: c1 | c2, type_divided[&#34;cell&#34;])).regions, **outer_void_properties)

    type_divided[&#34;cell&#34;].append(toset)


    for section, entries in type_divided.items():
        for idx, value in enumerate(entries):
            value.index = idx+1

    # Problem: while we&#39;ve chosen a set of representatives for equivalence classes under PhitsObject.__eq__, the objects themselves
    # don&#39;t have subobjects with index attributes pointing to the representative---there will be None showing up all over the output.
    # Solution: replace all members of an equivalence class in the object tree with their representative (whose index is defined above).
    representatives = {n: n for n in it.chain.from_iterable(type_divided.values())} # necessary because `unique` doesn&#39;t have idx

    def replace(this, that, inside):
        if inside is this:
            return that
        elif isinstance(inside, list) or isinstance(inside, tuple):
            replaced = tuple()
            for el in inside:
                if el is this:
                    replaced += (that,)
                else:
                    replaced += (replace(this, that, el),)
            return replaced
        else:
            return this

    def adjust_subobjects(an_obj, ason=(None, None)): # Recursively replace redundant subtypes with the representative in the dict
        if isinstance(an_obj, tuple) or isinstance(an_obj, list):
            for ob in an_obj:
                if ob is not ason[1]:
                    adjust_subobjects(ob, ason=ason)

        elif isinstance(an_obj, PhitsObject):
            if ason != (None, None):
                representative = representatives[an_obj]
                to_check = getattr(ason[1], ason[0])
                setattr(ason[1], ason[0], replace(an_obj, representatives[an_obj], to_check))
                
            for name, child in an_obj.__dict__.items():
                if child is not ason[1]:
                    adjust_subobjects(child, ason=(name, an_obj))

    adjust_subobjects(cells)
    adjust_subobjects(sources)
    adjust_subobjects(tallies)
    adjust_subobjects(cross_sections)
    adjust_subobjects(multipliers)
    adjust_subobjects(super_mirrors)
    adjust_subobjects(mat_time_changes)


    # Check that the whole shebang is valid together
    for _, v in type_divided.items():
        if len(v) &gt; 0 and hasattr(type(v[0]), &#34;global_restrictions&#34;):
            v[0].global_restrictions(type_divided)

    # Now, we can make the input file.
    inp = &#34;&#34;
    def add_defs(obj_type):
        nonlocal inp
        if obj_type in type_divided:
            if type_divided[obj_type]:
                objs = type_divided[obj_type]
                type_rep = objs[0]
                if hasattr(type_rep, &#34;group_by&#34;) and callable(type_rep.group_by):
                    grouped = [(k, list(v)) for k, v in it.groupby(sorted(objs, key=lambda x: x.group_by()), lambda x: x.group_by())]
                    if hasattr(type_rep, &#34;max_groups&#34;) and type_rep.max_groups is not None:
                        assert len(grouped) &lt;= type_rep.max_groups, ValueError(f&#34;Too many {obj_type} groups.&#34;)
                    for key, group in grouped:
                        group = list(group)
                        inp += group[0].separator()
                        gs = len(group)
                        for obj in group:
                            obj.group_size = gs
                        if hasattr(group[0], &#34;prelude&#34;):
                            inp += group[0].prelude_str()
                        for obj in group:
                            inp += obj.definition()
                else:
                    inp += type_rep.section_title()
                    if hasattr(type_rep, &#34;prelude&#34;):
                        inp += type_rep.prelude_str()
                    for obj in objs:
                        inp += obj.definition()



    inp += &#34;[Title]\n&#34;
    inp += title + &#39;\n&#39;

    if any(not param.empty() for param in type_divided[&#34;parameters&#34;]):
        add_defs(&#34;parameters&#34;) # parameters associated with object declarations, but that need to be in this global context.
        # for var, val in parameters.items(): # directly passed global parameters
        #     if var not in {&#34;totfact&#34;, &#34;iscorr&#34;}: # TODO: document these two
        #         inp += f&#34;{var} = {val}\n&#34;




    inp += &#34;[Source]\n&#34;
    if &#34;totfact&#34; in kwargs:
        val = kwargs[&#34;totfact&#34;]
        inp += f&#34;totfact = {val}\n&#34;
    if &#34;iscorr&#34; in kwargs:
        val = kwargs[&#34;iscorr&#34;]
        inp += f&#34;iscorr = {val}\n&#34;

    if isinstance(sources, col.Iterable):
        for source, weight in sources:
            inp += f&#34;&lt;source&gt; = {weight}\n&#34;
            inp += source.definition()
    else:
        inp += sources.definition()


    add_defs(&#34;material&#34;)
    add_defs(&#34;surface&#34;)
    add_defs(&#34;cell&#34;)
    add_defs(&#34;transform&#34;)
    add_defs(&#34;mat_time_change&#34;)
    add_defs(&#34;magnetic_field&#34;)
    add_defs(&#34;electromagnetic_field&#34;)
    add_defs(&#34;delta_ray&#34;)
    add_defs(&#34;track_structure&#34;)
    add_defs(&#34;super_mirror&#34;)
    add_defs(&#34;elastic_option&#34;)
    add_defs(&#34;data_max&#34;)
    add_defs(&#34;frag_data&#34;)
    add_defs(&#34;importance&#34;)
    add_defs(&#34;weight_window&#34;)
    add_defs(&#34;ww_bias&#34;)
    add_defs(&#34;forced_collisions&#34;)
    add_defs(&#34;repeated_collisions&#34;)
    add_defs(&#34;multiplier&#34;)
    add_defs(&#34;mat_name_color&#34;)
    add_defs(&#34;reg_name&#34;)
    add_defs(&#34;counter&#34;)
    add_defs(&#34;timer&#34;)
    add_defs(&#34;t-cross&#34;)
    add_defs(&#34;t-product&#34;)
    add_defs(&#34;t-time&#34;)

    inp += raw

    if max(map(len, inp.split(&#34;\n&#34;))) &gt; 200:
        print(inp)
        raise RuntimeError(&#34;PHITS line limit reached.&#34;)
    else:
        return inp</code></pre>
</details>
</dd>
<dt id="pyphits.read_dump"><code class="name flex">
<span>def <span class="ident">read_dump</span></span>(<span>name:str, columns:list[str], return_type:str) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Given a path to a PHITS dump file and names of the record entries in order,
produce a semantically equivalent dictionary of lists/numpy array/Pandas dataframe of the contents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_dump(name: str, columns: list[str], return_type: str) -&gt; dict:
    &#34;&#34;&#34;Given a path to a PHITS dump file and names of the record entries in order,
    produce a semantically equivalent dictionary of lists/numpy array/Pandas dataframe of the contents.&#34;&#34;&#34;
    rd = FortranRecordReader(&#39;(30(1p1d24.15))&#39;) # PHITS documentation says e, but code says d---latter is consistent with behavior
    acc = dict.fromkeys(columns)
    with open(name, &#39;r&#39;) as dmp:
        for line in dmp:
            for i, val in enumerate(rd.read(line)):
                if val is not None:
                    col = columns[i]
                    if acc[col] is None:
                        acc[col] = [val if col != &#34;particle&#34; else kf_decode(val)]
                    else:
                        acc[col] += val if col != &#34;particle&#34; else kf_decode(val)

    if return_type == &#34;dict&#34;:
        return acc
    elif return_type == &#34;numpy&#34;:
        return np.fromiter(acc.items())
    elif return_type == &#34;pandas&#34;:
        return DataFrame.from_dict(acc)


    return acc</code></pre>
</details>
</dd>
<dt id="pyphits.run_phits"><code class="name flex">
<span>def <span class="ident">run_phits</span></span>(<span>cells, sources, tallies, command:str='phits', hard_error:bool=True, filename:str='phits.inp', return_type:str='dict', injected_files=[], yanked_files=[], yank_to='/home/dnw/Code/PyPHITS', **make_input_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a scenario, calls <code><a title="pyphits.make_input" href="#pyphits.make_input">make_input()</a></code> to generate a corresponding input file, runs PHITS on it in a temporary directory,
and then collects and returns the resulting output as nice Python objects.</p>
<p>Required arguments:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Position</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cells</code></td>
<td>0</td>
<td>A list of <code><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></code>s with <code>name == "cell"</code>.</td>
</tr>
<tr>
<td><code>sources</code></td>
<td>1</td>
<td>Either a single <code><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></code> with <code>name == "source"</code>, or a list of tuples (<source object>, <weight>).</td>
</tr>
<tr>
<td><code>tallies</code></td>
<td>2</td>
<td>A list of objects of type <code><a title="pyphits.DumpFluence" href="#pyphits.DumpFluence">DumpFluence</a></code>, <code><a title="pyphits.DumpProduction" href="#pyphits.DumpProduction">DumpProduction</a></code>, or <code><a title="pyphits.DumpTime" href="#pyphits.DumpTime">DumpTime</a></code>.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>command</code></td>
<td>The shell command to invoke on the generated file.</td>
</tr>
<tr>
<td><code>hard_error</code></td>
<td>If truthy, raise an error and halt if PHITS encounters one. Otherwise, simply print the error and continue</td>
</tr>
<tr>
<td>(helpful in avoiding "I let it run all night and it crashed the minute I left the room" scenarios).</td>
<td></td>
</tr>
<tr>
<td><code>filename</code></td>
<td>The name of the input file on which to call PHITS. Of little utility except for debugging.</td>
</tr>
<tr>
<td><code>return_type</code></td>
<td>Either "dict", "numpy", or "pandas", corresponding to the desired result format.</td>
</tr>
<tr>
<td><code>injected_files</code></td>
<td>A list of path- or file-like objects to <code>shutil.copy</code>/<code>shutil.copyfileobj</code> to the temporary directory.</td>
</tr>
<tr>
<td><code>yanked_files</code></td>
<td>A list of paths relative to the temporary directory which will be copied out to <code>yank_to</code> before cleanup.</td>
</tr>
<tr>
<td><code>yank_to</code></td>
<td>A path to which <code>yanked_files</code> will be saved.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_phits(cells, sources, tallies, command: str = &#34;phits&#34;, hard_error: bool = True, filename: str = &#34;phits.inp&#34;,
              return_type: str = &#34;dict&#34;, injected_files=[], yanked_files=[], yank_to=os.getcwd(), **make_input_kwargs):
    &#34;&#34;&#34;Given a scenario, calls `make_input` to generate a corresponding input file, runs PHITS on it in a temporary directory,
    and then collects and returns the resulting output as nice Python objects.

    Required arguments:

    | Name | Position | Description |
    | ---- | -------- | ----------- |
    | `cells` | 0 | A list of `PhitsObject`s with `name == &#34;cell&#34;`.|
    | `sources` | 1 | Either a single `PhitsObject` with `name == &#34;source&#34;`, or a list of tuples (&lt;source object&gt;, &lt;weight&gt;).|
    | `tallies` | 2 | A list of objects of type `DumpFluence`, `DumpProduction`, or `DumpTime`.|

    Optional arguments:

    | Name | Description |
    | ---- | ----------- |
    | `command` | The shell command to invoke on the generated file. |
    | `hard_error` | If truthy, raise an error and halt if PHITS encounters one. Otherwise, simply print the error and continue
    (helpful in avoiding &#34;I let it run all night and it crashed the minute I left the room&#34; scenarios). |
    | `filename` | The name of the input file on which to call PHITS. Of little utility except for debugging. |
    | `return_type` | Either &#34;dict&#34;, &#34;numpy&#34;, or &#34;pandas&#34;, corresponding to the desired result format. |
    | `injected_files` | A list of path- or file-like objects to `shutil.copy`/`shutil.copyfileobj` to the temporary directory. |
    | `yanked_files` | A list of paths relative to the temporary directory which will be copied out to `yank_to` before cleanup. |
    | `yank_to` | A path to which `yanked_files` will be saved. |
    &#34;&#34;&#34;
    with tf.TemporaryDirectory() as newdir:
        inp = make_input(cells, sources, tallies, **make_input_kwargs)
        name = os.path.join(newdir, filename)
        with open(os.path.join(newdir, filename), &#34;w&#34;) as inp_file:
            inp_file.write(inp)

        for path in injected_files:
            copy(path, os.path.join(newdir, os.path.basename(path)))

        try:
            # TODO: PHITS actualy **DOESN&#39;T FKING SET EXIT CODES ON ERROR** so will have to grep the output for &#34;Error&#34;...
            out = sp.run([&#34;phits&#34;, filename], capture_output=True, text=True, cwd=newdir)
            assert not re.search(&#34;(?i:Error)&#34;, out.stdout), &#34;PHITS Error.&#34; # this REALLY sucks. Thank PHITS.
            assert out.returncode == 0, &#34;PHITS Error&#34;

        except AssertionError as error:
            r = f&#34;PHITS exited with code {out.returncode}.\n&#34;
            r += f&#34;stdout: {out.stdout}\n&#34;
            r += f&#34;stderr: {out.stderr}\n&#34;
            r += &#34;Offending input file:\n&#34;
            for idx, line in enumerate(inp.split(&#34;\n&#34;)):
                r += f&#34;{idx}:    {line}\n&#34;

            if hard_error:
                raise RuntimeError(r)
            else:
                print(r)

        result = dict()
        for t in tallies:

            dfile = &#34;&#34;
            if t.name == &#34;t-cross&#34;:
                dfile = os.path.join(newdir, f&#34;cross{t.index}_dmp&#34;)
            elif t.name == &#34;t-product&#34;:
                dfile = os.path.join(newdir, f&#34;product{t.index}_dmp&#34;)
            elif t.name == &#34;t-time&#34;:
                dfile = os.path.join(newdir, f&#34;time{t.index}_dmp&#34;)
            result[t] = read_dump(dfile, t.data, return_type)


        if yanked_files != []:
            for name in yanked_files:
                copy(os.path.join(newdir, name), yank_to)

        return result</code></pre>
</details>
</dd>
<dt id="pyphits.tuplified_lists"><code class="name flex">
<span>def <span class="ident">tuplified_lists</span></span>(<span>el)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyphits.AngleDistribution"><code class="flex name class">
<span>class <span class="ident">AngleDistribution</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An arbitrary distribution of source weights over angle.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>bins</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is (float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td>1</td>
<td><code>last_bin</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unit</code></td>
<td><code>a-type</code></td>
<td>One of the keys in {'cos': 1, 'degree': 11}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>particle_production</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AngleDistribution(PhitsObject):
    &#34;&#34;&#34;An arbitrary distribution of source weights over angle.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = {&#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal())), 0),
              &#34;last_bin&#34;: (None, PosReal(), 1),
              &#34;unit&#34;: (&#34;a-type&#34;, FinBij({&#34;cos&#34;: 1, &#34;degree&#34;: 11}), None),
              &#34;particle_production&#34;: (None, List(PosReal()), None)}

    shape = lambda self: (&#34;a-type = 14&#34; if self.unit == &#34;degree&#34; else &#34;a-type = 4&#34;,
                          f&#34;na = {len(self.bins)}&#34;,
                          &#34;\n&#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.bins) + f&#34;\n{self.last_bin}&#34;,
                          &#34;q-type = 1\n&#34; + &#34; &#34;.join((str(i) for i in self.particle_production)) if self.particle_production \
                          else &#34;&#34;)

    def restrictions(self):
        if self.particle_production is not None and len(self.bins) != len(self.particle_production):
            raise ValueError(&#34;For EnergyDistribution: len(bins) must equal len(particle_production).&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.AngleDistribution.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.particle_production is not None and len(self.bins) != len(self.particle_production):
        raise ValueError(&#34;For EnergyDistribution: len(bins) must equal len(particle_production).&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Beam"><code class="flex name class">
<span>class <span class="ident">Beam</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A beam-like source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>eccentricity</code></td>
<td><code>('x1', 'y1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>zbounds</code></td>
<td><code>('z0', 'z1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>phase_gradients</code></td>
<td><code>('rx', 'ry')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>sampling</code></td>
<td><code>wem</code></td>
<td>Either one of the keys in {'gaussian': 0}, with the value being the corresponding PHITS value, or float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>('x1', 'y1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>angle_dispersion</code></td>
<td><code>('xmrad1', 'ymrad1')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>phase_center</code></td>
<td><code>('x2', 'y2')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>phase_angle_center</code></td>
<td><code>('xmrad2', 'ymrad2')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>positive</code></td>
<td><code>dir</code></td>
<td>One of the keys in {True: 1, False: -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Beam(PhitsObject): # I don&#39;t understand what this is trying to do
    &#34;&#34;&#34;A beam-like source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;eccentricity&#34;: ((&#34;x1&#34;, &#34;y1&#34;), (Real(), Real()), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                       &#34;phase_gradients&#34;: ((&#34;rx&#34;, &#34;ry&#34;), (Real(), Real()), None),
                       &#34;sampling&#34;: (&#34;wem&#34;, OneOf(FinBij({&#34;gaussian&#34;: 0}), PosReal()), None),
                       &#34;dispersion&#34;: ((&#34;x1&#34;, &#34;y1&#34;), (Real(), Real()), None),
                       &#34;angle_dispersion&#34;: ((&#34;xmrad1&#34;, &#34;ymrad1&#34;), (PosReal(), PosReal()), None),
                       &#34;phase_center&#34;: ((&#34;x2&#34;, &#34;y2&#34;), (Real(), Real()), None),
                       &#34;phase_angle_center&#34;: ((&#34;xmrad2&#34;, &#34;ymrad2&#34;), (Real(), Real()), None),
                       &#34;positive&#34;: (&#34;dir&#34;, FinBij({True: 1, False: -1}), None),
                       &#34;spectrum&#34;: (None, IsA(EnergyDistribution), 1)}

    shape = (&#34;s-type = 11&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
             &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;eccentricity&#34;, &#34;zbounds&#34;, &#34;phase_gradients&#34;, &#34;sampling&#34;, &#34;dispersion&#34;,
             &#34;angle_dispersion&#34;, &#34;phase_center&#34;, &#34;phase_angle_center&#34;, &#34;positive&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Box"><code class="flex name class">
<span>class <span class="ident">Box</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A box given by a displacement vector to a corner and three orthogonal vectors defining its walls.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>base</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>walls</code></td>
<td><code>None</code></td>
<td>An orthogonal matrix (AA^T = I) representing a rotation.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Box(PhitsObject): # box formed by three vectors with tails at a given base point, or cross product of 3 intervals,
           # stored in the form x0 y0 z0 Ax Ay Az Bx By Bz Cx Cy Cz
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;base&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;walls&#34;: (None, OrthogonalMatrix(), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;BOX&#34;, &#34;base&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.walls)),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Cell"><code class="flex name class">
<span>class <span class="ident">Cell</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The prototypical <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code>, consisting of the intersection of several regions defined by surfaces with a material of some density.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>regions</code></td>
<td><code>None</code></td>
<td>A recursive tuple of surfaces with set operation semantics: "~" negates what follows, infix "</td>
</tr>
<tr>
<td>1</td>
<td><code>material</code></td>
<td><code>None</code></td>
<td>An instance of Material.</td>
</tr>
<tr>
<td>2</td>
<td><code>density</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>magnetic_field</code></td>
<td><code>None</code></td>
<td>Either an instance of MagneticField, or an instance of NeutronMagneticField.</td>
</tr>
<tr>
<td><code>electromagnetic_field</code></td>
<td><code>None</code></td>
<td>Either , or an instance of ElectromagneticField.</td>
</tr>
<tr>
<td><code>delta_ray</code></td>
<td><code>None</code></td>
<td>An instance of DeltaRay.</td>
</tr>
<tr>
<td><code>track_structure</code></td>
<td><code>None</code></td>
<td>An instance of TrackStructure.</td>
</tr>
<tr>
<td><code>elastic_option</code></td>
<td><code>None</code></td>
<td>An instance of ElasticOption.</td>
</tr>
<tr>
<td><code>importance</code></td>
<td><code>None</code></td>
<td>An instance of Importance.</td>
</tr>
<tr>
<td><code>weight_window</code></td>
<td><code>None</code></td>
<td>An instance of WeightWindow.</td>
</tr>
<tr>
<td><code>ww_bias</code></td>
<td><code>None</code></td>
<td>An instance of WWBias.</td>
</tr>
<tr>
<td><code>forced_collisions</code></td>
<td><code>None</code></td>
<td>An instance of ForcedCollisions.</td>
</tr>
<tr>
<td><code>repeated_collisions</code></td>
<td><code>None</code></td>
<td>An instance of RepeatedCollisions.</td>
</tr>
<tr>
<td><code>reg_name</code></td>
<td><code>None</code></td>
<td>An instance of RegionName.</td>
</tr>
<tr>
<td><code>counter</code></td>
<td><code>None</code></td>
<td>An instance of Counter.</td>
</tr>
<tr>
<td><code>timer</code></td>
<td><code>None</code></td>
<td>An instance of Timer.</td>
</tr>
<tr>
<td><code>volume</code></td>
<td><code>VOL</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>temperature</code></td>
<td><code>TMP</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>TRCL</code></td>
<td>An instance of Transform.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cell(PhitsObject):
    &#34;&#34;&#34;The prototypical `Cell`, consisting of the intersection of several regions defined by surfaces with a material of some density.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, RegionTuple(_surface_spec), 0),
                              &#34;material&#34;: (None, IsA(Material, index=True), 1),
                              &#34;density&#34;: (None, PosReal(), 2)}
    shape = lambda self: ((&#34;self&#34;, &#34;material&#34;, &#34;density&#34;, &#34;regions&#34;, &#34;\\&#34;),
                          &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;&#34;)

    subobjects = set(_subobject_syntax.keys())

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r

    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Cone"><code class="flex name class">
<span>class <span class="ident">Cone</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A truncated right-angle cone with bottom-face center (x_0, y_0, z_0), height vector (H_x, H_y, H_z), and bottom and top radii
R_1 and R_2 respectively.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>center</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>height</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>bottom_r</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>3</td>
<td><code>top_r</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cone(PhitsObject):
    &#34;&#34;&#34;A truncated right-angle cone with bottom-face center (x_0, y_0, z_0), height vector (H_x, H_y, H_z), and bottom and top radii
    R_1 and R_2 respectively.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                               &#34;height&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                               &#34;radii&#34;: ((&#34;top&#34;, &#34;bottom&#34;), Interval(0), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;TRC&#34;, &#34;center&#34;, &#34;height&#34;, &#34;radii&#34;),)

    def restrictions(self):
        if self.height == (0, 0, 0):
            raise ValueError(&#34;Cone must have a nonzero height vector.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Cone.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.height == (0, 0, 0):
        raise ValueError(&#34;Cone must have a nonzero height vector.&#34;)

    if self.bottom_r &lt;= self.top_r:
        raise ValueError(&#34;Cone must have a top radius smaller than its bottom radius;&#34;
                         f&#34; got bottom_r={self.bottom_r} and top_r={self.top_r}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Conical"><code class="flex name class">
<span>class <span class="ident">Conical</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A conical solid source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>('x0', 'y0', 'z0')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>altitude</code></td>
<td><code>('x1', 'y1', 'z1')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>trim</code></td>
<td><code>('r0', 'r1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>angle</code></td>
<td><code>r2</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conical(PhitsObject):
    &#34;&#34;&#34;A conical solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;top&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;altitude&#34;: ((&#34;x1&#34;, &#34;y1&#34;, &#34;z1&#34;), (Real(), Real(), Real()), None),
                       &#34;trim&#34;: ((&#34;r0&#34;, &#34;r1&#34;), (Real(), Real()), None),
                       &#34;angle&#34;: (&#34;r2&#34;, PosReal(), None)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 18&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;top&#34;, &#34;altitude&#34;, &#34;trim&#34;, &#34;angle&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;,
                          &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Counter"><code class="flex name class">
<span>class <span class="ident">Counter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Configures one of three counters, which can track all manner of things. Results accessible through tallies.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>entry</code></td>
<td><code>None</code></td>
<td>Integer between -9999 and 10000.</td>
</tr>
<tr>
<td>2</td>
<td><code>exit</code></td>
<td><code>None</code></td>
<td>Integer between -9999 and 10000.</td>
</tr>
<tr>
<td>3</td>
<td><code>collision</code></td>
<td><code>None</code></td>
<td>Integer between -9999 and 10000.</td>
</tr>
<tr>
<td>4</td>
<td><code>reflection</code></td>
<td><code>None</code></td>
<td>Integer between -9999 and 10000.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Counter(PhitsObject):
    &#34;&#34;&#34;Configures one of three counters, which can track all manner of things. Results accessible through tallies.&#34;&#34;&#34;
    name = &#34;counter&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(OneOf(Particle(), Nuclide()), max_len=20, unique=True), 0),
              &#34;entry&#34;: (None, Between(-9999, 10000), 1),
              &#34;exit&#34;: (None, Between(-9999, 10000), 2),
              &#34;collision&#34;: (None, Between(-9999, 10000), 3),
              &#34;reflection&#34;: (None, Between(-9999, 10000), 4),
              }

    superobjects = [&#34;cell&#34;]
    prelude = (&#34;particles&#34;, (&#34;reg&#34;, &#34;in&#34;, &#34;out&#34;, &#34;coll&#34;, &#34;ref&#34;))
    shape = ((&#34;cell&#34;, &#34;entry&#34;, &#34;exit&#34;, &#34;collision&#34;, &#34;reflection&#34;),)

    group_by = lambda self: self.particles
    separator = lambda self: self.section_title() + f&#34;counter = {self.index}\n&#34;
    max_groups = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Cylinder"><code class="flex name class">
<span>class <span class="ident">Cylinder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A right-circular cylinder with center of the bottom face (x_0, y_0, z_0), height vector from the bottom to top face (H_x, H_y, H_z),
and radius R.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>center</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>height</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>radius</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cylinder(PhitsObject):
    &#34;&#34;&#34;A right-circular cylinder with center of the bottom face (x_0, y_0, z_0), height vector from the bottom to top face (H_x, H_y, H_z),
    and radius R.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;height&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;radius&#34;: (None, PosReal(), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;RCC&#34;, &#34; &#34;.join(str(i) for i in self.center), &#34; &#34;.join(str(i) for i in self.height), &#34;radius&#34;),)

    def restrictions(self):
        if self.height == (0, 0, 0):
            raise ValueError(&#34;Cylinder must have a nonzero height vector.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Cylinder.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.height == (0, 0, 0):
        raise ValueError(&#34;Cylinder must have a nonzero height vector.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Cylindrical"><code class="flex name class">
<span>class <span class="ident">Cylindrical</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A cylindrical solid source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>zbounds</code></td>
<td><code>('z0', 'z1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>radius</code></td>
<td><code>r0</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>cutout_radius</code></td>
<td><code>r1</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cylindrical(PhitsObject):
    &#34;&#34;&#34;A cylindrical solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                        &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                        &#34;radius&#34;: (&#34;r0&#34;, PosReal(), None),
                        &#34;cutout_radius&#34;: (&#34;r1&#34;, PosReal(), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 1&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;charge_override&#34;, &#34;counter_start&#34;,
                          &#34;fissile&#34;, &#34;center&#34;, &#34;zbounds&#34;, &#34;radius&#34;, &#34;cutout_radius&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if (self.radius is None or self.radius == 0) and self.cutout_radius is not None:
            raise ValueError(&#34;Cylindrical sources that specify a cutout radius must also specify a nonzero radius;&#34;
                             &#34;got cutout_radius={self.cutout_radius}.&#34;)
        if self.radius is not None and self.cutout_radius is not None and self.radius &lt; self.cutout_radius:
            raise ValueError(&#34;Cylindrical sources cannot have cutouts larger than their radius;&#34;
                             f&#34;got radius={self.radius} and cutout_radius={self.cutout_radius}.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Cylindrical.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if (self.radius is None or self.radius == 0) and self.cutout_radius is not None:
        raise ValueError(&#34;Cylindrical sources that specify a cutout radius must also specify a nonzero radius;&#34;
                         &#34;got cutout_radius={self.cutout_radius}.&#34;)
    if self.radius is not None and self.cutout_radius is not None and self.radius &lt; self.cutout_radius:
        raise ValueError(&#34;Cylindrical sources cannot have cutouts larger than their radius;&#34;
                         f&#34;got radius={self.radius} and cutout_radius={self.cutout_radius}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.DataMax"><code class="flex name class">
<span>class <span class="ident">DataMax</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the maximum energy for an interaction between particles and nucleus in the material.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is one of the keys in {'proton': 'proton', 'neutron': 'neutron'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>nucleus</code></td>
<td><code>None</code></td>
<td>A nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>2</td>
<td><code>max_energy</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataMax(PhitsObject):
    &#34;&#34;&#34;Sets the maximum energy for an interaction between particles and nucleus in the material.&#34;&#34;&#34;
    name = &#34;data_max&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(FinBij({&#34;proton&#34;: &#34;proton&#34;, &#34;neutron&#34;: &#34;neutron&#34;}), unique=True), 0),
              &#34;nucleus&#34;: (None, Nuclide(fake=True), 1),
              &#34;max_energy&#34;: (None, PosReal(), 2)}
    superobjects = [&#34;material&#34;]
    prelude = (&#34;particles&#34;, (&#34;mat&#34;, &#34;&#39;nucleus&#34;, &#34;dmax&#34;))
    # Manual lies about accepting the usual syntax for nuclides
    shape = lambda self: ((&#34;material&#34;, &#34;nucleus&#34;, &#34;max_energy&#34;),)
    group_by = lambda self: (self.particles,)
    separator = lambda self: self.section_title()
    max_groups = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.DeltaRay"><code class="flex name class">
<span>class <span class="ident">DeltaRay</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A threshold energy fo each cell, above which delta rays are to be produced.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>threshold</code></td>
<td><code>None</code></td>
<td>Float between 1 and None.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeltaRay(PhitsObject):
    &#34;&#34;&#34;A threshold energy fo each cell, above which delta rays are to be produced.&#34;&#34;&#34;
    name = &#34;delta_ray&#34;
    syntax = {&#34;threshold&#34;: (None, RealBetween(1, None), 0),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;del&#34;),)
    shape = ((&#34;cell&#34;, &#34;threshold&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.DumpFluence"><code class="flex name class">
<span>class <span class="ident">DumpFluence</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Tally that counts some quantity whenever a particle crosses from one region to another.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>out</code></td>
<td><code>None</code></td>
<td>An instance of Cell.</td>
</tr>
<tr>
<td>1</td>
<td><code>into</code></td>
<td><code>None</code></td>
<td>An instance of Cell.</td>
</tr>
<tr>
<td>2</td>
<td><code>area</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>3</td>
<td><code>data</code></td>
<td><code>dump</code></td>
<td>A list of values, each of which is one of the keys in {'particle': 1, 'x': 2, 'y': 3, 'z': 4, 'u': 5, 'v': 6, 'w': 7, 'energy': 8, 'weight': 9, 'time': 10, 'counter1': 11, 'counter2': 12, 'counter3': 13, 'spinx': 14, 'spiny': 15, 'spinz': 16, 'collision_number': 17, 'history_number': 18, 'batch_number': 19, 'cascade_id': 20}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>4</td>
<td><code>output</code></td>
<td><code>output</code></td>
<td>One of the keys in {'current': 'current', 'a_current': 'a-curr', 'oa_current': 'oa-curr'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>5</td>
<td><code>energy_mesh</code></td>
<td><code>('emin', 'emax', 'ne')</code></td>
<td>A tuple (a tuple of length 2 contained in (0, inf), integer between 1 and 50).</td>
</tr>
<tr>
<td>6</td>
<td><code>angle_mesh</code></td>
<td><code>('amin', 'amax', 'na')</code></td>
<td>A tuple (a tuple of length 2 contained in (-1, 1), integer between 1 and 50).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td><code>factor</code></td>
<td><code>factor</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>maximum_error</code></td>
<td><code>stdcut</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>angle_semantics</code></td>
<td><code>iangform</code></td>
<td>One of the keys in {'to_normal': 0, 'to_x': 1, 'to_y': 2, 'to_z': 3}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>time_mesh</code></td>
<td><code>('tmin', 'tmax', 'nt')</code></td>
<td>A tuple (a tuple of length 2 contained in (0, inf), integer between 1 and 50).</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DumpFluence(PhitsObject):
    &#34;&#34;&#34;Tally that counts some quantity whenever a particle crosses from one region to another.&#34;&#34;&#34;
    name = &#34;t-cross&#34;
    syntax = {&#34;out&#34;: (None, IsA(Cell, index=True), 0),
              &#34;into&#34;: (None, IsA(Cell, index=True), 1),
              &#34;area&#34;: (None, PosReal(), 2),
              &#34;data&#34;: (&#34;dump&#34;, List(FinBij({&#34;particle&#34;: 1, &#34;x&#34;: 2, &#34;y&#34;: 3, &#34;z&#34;: 4, &#34;u&#34;: 5, &#34;v&#34;: 6, &#34;w&#34;: 7, &#34;energy&#34;: 8, &#34;weight&#34;: 9,
                                            &#34;time&#34;: 10, &#34;counter1&#34;: 11, &#34;counter2&#34;: 12, &#34;counter3&#34;: 13, &#34;spinx&#34;: 14, &#34;spiny&#34;: 15,
                                            &#34;spinz&#34;: 16, &#34;collision_number&#34;: 17, &#34;history_number&#34;: 18, &#34;batch_number&#34;: 19,
                                            &#34;cascade_id&#34;: 20}), unique=True), 3),
              &#34;output&#34;: (&#34;output&#34;, FinBij({&#34;current&#34;: &#34;current&#34;, &#34;a_current&#34;: &#34;a-curr&#34;, &#34;oa_current&#34;: &#34;oa-curr&#34;}), 4),
              &#34;particles&#34;: (&#34;part&#34;, List(Particle(), max_len=6, unique=True), None),
              &#34;factor&#34;: (&#34;factor&#34;, PosReal(), None),
              # &#34;counter&#34;: ()
              &#34;maximum_error&#34;: (&#34;stdcut&#34;, PosReal(), None),
              # &#34;multiplier&#34;: ()
              # TODO: set Between() back to PosInt; done because otherwise memory overflows on my machine during tests
              &#34;energy_mesh&#34;: ((&#34;emin&#34;, &#34;emax&#34;, &#34;ne&#34;), (Interval(0), Between(1, 50)), 5),
              &#34;angle_mesh&#34;: ((&#34;amin&#34;, &#34;amax&#34;, &#34;na&#34;), (Interval(-1, 1), Between(1, 50)), 6),
              &#34;angle_semantics&#34;: (&#34;iangform&#34;, FinBij({&#34;to_normal&#34;: 0, &#34;to_x&#34;: 1, &#34;to_y&#34;: 2, &#34;to_z&#34;: 3}), None),
              &#34;time_mesh&#34;: ((&#34;tmin&#34;, &#34;tmax&#34;, &#34;nt&#34;), (Interval(0), Between(1, 50)), None)}

    prelude = lambda self: (&#34;particles&#34;, &#34;unit = 1&#34;, &#34;axis = reg&#34;, f&#34;file = cross{self.index}&#34;, &#34;factor&#34;, &#34;output&#34;, &#34;maximum_error&#34;,
                            f&#34;dump = -{len(self.data)}&#34;, (&#34;data&#34;,),
                            &#34;e-type = 2&#34;, f&#34;emin = {self.energy_mesh[0][0]}&#34;, f&#34;emax = {self.energy_mesh[0][1]}&#34;,
                            f&#34;ne = {self.energy_mesh[1]}&#34;,
                            f&#34;a-type = 2\namin = {self.angle_mesh[0][0]}\namax = {self.angle_mesh[0][1]}\nna = {self.angle_mesh[1]}&#34; \
                            if self.angle_mesh is not None else &#34;&#34;, &#34;angle_semantics&#34;,
                            f&#34;t-type = 2\ntmin = {self.angle_mesh[0][0]}\ntmax = {self.time_mesh[0][1]}\nnt = {self.time_mesh[1]}&#34; \
                            if self.time_mesh is not None else &#34;&#34;,
                            &#34;mesh = reg&#34;, f&#34;reg = {self.group_size}&#34;,
                            (&#34;r-from&#34;, &#34;r-to&#34;, &#34;&#39;area&#34;))

    shape = lambda self: ((f&#34;{self.out.index}&#34;, f&#34;{self.into.index}&#34;, &#34;area&#34;),)

    group_by = lambda self: (self.particles, self.data, self.output, self.factor, self.energy_mesh, self.angle_mesh,
                             self.time_mesh)
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.DumpProduction"><code class="flex name class">
<span>class <span class="ident">DumpProduction</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Tally that counts how many particles of some type are created within a <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code>.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>cell</code></td>
<td><code>reg</code></td>
<td>An instance of Cell.</td>
</tr>
<tr>
<td>1</td>
<td><code>data</code></td>
<td><code>dump</code></td>
<td>A list of values, each of which is one of the keys in {'particle': 1, 'x': 2, 'y': 3, 'z': 4, 'u': 5, 'v': 6, 'w': 7, 'energy': 8, 'weight': 9, 'time': 10, 'counter1': 11, 'counter2': 12, 'counter3': 13, 'spinx': 14, 'spiny': 15, 'spinz': 16, 'collision_number': 17, 'history_number': 18, 'batch_number': 19, 'cascade_id': 20}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>2</td>
<td><code>output</code></td>
<td><code>output</code></td>
<td>One of the keys in {'source': 'source', 'nuclear': 'nuclear', 'nonela': 'nonela', 'elastic': 'elastic', 'decay': 'decay', 'fission': 'fission', 'atomic': 'atomic'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>3</td>
<td><code>energy_mesh</code></td>
<td><code>('emin', 'emax', 'ne')</code></td>
<td>A tuple (a tuple of length 2 contained in (0, inf), integer between 1 and 50).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td><code>materials</code></td>
<td><code>material</code></td>
<td>A list of values, each of which is an instance of Material.</td>
</tr>
<tr>
<td><code>mother</code></td>
<td><code>material</code></td>
<td>A list of values, each of which is a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td><code>factor</code></td>
<td><code>factor</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>maximum_error</code></td>
<td><code>stdcut</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>time_mesh</code></td>
<td><code>('tmin', 'tmax', 'nt')</code></td>
<td>A tuple (a tuple of length 2 contained in (0, inf), integer between 1 and 50).</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DumpProduction(PhitsObject):
    &#34;&#34;&#34;Tally that counts how many particles of some type are created within a `Cell`.&#34;&#34;&#34;
    name = &#34;t-product&#34;
    syntax = {&#34;cell&#34;: (&#34;reg&#34;, IsA(Cell, index=True), 0),
              &#34;data&#34;: (&#34;dump&#34;, List(FinBij({&#34;particle&#34;: 1, &#34;x&#34;: 2, &#34;y&#34;: 3, &#34;z&#34;: 4, &#34;u&#34;: 5, &#34;v&#34;: 6, &#34;w&#34;: 7, &#34;energy&#34;: 8, &#34;weight&#34;: 9,
                                            &#34;time&#34;: 10, &#34;counter1&#34;: 11, &#34;counter2&#34;: 12, &#34;counter3&#34;: 13, &#34;spinx&#34;: 14, &#34;spiny&#34;: 15,
                                            &#34;spinz&#34;: 16, &#34;collision_number&#34;: 17, &#34;history_number&#34;: 18, &#34;batch_number&#34;: 19,
                                            &#34;cascade_id&#34;: 20}), unique=True), 1),
              &#34;output&#34;: (&#34;output&#34;, FinBij({&#34;source&#34;: &#34;source&#34;, &#34;nuclear&#34;: &#34;nuclear&#34;, &#34;nonela&#34;: &#34;nonela&#34;, &#34;elastic&#34;: &#34;elastic&#34;,
                                           &#34;decay&#34;: &#34;decay&#34;, &#34;fission&#34;: &#34;fission&#34;, &#34;atomic&#34;: &#34;atomic&#34;}), 2),
              &#34;particles&#34;: (&#34;part&#34;, List(Particle(), max_len=6, unique=True), None),
              &#34;materials&#34;: (&#34;material&#34;, List(IsA(Material, index=True)), None),
              &#34;mother&#34;: (&#34;material&#34;, List(Nuclide(fake=True)), None),
              &#34;factor&#34;: (&#34;factor&#34;, PosReal(), None),
              # counter
              &#34;maximum_error&#34;: (&#34;stdcut&#34;, PosReal(), None),
              # &#34;multiplier&#34;: ()
              # TODO: set Between() back to PosInt; done because otherwise the memory overflows
              &#34;energy_mesh&#34;: ((&#34;emin&#34;, &#34;emax&#34;, &#34;ne&#34;), (Interval(0), Between(1, 50)), 3),
              &#34;time_mesh&#34;: ((&#34;tmin&#34;, &#34;tmax&#34;, &#34;nt&#34;), (Interval(0), Between(1, 50)), None)}


    prelude = lambda self: (&#34;particles&#34;, &#34;unit = 1&#34;, &#34;axis = reg&#34;, f&#34;file = product{self.index}&#34;, &#34;factor&#34;, &#34;output&#34;, &#34;maximum_error&#34;,
                            f&#34;material = {len(self.materials)}&#34; if self.materials is not None else &#34;&#34;, (&#34;materials&#34;,),
                            f&#34;mother = {len(self.mother)}&#34; if self.mother is not None else &#34;&#34;, (&#34;mother&#34;,),
                            f&#34;dump = -{len(self.data)}&#34;, (&#34;data&#34;,),
                            &#34;e-type = 2&#34;, f&#34;emin = {self.energy_mesh[0][0]}&#34;, f&#34;emax = {self.energy_mesh[0][1]}&#34;,
                            f&#34;ne = {self.energy_mesh[1]}&#34;,
                            f&#34;t-type = 2\ntmin = {self.time_mesh[0][0]}\ntmax = {self.time_mesh[0][1]}\nnt = {self.time_mesh[1]}&#34; \
                            if self.time_mesh is not None else &#34;&#34;,
                            &#34;mesh = reg&#34;)

    shape = (&#34;cell&#34;,)

    group_by = lambda self: (self.particles, self.data, self.output, self.factor, self.energy_mesh, self.time_mesh)
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.DumpTime"><code class="flex name class">
<span>class <span class="ident">DumpTime</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Tally that records how particles' disappearance (via energy cutoff, escape, decay) changes over time in a <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code>.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>cell</code></td>
<td><code>reg</code></td>
<td>An instance of Cell.</td>
</tr>
<tr>
<td>1</td>
<td><code>data</code></td>
<td><code>dump</code></td>
<td>A list of values, each of which is one of the keys in {'particle': 1, 'x': 2, 'y': 3, 'z': 4, 'u': 5, 'v': 6, 'w': 7, 'energy': 8, 'weight': 9, 'time': 10, 'counter1': 11, 'counter2': 12, 'counter3': 13, 'spinx': 14, 'spiny': 15, 'spinz': 16, 'collision_number': 17, 'history_number': 18, 'batch_number': 19, 'cascade_id': 20}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>2</td>
<td><code>output</code></td>
<td><code>output</code></td>
<td>One of the keys in {'all': 'all', 'cutoff': 'cutoff', 'escape': 'escape', 'decay': 'decay'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>3</td>
<td><code>energy_mesh</code></td>
<td><code>('emin', 'emax', 'ne')</code></td>
<td>A tuple (a tuple of length 2 contained in (0, inf), integer between 1 and 50).</td>
</tr>
<tr>
<td>4</td>
<td><code>time_mesh</code></td>
<td><code>('tmin', 'tmax', 'nt')</code></td>
<td>A tuple (a tuple of length 2 contained in (0, inf), integer between 1 and 50).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td><code>materials</code></td>
<td><code>material</code></td>
<td>A list of values, each of which is an instance of Material.</td>
</tr>
<tr>
<td><code>factor</code></td>
<td><code>factor</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>maximum_error</code></td>
<td><code>stdcut</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DumpTime(PhitsObject):
    &#34;&#34;&#34;Tally that records how particles&#39; disappearance (via energy cutoff, escape, decay) changes over time in a `Cell`.&#34;&#34;&#34;
    name = &#34;t-time&#34;
    syntax = {&#34;cell&#34;: (&#34;reg&#34;, IsA(Cell, index=True), 0),
              &#34;data&#34;: (&#34;dump&#34;, List(FinBij({&#34;particle&#34;: 1, &#34;x&#34;: 2, &#34;y&#34;: 3, &#34;z&#34;: 4, &#34;u&#34;: 5, &#34;v&#34;: 6, &#34;w&#34;: 7, &#34;energy&#34;: 8, &#34;weight&#34;: 9,
                                            &#34;time&#34;: 10, &#34;counter1&#34;: 11, &#34;counter2&#34;: 12, &#34;counter3&#34;: 13, &#34;spinx&#34;: 14, &#34;spiny&#34;: 15,
                                            &#34;spinz&#34;: 16, &#34;collision_number&#34;: 17, &#34;history_number&#34;: 18, &#34;batch_number&#34;: 19,
                                            &#34;cascade_id&#34;: 20}), unique=True), 1),
              &#34;output&#34;: (&#34;output&#34;, FinBij({&#34;all&#34;: &#34;all&#34;, &#34;cutoff&#34;: &#34;cutoff&#34;, &#34;escape&#34;: &#34;escape&#34;, &#34;decay&#34;: &#34;decay&#34;}), 2),
              &#34;particles&#34;: (&#34;part&#34;, List(Particle(), max_len=6, unique=True), None),
              &#34;materials&#34;: (&#34;material&#34;, List(IsA(Material, index=True)), None),
              &#34;factor&#34;: (&#34;factor&#34;, PosReal(), None),
              # counter
              &#34;maximum_error&#34;: (&#34;stdcut&#34;, PosReal(), None),
              # &#34;multiplier&#34;: ()
              &#34;energy_mesh&#34;: ((&#34;emin&#34;, &#34;emax&#34;, &#34;ne&#34;), (Interval(0), Between(1, 50)), 3),
              &#34;time_mesh&#34;: ((&#34;tmin&#34;, &#34;tmax&#34;, &#34;nt&#34;), (Interval(0), Between(1, 50)), 4)}


    prelude = lambda self: (&#34;particles&#34;, &#34;unit = 1&#34;, &#34;axis = reg&#34;, f&#34;file = time{self.index}&#34;, &#34;factor&#34;, &#34;output&#34;, &#34;maximum_error&#34;,
                            f&#34;material = {len(self.materials)}&#34; if self.materials is not None else &#34;&#34;, (&#34;materials&#34;,),
                            f&#34;dump = -{len(self.data)}&#34;, (&#34;data&#34;,),
                            &#34;e-type = 2&#34;, f&#34;emin = {self.energy_mesh[0][0]}&#34;, f&#34;emax = {self.energy_mesh[0][1]}&#34;,
                            f&#34;ne = {self.energy_mesh[1]}&#34;,
                            &#34;t-type = 2&#34;, f&#34;tmin = {self.time_mesh[0][0]}&#34;, f&#34;tmax = {self.time_mesh[0][1]}&#34;,
                            f&#34;nt = {self.time_mesh[1]}&#34;, &#34;mesh = reg&#34;)

    shape = (&#34;cell&#34;,)

    group_by = lambda self: (self.particles, self.data, self.output, self.factor, self.energy_mesh, self.time_mesh)
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.ElasticOption"><code class="flex name class">
<span>class <span class="ident">ElasticOption</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters for the user-specified elastic scattering law Fortran subroutines.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>c1</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>2</td>
<td><code>c2</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>3</td>
<td><code>c3</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>4</td>
<td><code>c4</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ElasticOption(PhitsObject):
    &#34;&#34;&#34;Parameters for the user-specified elastic scattering law Fortran subroutines.&#34;&#34;&#34;
    name = &#34;elastic_option&#34;
    syntax = {&#34;c1&#34;: (None, PosReal(), 1),
              &#34;c2&#34;: (None, PosReal(), 2),
              &#34;c3&#34;: (None, PosReal(), 3),
              &#34;c4&#34;: (None, PosReal(), 4)}

    prelude = ((&#34;reg&#34;, &#34;&#39;c1&#34;, &#34;&#39;c2&#34;, &#34;&#39;c3&#34;, &#34;&#39;c4&#34;),)
    shape = ((&#34;cell&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;c3&#34;, &#34;c4&#34;),)
    superobjects = [&#34;cell&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.ElectromagneticField"><code class="flex name class">
<span>class <span class="ident">ElectromagneticField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A uniform electromagnetic field within a region, affecting charged particles.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>e_strength</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>1</td>
<td><code>m_strength</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>e_transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>m_transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ElectromagneticField(PhitsObject):
    &#34;&#34;&#34;A uniform electromagnetic field within a region, affecting charged particles.&#34;&#34;&#34;
    name = &#34;electromagnetic_field&#34;
    syntax = {&#34;e_strength&#34;: (None, Real(), 0),
              &#34;m_strength&#34;: (None, Real(), 1),
              &#34;e_transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;m_transform&#34;: (None, IsA(Transform, index=True), None, 0),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;elf&#34;, &#34;mgf&#34;, &#34;trcle&#34;, &#34;trclm&#34;),)
    shape = ((&#34;cell&#34;, &#34;e_strength&#34;, &#34;m_strength&#34;, &#34;e_transform&#34;, &#34;m_transform&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.EllipticalCylinder"><code class="flex name class">
<span>class <span class="ident">EllipticalCylinder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An ellipse extruded into a cylinder, given by a center point and a three orthogonal vectors defining the extrusion and axes.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>center</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>axes</code></td>
<td><code>None</code></td>
<td>An orthogonal matrix (AA^T = I) representing a rotation.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EllipticalCylinder(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;axes&#34;: (None, OrthogonalMatrix(), 1)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;REC&#34;, &#34;center&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.axes)),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.EnergyDistribution"><code class="flex name class">
<span>class <span class="ident">EnergyDistribution</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An arbitrary distribution of source weights over energy.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>bins</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>adjust</code></td>
<td><code>None</code></td>
<td>One of the keys in {'particles': 'particles', 'weights': 'weights'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>units</code></td>
<td><code>None</code></td>
<td>One of the keys in {'MeV': 'MeV', 'Angstrom': 'Angstrom'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>normalize</code></td>
<td><code>None</code></td>
<td>One of the keys in {'1/Lethargy': -1, '1/MeV': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>particle_production</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnergyDistribution(PhitsObject):
    &#34;&#34;&#34;An arbitrary distribution of source weights over energy.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = {&#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal(), PosReal())), 0),
              &#34;adjust&#34;: (None, FinBij({&#34;particles&#34;: &#34;particles&#34;, &#34;weights&#34;: &#34;weights&#34;}), None),
              &#34;units&#34;: (None, FinBij({&#34;MeV&#34;: &#34;MeV&#34;, &#34;Angstrom&#34;: &#34;Angstrom&#34;}), None),
              &#34;normalize&#34;: (None, FinBij({&#34;1/Lethargy&#34;: -1, &#34;1/MeV&#34;: 1}), None), # TODO: check 1/MeV
              &#34;particle_production&#34;: (None, List(PosReal()), None)
              }

    shape = lambda slf: ((&#34;e-type = 22&#34; if slf.units == &#34;MeV&#34; else &#34;e-type = 32&#34;) if slf.adjust == &#34;particles&#34; else \
                          (&#34;e-type = 23&#34; if slf.units == &#34;MeV&#34; else &#34;e-type = 33&#34;),
                          f&#34;ne = -{len(slf.bins)}&#34; if slf.normalize == &#34;1/Lethargy&#34; else f&#34;ne = {len(slf.bins)}&#34;,
                          &#34;\n&#34;.join(&#34; &#34;.join(str(j) for j in i) for i in slf.bins),
                          &#34;p-type = 1\n&#34; + &#34; &#34;.join((str(i) for i in slf.particle_production)) if slf.particle_production else &#34;&#34;)
    def restrictions(self):
        if self.particle_production is not None and len(self.bins) != len(self.particle_production):
            raise ValueError(&#34;For EnergyDistribution: len(bins) must equal len(particle_production).&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.EnergyDistribution.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.particle_production is not None and len(self.bins) != len(self.particle_production):
        raise ValueError(&#34;For EnergyDistribution: len(bins) must equal len(particle_production).&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.ForcedCollisions"><code class="flex name class">
<span>class <span class="ident">ForcedCollisions</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the way tallies are calculated in a region for better measurement of low-probability interactions,
such as thin targets, or for improving statistics.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td>1</td>
<td><code>factor</code></td>
<td><code>None</code></td>
<td>Float between -1 and 1.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>force_secondaries</code></td>
<td><code>None</code></td>
<td>One of the keys in {True: 1, False: -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForcedCollisions(PhitsObject):
    &#34;&#34;&#34;Changes the way tallies are calculated in a region for better measurement of low-probability interactions, \
    such as thin targets, or for improving statistics.&#34;&#34;&#34;
    name = &#34;forced_collisions&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;factor&#34;: (None, RealBetween(-1, 1), 1),
              &#34;force_secondaries&#34;: (None, FinBij({True: 1, False: -1}), None),
              }

    superobjects = [&#34;cell&#34;]
    prelude = (&#34;particles&#34;, (&#34;reg&#34;, &#34;fcl&#34;))
    shape = lambda self: ((&#34;cell&#34;, f&#34;{self.force_secondaries * self.factor}&#34; if self.force_secondaries is not None \
                           else str(self.factor)),)

    group_by = lambda self: self.particles

    separator = lambda self: self.section_title()
    max_groups = 6

    def restrictions(self):
        if &#34;electron&#34; in self.particles or &#34;positron&#34; in self.particles:
            raise ValueError(f&#34;ForcedCollision does not accept electrons or positrons; got {self.particles}.&#34;)

    def global_restrictions(self, type_divided):
        all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;forced_collisions&#34;])))
        if len(set(all_particles)) &lt; len(all_particles):
            raise ValueError(&#34;Integration problem: all ForcedCollisions must have mutually disjoint lists of particles.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.ForcedCollisions.global_restrictions"><code class="name flex">
<span>def <span class="ident">global_restrictions</span></span>(<span>self, type_divided)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_restrictions(self, type_divided):
    all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;forced_collisions&#34;])))
    if len(set(all_particles)) &lt; len(all_particles):
        raise ValueError(&#34;Integration problem: all ForcedCollisions must have mutually disjoint lists of particles.&#34;)</code></pre>
</details>
</dd>
<dt id="pyphits.ForcedCollisions.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if &#34;electron&#34; in self.particles or &#34;positron&#34; in self.particles:
        raise ValueError(f&#34;ForcedCollision does not accept electrons or positrons; got {self.particles}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.FragData"><code class="flex name class">
<span>class <span class="ident">FragData</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables user-defined cross-sections for a particular interaction in a cell.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>semantics</code></td>
<td><code>None</code></td>
<td>One of the keys in {'histogram': 1, 'extrapolated': 4, 'interpolated': 5}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>projectile</code></td>
<td><code>None</code></td>
<td>Either one of the keys in {'proton': 'proton', 'neutron': 'neutron'}, with the value being the corresponding PHITS value, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>2</td>
<td><code>target</code></td>
<td><code>None</code></td>
<td>A nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>3</td>
<td><code>file</code></td>
<td><code>None</code></td>
<td>A valid file name.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FragData(PhitsObject):
    &#34;&#34;&#34;Enables user-defined cross-sections for a particular interaction in a cell.&#34;&#34;&#34;
    name = &#34;frag_data&#34;
    syntax = {&#34;semantics&#34;: (None, FinBij({&#34;histogram&#34;: 1, &#34;extrapolated&#34;: 4, &#34;interpolated&#34;: 5}), 0),
              &#34;projectile&#34;: (None, OneOf(FinBij({&#34;proton&#34;: &#34;proton&#34;, &#34;neutron&#34;: &#34;neutron&#34;}), Nuclide(fake=True)), 1),
              &#34;target&#34;: (None, Nuclide(fake=True), 2),
              &#34;file&#34;: (None, Path(), 3)}
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;opt&#34;, &#34;proj&#34;, &#34;targ&#34;, &#34;&#39;file&#34;),)
    shape = ((&#34;semantics&#34;, &#34;projectile&#34;, &#34;target&#34;, &#34;file&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Gaussian"><code class="flex name class">
<span>class <span class="ident">Gaussian</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Gaussian source from every direction.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0', 'z0')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>fwhms</code></td>
<td><code>('x1', 'y1', 'z1')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gaussian(PhitsObject):
    &#34;&#34;&#34;A Gaussian source from every direction.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;fwhms&#34;: ((&#34;x1&#34;, &#34;y1&#34;, &#34;z1&#34;), (PosReal(), PosReal(), PosReal()), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 3&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;fwhms&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                          else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.GaussianSlices"><code class="flex name class">
<span>class <span class="ident">GaussianSlices</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A 2D Gaussian source, uniform in the (z)-axis.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>fwhm</code></td>
<td><code>r1</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>zbounds</code></td>
<td><code>('z0', 'z1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GaussianSlices(PhitsObject):
    &#34;&#34;&#34;A 2D Gaussian source, uniform in the \\(z\\)-axis.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;fwhm&#34;: (&#34;r1&#34;, PosReal(), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 13&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;fwhm&#34;, &#34;zbounds&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                          else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.GeneralConic"><code class="flex name class">
<span>class <span class="ident">GeneralConic</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An arbitrary ellipsoid, hyperboloid, or paraboloid, of the mathematical form
(A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+Dxy+Eyz+Fzx+Gx+Hy+Jz+K = 0).Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>quadratic</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>mixed</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>linear</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>constant</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneralConic(PhitsObject): # ellipsoid, hyperboloid, or paraboloid of the form
                    # A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+Dxy+Eyz+Fzx+Gx+Hy+Jz+K = 0
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;quadratic&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;mixed&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;linear&#34;: ((None, None, None), (Real(), Real(), Real()), 2),
                       &#34;constant&#34;: (None, Real(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;GQ&#34;, &#34;quadratic&#34;, &#34;mixed&#34;, &#34;linear&#34;, &#34;constant&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Importance"><code class="flex name class">
<span>class <span class="ident">Importance</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the relative tally weight of certain particles in a cell.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td>1</td>
<td><code>importance</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Importance(PhitsObject):
    &#34;&#34;&#34;Change the relative tally weight of certain particles in a cell.&#34;&#34;&#34;
    name = &#34;importance&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;importance&#34;: (None, PosReal(), 1),
              }
    superobjects = [&#34;cell&#34;]
    prelude = (&#34;particles&#34;, (&#34;reg&#34;, &#34;imp&#34;))
    shape = ((&#34;cell&#34;, &#34;importance&#34;),)
    group_by = lambda self: self.particles
    separator = lambda self: self.section_title()
    max_groups = 6

    @classmethod
    def global_restrictions(self, type_divided):
        all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;importance&#34;])))
        if len(set(all_particles)) &lt; len(all_particles):
            raise ValueError(&#34;Integration problem: all Importances must have mutually disjoint lists of particles.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyphits.Importance.global_restrictions"><code class="name flex">
<span>def <span class="ident">global_restrictions</span></span>(<span>type_divided)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def global_restrictions(self, type_divided):
    all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;importance&#34;])))
    if len(set(all_particles)) &lt; len(all_particles):
        raise ValueError(&#34;Integration problem: all Importances must have mutually disjoint lists of particles.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.MagneticField"><code class="flex name class">
<span>class <span class="ident">MagneticField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A uniform magnetic field in a region, affecting charged particles.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>typ</code></td>
<td><code>None</code></td>
<td>One of the keys in {'dipole': 2, 'quadrupole': 4}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>strength</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>calc_freq</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>time</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MagneticField(PhitsObject):
    &#34;&#34;&#34;A uniform magnetic field in a region, affecting charged particles.&#34;&#34;&#34;
    name = &#34;magnetic_field&#34;
    syntax = {&#34;typ&#34;: (None, FinBij({&#34;dipole&#34;: 2, &#34;quadrupole&#34;: 4}), 0),
              &#34;strength&#34;: (None, Real(), 1),
              &#34;calc_freq&#34;: (None, PosReal(), None, 0.0),
              &#34;transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;time&#34;: (None, PosReal(), None, &#34;non&#34;),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;&#39;typ&#34;, &#34;&#39;gap&#34;, &#34;mgf&#34;, &#34;trcl&#34;, &#34;&#39;time&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ&#34;, &#34;calc_freq&#34;, &#34;strength&#34;, &#34;transform&#34;, &#34;time&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.MappedElectromagneticField"><code class="flex name class">
<span>class <span class="ident">MappedElectromagneticField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A non-unifrom electromagnetic field within a region, affecting charged particles, given by a file.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>typ_e</code></td>
<td><code>None</code></td>
<td>One of the keys in {'xyz_list_charged': -1, 'rz_list_charged': -2, 'xyz_map_charged': -3, 'rz_map_charged': -4}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>typ_m</code></td>
<td><code>None</code></td>
<td>One of the keys in {'xyz_list_charged': -1, 'rz_list_charged': -2, 'xyz_map_charged': -3, 'rz_map_charged': -4}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>2</td>
<td><code>calc_freq</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>3</td>
<td><code>e_normalization</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>4</td>
<td><code>m_normalization</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>5</td>
<td><code>e_file</code></td>
<td><code>None</code></td>
<td>A valid file name.</td>
</tr>
<tr>
<td>6</td>
<td><code>m_file</code></td>
<td><code>None</code></td>
<td>A valid file name.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>e_transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>m_transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MappedElectromagneticField(PhitsObject):
    &#34;&#34;&#34;A non-unifrom electromagnetic field within a region, affecting charged particles, given by a file.&#34;&#34;&#34;
    name = &#34;electromagnetic_field&#34;
    syntax = {&#34;typ_e&#34;: (None, FinBij({&#34;xyz_list_charged&#34;: -1, &#34;rz_list_charged&#34;: -2, &#34;xyz_map_charged&#34;: -3, &#34;rz_map_charged&#34;: -4}), 0),
              &#34;typ_m&#34;: (None, FinBij({&#34;xyz_list_charged&#34;: -1, &#34;rz_list_charged&#34;: -2, &#34;xyz_map_charged&#34;: -3, &#34;rz_map_charged&#34;: -4}), 1),
              &#34;calc_freq&#34;: (None, PosReal(), 2),
              &#34;e_normalization&#34;: (None, Real(), 3),
              &#34;m_normalization&#34;: (None, Real(), 4),
              &#34;e_file&#34;: (None, Path(), 5),
              &#34;m_file&#34;: (None, Path(), 6),
              &#34;e_transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;m_transform&#34;: (None, IsA(Transform, index=True), None, 0)}
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;type&#34;, &#34;typm&#34;, &#34;gap&#34;, &#34;elf&#34;, &#34;mgf&#34;, &#34;trcle&#34;, &#34;trclm&#34;, &#34;filee&#34;, &#34;filem&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ_e&#34;, &#34;typ_m&#34;, &#34;calc_freq&#34;, &#34;e_normalization&#34;, &#34;m_normalization&#34;, &#34;e_transform&#34;, &#34;m_transform&#34;, &#34;e_file&#34;, &#34;m_file&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.MappedMagneticField"><code class="flex name class">
<span>class <span class="ident">MappedMagneticField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A non-uniform magnetic field in a region, affecting charged particles, given by a file.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>typ</code></td>
<td><code>None</code></td>
<td>One of the keys in {'xyz_list_charged': -1, 'rz_list_charged': -2, 'xyz_map_charged': -3, 'rz_map_charged': -4, 'xyz_list_neutron': -101, 'rz_list_neutron': -102, 'xyz_map_neutron': -103, 'rz_map_neutron': -104}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>normalization</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>2</td>
<td><code>calc_freq</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>3</td>
<td><code>m_file</code></td>
<td><code>None</code></td>
<td>A valid file name.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MappedMagneticField(PhitsObject):
    &#34;&#34;&#34;A non-uniform magnetic field in a region, affecting charged particles, given by a file.&#34;&#34;&#34;
    name = &#34;magnetic_field&#34;
    syntax = {&#34;typ&#34;: (None, FinBij({&#34;xyz_list_charged&#34;: -1, &#34;rz_list_charged&#34;: -2, &#34;xyz_map_charged&#34;: -3, &#34;rz_map_charged&#34;: -4,
                                    &#34;xyz_list_neutron&#34;: -101, &#34;rz_list_neutron&#34;: -102, &#34;xyz_map_neutron&#34;: -103, &#34;rz_map_neutron&#34;: -104}), 0),
              &#34;normalization&#34;: (None, Real(), 1),
              &#34;calc_freq&#34;: (None, PosReal(), 2),
              &#34;m_file&#34;: (None, Path(), 3),
              &#34;transform&#34;: (None, IsA(Transform, index=True), None, 0),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;&#39;typ&#34;, &#34;gap&#34;, &#34;mgf&#34;, &#34;trcl&#34;, &#34;file&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ&#34;, &#34;calc_freq&#34;, &#34;normalization&#34;, &#34;transform&#34;, &#34;m_file&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.MatNameColor"><code class="flex name class">
<span>class <span class="ident">MatNameColor</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a name and color of a material. Useful when <code><a title="pyphits.make_input" href="#pyphits.make_input">make_input()</a></code>ing to visualise geometries.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>mat_name</code></td>
<td><code>None</code></td>
<td>A string.</td>
</tr>
<tr>
<td>1</td>
<td><code>size</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>2</td>
<td><code>color</code></td>
<td><code>None</code></td>
<td>A color.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatNameColor(PhitsObject):
    &#34;&#34;&#34;Sets a name and color of a material. Useful when `make_input`ing to visualise geometries.&#34;&#34;&#34;
    name = &#34;mat_name_color&#34;
    syntax = {&#34;mat_name&#34;: (None, Text(), 0),
              &#34;size&#34;: (None, PosReal(), 1),
              &#34;color&#34;: (None, Color(), 2)} # TODO: color

    superobjects = [&#34;material&#34;]
    prelude = ((&#34;mat&#34;, &#34;name&#34;, &#34;&#39;size&#34;, &#34;&#39;color&#34;),)
    shape = ((&#34;material&#34;, &#34;mat_name&#34;, &#34;size&#34;, &#34;color&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.MatTimeChange"><code class="flex name class">
<span>class <span class="ident">MatTimeChange</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>At a certain time, change the material old to material new.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>time</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>1</td>
<td><code>new</code></td>
<td><code>None</code></td>
<td>An instance of Material.</td>
</tr>
<tr>
<td>2</td>
<td><code>old</code></td>
<td><code>None</code></td>
<td>An instance of Material.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatTimeChange(PhitsObject):
    &#34;&#34;&#34;At a certain time, change the material old to material new.&#34;&#34;&#34;
    name = &#34;mat_time_change&#34;
    syntax = {&#34;time&#34;: (None, PosReal(), 0),
              &#34;new&#34;: (None, IsA(Material, index=True), 1),
              &#34;old&#34;: (None, IsA(Material, index=True), 2)}
    prelude = ((&#34;mat&#34;, &#34;&#39;time&#34;, &#34;change&#34;),)
    shape = ((&#34;old&#34;, &#34;time&#34;, &#34;new&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Material"><code class="flex name class">
<span>class <span class="ident">Material</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up a material with which a <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code> will be filled, including all relevant nuclear information.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>composition</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is (a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208, int &gt; zero).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gas</code></td>
<td><code>GAS</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electron_step</code></td>
<td><code>ESTEP</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td><code>neutron_lib</code></td>
<td><code>NLIB</code></td>
<td>A library ID (one of ['50c', '20t', '21t', '22t', '23t', '24t', '25t', '26t', '27t', '28t', '29t', '50t', '50e', '51c', '51h', '90p']).</td>
</tr>
<tr>
<td><code>photon_lib</code></td>
<td><code>PLIB</code></td>
<td>A library ID (one of ['50c', '20t', '21t', '22t', '23t', '24t', '25t', '26t', '27t', '28t', '29t', '50t', '50e', '51c', '51h', '90p']).</td>
</tr>
<tr>
<td><code>electron_lib</code></td>
<td><code>ELIB</code></td>
<td>A library ID (one of ['50c', '20t', '21t', '22t', '23t', '24t', '25t', '26t', '27t', '28t', '29t', '50t', '50e', '51c', '51h', '90p']).</td>
</tr>
<tr>
<td><code>proton_lib</code></td>
<td><code>HLIB</code></td>
<td>A library ID (one of ['50c', '20t', '21t', '22t', '23t', '24t', '25t', '26t', '27t', '28t', '29t', '50t', '50e', '51c', '51h', '90p']).</td>
</tr>
<tr>
<td><code>conductor</code></td>
<td><code>COND</code></td>
<td>One of the keys in {False: -1, True: 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>thermal_lib</code></td>
<td><code>None</code></td>
<td>A material thermal neutron scattering law library identifier.</td>
</tr>
<tr>
<td><code>chemical</code></td>
<td><code>chem</code></td>
<td>A list of values, each of which is (one of the chemical symbols ['H20', 'CO2', 'NH2', 'NH3', 'SF6', 'TeF6', 'CH4', 'CH3', 'C2H2', 'C2H4', 'C2H6', 'C6H6', 'CH32N3'], int &gt; zero).</td>
</tr>
<tr>
<td><code>data_max</code></td>
<td><code>None</code></td>
<td>An instance of DataMax.</td>
</tr>
<tr>
<td><code>mat_name_color</code></td>
<td><code>None</code></td>
<td>An instance of MatNameColor.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Material(PhitsObject): # Composition is a list of pairs of (&lt;element name string&gt;, &lt;ratio&gt;) e.g. (&#34;8Li&#34;, 0.5)
    &#34;&#34;&#34;Sets up a material with which a `Cell` will be filled, including all relevant nuclear information.&#34;&#34;&#34;
    name = &#34;material&#34;
    syntax = {&#34;composition&#34;: (None, List(Tuple(JENDL4Nuclide(), PosInt()), unique_by=lambda x: kf_encode(x[0])), 0),
              &#34;gas&#34;: (&#34;GAS&#34;, Choice10(), None),
              &#34;electron_step&#34;: (&#34;ESTEP&#34;, PosInt(), None), # TODO: check integer right
              &#34;neutron_lib&#34;: (&#34;NLIB&#34;, LibraryID(), None),
              &#34;photon_lib&#34;: (&#34;PLIB&#34;, LibraryID(), None),
              &#34;electron_lib&#34;: (&#34;ELIB&#34;, LibraryID(), None),
              &#34;proton_lib&#34;: (&#34;HLIB&#34;, LibraryID(), None),
              &#34;conductor&#34;: (&#34;COND&#34;, FinBij({False: -1, True: 1}), None),
              &#34;thermal_lib&#34;: (None, ThermalLib(), None),
              &#34;chemical&#34;: (&#34;chem&#34;, List(Tuple(Chemical(), PosInt())), None),
              &#34;data_max&#34;: (None, IsA(DataMax, index=True), None),
              &#34;mat_name_color&#34;: (None, IsA(MatNameColor, index=True), None)
              }
    subobjects = [&#34;data_max&#34;, &#34;mat_time_change&#34;, &#34;mat_name_color&#34;]
    shape = lambda self: (f&#34;MAT[{self.index}]&#34;,
                          _decomposition(self.composition),
                          &#34;gas&#34;, &#34;electron_step&#34;, # &#34;neutron_lib&#34;, &#34;photon_lib&#34;, &#34;electron_lib&#34;, &#34;proton_lib&#34;,
                          &#34;conductor&#34;,
                          &#34;chem = &#34; + &#34; &#34;.join(ch + &#34; &#34; + str(den) for ch, den in self.chemical) \
                          if self.chemical is not None else &#34;&#34;,
                          f&#34;MT{self.index} &#34; + self.syntax[&#34;thermal_lib&#34;][1].phits(self.thermal_lib) \
                          if self.thermal_lib is not None else &#34;&#34;
                          )

    def restrictions(self):
        if any(map(lambda x: int(str(_tester.phits(x[0]))[:-3]) &gt; 92, self.composition)) and \
           (not hasattr(self, &#34;parameters&#34;) or not hasattr(self.parameters, &#34;stoping_model&#34;) or \
            &#34;ATIMA&#34; in self.parameters.stopping_model):
            raise ValueError(&#34;Material cannot have nuclei with Z &gt; 92 and ATIMA set at the same time;&#34;
                             &#34; please pass stopping_model=SPAR+NTMC to the material.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Material.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if any(map(lambda x: int(str(_tester.phits(x[0]))[:-3]) &gt; 92, self.composition)) and \
       (not hasattr(self, &#34;parameters&#34;) or not hasattr(self.parameters, &#34;stoping_model&#34;) or \
        &#34;ATIMA&#34; in self.parameters.stopping_model):
        raise ValueError(&#34;Material cannot have nuclei with Z &gt; 92 and ATIMA set at the same time;&#34;
                         &#34; please pass stopping_model=SPAR+NTMC to the material.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.NeutronMagneticField"><code class="flex name class">
<span>class <span class="ident">NeutronMagneticField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A uniform magnetic field in a region, affecting neutrons via spin.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>typ</code></td>
<td><code>None</code></td>
<td>One of the keys in {'identified': 60, 'nograv': 61, 'dipole': 102, 'quadrupole': 104, 'sextupole': 106}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>strength</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>calc_freq</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>polarization</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>time</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NeutronMagneticField(PhitsObject):
    &#34;&#34;&#34;A uniform magnetic field in a region, affecting neutrons via spin.&#34;&#34;&#34;
    name = &#34;magnetic_field&#34;
    syntax = {&#34;typ&#34;: (None, FinBij({&#34;identified&#34;: 60, &#34;nograv&#34;: 61, &#34;dipole&#34;: 102,
                                    &#34;quadrupole&#34;: 104, &#34;sextupole&#34;: 106}), 0),
              &#34;strength&#34;: (None, Real(), 1),
              &#34;calc_freq&#34;: (None, PosReal(), None, 0.0),
              &#34;polarization&#34;: (None, Real(), None, &#34;non&#34;),
              &#34;transform&#34;: (None, IsA(Transform, index=True), None, 0),
              &#34;time&#34;: (None, PosReal(), None, &#34;non&#34;),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;&#39;typ&#34;, &#34;&#39;gap&#34;, &#34;mgf&#34;, &#34;trcl&#34;, &#34;polar&#34;, &#34;&#39;time&#34;),)
    shape = ((&#34;cell&#34;, &#34;typ&#34;, &#34;calc_freq&#34;, &#34;strength&#34;, &#34;transform&#34;, &#34;polarization&#34;, &#34;time&#34;),)

    group_by = lambda self: type(self).__name__
    separator = lambda self: self.section_title()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.OuterVoid"><code class="flex name class">
<span>class <span class="ident">OuterVoid</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Void, but different for some reason. Probably shouldn't be used directly;
<code><a title="pyphits.run_phits" href="#pyphits.run_phits">run_phits()</a></code> creates the required OuterVoid for you automatically.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>regions</code></td>
<td><code>None</code></td>
<td>A recursive tuple of surfaces with set operation semantics: "~" negates what follows, infix "</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>magnetic_field</code></td>
<td><code>None</code></td>
<td>Either an instance of MagneticField, or an instance of NeutronMagneticField.</td>
</tr>
<tr>
<td><code>electromagnetic_field</code></td>
<td><code>None</code></td>
<td>Either , or an instance of ElectromagneticField.</td>
</tr>
<tr>
<td><code>delta_ray</code></td>
<td><code>None</code></td>
<td>An instance of DeltaRay.</td>
</tr>
<tr>
<td><code>track_structure</code></td>
<td><code>None</code></td>
<td>An instance of TrackStructure.</td>
</tr>
<tr>
<td><code>elastic_option</code></td>
<td><code>None</code></td>
<td>An instance of ElasticOption.</td>
</tr>
<tr>
<td><code>importance</code></td>
<td><code>None</code></td>
<td>An instance of Importance.</td>
</tr>
<tr>
<td><code>weight_window</code></td>
<td><code>None</code></td>
<td>An instance of WeightWindow.</td>
</tr>
<tr>
<td><code>ww_bias</code></td>
<td><code>None</code></td>
<td>An instance of WWBias.</td>
</tr>
<tr>
<td><code>forced_collisions</code></td>
<td><code>None</code></td>
<td>An instance of ForcedCollisions.</td>
</tr>
<tr>
<td><code>repeated_collisions</code></td>
<td><code>None</code></td>
<td>An instance of RepeatedCollisions.</td>
</tr>
<tr>
<td><code>reg_name</code></td>
<td><code>None</code></td>
<td>An instance of RegionName.</td>
</tr>
<tr>
<td><code>counter</code></td>
<td><code>None</code></td>
<td>An instance of Counter.</td>
</tr>
<tr>
<td><code>timer</code></td>
<td><code>None</code></td>
<td>An instance of Timer.</td>
</tr>
<tr>
<td><code>volume</code></td>
<td><code>VOL</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>temperature</code></td>
<td><code>TMP</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>TRCL</code></td>
<td>An instance of Transform.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OuterVoid(PhitsObject):
    &#34;&#34;&#34;Void, but different for some reason. Probably shouldn&#39;t be used directly;
    `run_phits` creates the required OuterVoid for you automatically.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, RegionTuple(_surface_spec), 0)}
    shape = lambda self: ((&#34;self&#34;, &#34;-1&#34;, &#34;regions&#34;, &#34;\\&#34;), &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;&#34;)
    subobjects = set(_subobject_syntax.keys())

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r
    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Parabolic"><code class="flex name class">
<span>class <span class="ident">Parabolic</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A parabolic source from every direction.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>width</code></td>
<td><code>('x1', 'y1')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>zbounds</code></td>
<td><code>('z0', 'z1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>rn</code></td>
<td>Integer between 2 and 2147483647.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parabolic(PhitsObject):
    &#34;&#34;&#34;A parabolic source from every direction.&#34;&#34;&#34;
    name = &#34;source&#34;

    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;width&#34;: ((&#34;x1&#34;, &#34;y1&#34;), (PosReal(), PosReal()), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                       &#34;order&#34;: (&#34;rn&#34;, Between(2, 2147483647), None) # PHITS&#39;s default INTEGER is 32-bit; if something&#39;s bigger,
                                                                     # their  0 (mod 2) check of multiplying and dividing by 2 fails.
                       } | _source_semi_common
    shape = lambda self: (&#34;s-type = 7&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;width&#34;, &#34;zbounds&#34;, &#34;order&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if self.order is not None and self.order % 2 != 0:
            raise ValueError(f&#34;The order of a Parabolic source must be even; got order={self.order}.&#34;) # TODO: needed?
        if self.zbounds is not None and self.zbounds[0] &gt; self.zbounds[1]:
            raise ValueError(f&#34;The the zbounds of a Parabolic source must be a well-formed interval; got zbounds={self.zbounds}.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Parabolic.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.order is not None and self.order % 2 != 0:
        raise ValueError(f&#34;The order of a Parabolic source must be even; got order={self.order}.&#34;) # TODO: needed?
    if self.zbounds is not None and self.zbounds[0] &gt; self.zbounds[1]:
        raise ValueError(f&#34;The the zbounds of a Parabolic source must be a well-formed interval; got zbounds={self.zbounds}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.ParabolicSlices"><code class="flex name class">
<span>class <span class="ident">ParabolicSlices</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A parabolic source, uniform along the (z)-axis.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>width</code></td>
<td><code>r1</code></td>
<td>Float.</td>
</tr>
<tr>
<td><code>zbounds</code></td>
<td><code>('z0', 'z1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>rn</code></td>
<td>Integer between 2 and 2147483647.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParabolicSlices(PhitsObject):
    &#34;&#34;&#34;A parabolic source, uniform along the \\(z\\)-axis.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;), (Real(), Real()), None),
                       &#34;width&#34;: (&#34;r1&#34;, Real(), None),
                       &#34;zbounds&#34;: ((&#34;z0&#34;, &#34;z1&#34;), (Real(), Real()), None),
                       &#34;order&#34;: (&#34;rn&#34;, Between(2, 2147483647), None)
                       } | _source_semi_common
    shape = lambda self: (&#34;s-type = 15&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;width&#34;, &#34;zbounds&#34;, &#34;order&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if self.order is not None and self.order % 2 != 0:
            raise ValueError(f&#34;The order of a ParabolicPrism source must be even; got order={self.order}.&#34;) # TODO: needed?
        if self.zbounds is not None and self.zbounds[0] &gt; self.zbounds[1]:
            raise ValueError(f&#34;The the zbounds of a ParabolicPrism source must be a well-formed interval; got zbounds={self.zbounds}.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.ParabolicSlices.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.order is not None and self.order % 2 != 0:
        raise ValueError(f&#34;The order of a ParabolicPrism source must be even; got order={self.order}.&#34;) # TODO: needed?
    if self.zbounds is not None and self.zbounds[0] &gt; self.zbounds[1]:
        raise ValueError(f&#34;The the zbounds of a ParabolicPrism source must be a well-formed interval; got zbounds={self.zbounds}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.ParallelPlane"><code class="flex name class">
<span>class <span class="ident">ParallelPlane</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A plane of the form x_i = D.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>parallel</code></td>
<td><code>None</code></td>
<td>One of the keys in {'x': 'X', 'y': 'Y', 'z': 'Z'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>D</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParallelPlane(PhitsObject):
    &#34;&#34;&#34;A plane of the form x_i = D.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;parallel&#34;: (None, FinBij({&#34;x&#34;: &#34;X&#34;, &#34;y&#34;: &#34;Y&#34;, &#34;z&#34;:&#34;Z&#34;}), 0),
                       &#34;D&#34;: (None, Real(), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, f&#34;P{self.parallel}&#34;, &#34;D&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Parameters"><code class="flex name class">
<span>class <span class="ident">Parameters</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A "dictionary with an attitude" representing an entry in the [Parameters] section of an input file.
Any extra keyword arguments to any constructors are minted into parameter objects.</p>
<pre><code>&gt;&gt;&gt; print(Parameters(ndedx=2, dbcutoff=3.3).definition())
ndedx = 2
dbcutoff = 3.3
</code></pre>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>control</code></td>
<td><code>icntl</code></td>
<td>One of the keys in {'normal': 0, 'output_cross-section': 1, 'output_echo_only': 3, 'all_reg_void': 5, 'source_check': 6, 'show_geometry': 7, 'show_geometry_with_xyz': 8, 'show_regions': 9, 'show_regions_with_tally': 10, 'show_3d_geometry': 11, 'use_dumpall': 12, 'sum_tally': 13, 'auto_volume': 14, 'ww_bias_tally': 15, 'analysis_script': 16, 'anatally': 17}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>max_histories</code></td>
<td><code>maxcas</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td><code>max_batches</code></td>
<td><code>maxbch</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td><code>nuclear_memory_rescale</code></td>
<td><code>xsmemory</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td><code>timeout</code></td>
<td>Either None or a number.</td>
</tr>
<tr>
<td><code>stdev_control</code></td>
<td><code>istdev</code></td>
<td>One of the keys in {'history_restart': -2, 'batch_restart': -1, 'normal': 0, 'batch': 1, 'history': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>share_tallies</code></td>
<td><code>italsh</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>check_consistency</code></td>
<td><code>ireschk</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>xor_prng</code></td>
<td><code>nrandgen</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>random_seed</code></td>
<td><code>rseed</code></td>
<td>Float.</td>
</tr>
<tr>
<td><code>seed_from_time</code></td>
<td><code>itimrand</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>proton_e_cutoff</code></td>
<td><code>emin(1)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_e_cutoff</code></td>
<td><code>emin(2)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionp_e_cutoff</code></td>
<td><code>emin(3)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pion0_e_cutoff</code></td>
<td><code>emin(4)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionm_e_cutoff</code></td>
<td><code>emin(5)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonp_e_cutoff</code></td>
<td><code>emin(6)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonm_e_cutoff</code></td>
<td><code>emin(7)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonp_e_cutoff</code></td>
<td><code>emin(8)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaon0_e_cutoff</code></td>
<td><code>emin(9)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonm_e_cutoff</code></td>
<td><code>emin(10)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>other_e_cutoff</code></td>
<td><code>emin(11)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_e_cutoff</code></td>
<td><code>emin(12)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>positron_e_cutoff</code></td>
<td><code>emin(13)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_e_cutoff</code></td>
<td><code>emin(14)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>deuteron_e_cutoff</code></td>
<td><code>emin(15)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>triton_e_cutoff</code></td>
<td><code>emin(16)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he3_e_cutoff</code></td>
<td><code>emin(17)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he4_e_cutoff</code></td>
<td><code>emin(18)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>nucleon_e_cutoff</code></td>
<td><code>emin(19)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>proton_e_max</code></td>
<td><code>dmax(1)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_e_max</code></td>
<td><code>dmax(2)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_e_max</code></td>
<td><code>dmax(12)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>positron_e_max</code></td>
<td><code>dmax(13)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_e_max</code></td>
<td><code>dmax(14)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>deuteron_e_max</code></td>
<td><code>dmax(15)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he4_e_max</code></td>
<td><code>dmax(18)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>proton_react_cutoff</code></td>
<td><code>cmin(1)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_react_cutoff</code></td>
<td><code>cmin(2)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionp_react_cutoff</code></td>
<td><code>cmin(3)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pion0_react_cutoff</code></td>
<td><code>cmin(4)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionm_react_cutoff</code></td>
<td><code>cmin(5)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonp_react_cutoff</code></td>
<td><code>cmin(6)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonm_react_cutoff</code></td>
<td><code>cmin(7)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonp_react_cutoff</code></td>
<td><code>cmin(8)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaon0_react_cutoff</code></td>
<td><code>cmin(9)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonm_react_cutoff</code></td>
<td><code>cmin(10)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>other_react_cutoff</code></td>
<td><code>cmin(11)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_react_cutoff</code></td>
<td><code>cmin(12)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>positron_react_cutoff</code></td>
<td><code>cmin(13)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_react_cutoff</code></td>
<td><code>cmin(14)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>deuteron_react_cutoff</code></td>
<td><code>cmin(15)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>triton_react_cutoff</code></td>
<td><code>cmin(16)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he3_react_cutoff</code></td>
<td><code>cmin(17)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he4_react_cutoff</code></td>
<td><code>cmin(18)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>nucleon_react_cutoff</code></td>
<td><code>cmin(19)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charged_e_min</code></td>
<td><code>esmin</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charged_e_max</code></td>
<td><code>esmax</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_positron_track_structure_e_min</code></td>
<td><code>etsmin</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_positron_track_structure_e_max</code></td>
<td><code>etsmax</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>nucleon_track_structure_e_max</code></td>
<td><code>tsmax</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electric_transport_type</code></td>
<td><code>negs</code></td>
<td>One of the keys in {'PHITS': -1, 'ignore': 0, 'EGS5': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>automatic_e_bounds</code></td>
<td><code>nucdata</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electron_positron_adjust_weight_over_e_max</code></td>
<td><code>ieleh</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>nucleon_nucleus_model_switch_e</code></td>
<td><code>ejamnu</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pion_nucleus_model_switch_e</code></td>
<td><code>ejampi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>isobar_max_e</code></td>
<td><code>eisobar</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>isobar_model</code></td>
<td><code>isobar</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>bertini_jqmd_switch_e</code></td>
<td><code>eqmdnu</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>jqmd_e_min</code></td>
<td><code>eqmdmin</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>jqmd_jamqmd_switch_e</code></td>
<td><code>ejamqmd</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>incl_control</code></td>
<td><code>inclg</code></td>
<td>One of the keys in {None: 0, 'all': 1, 'no_He': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>icnl_e_min</code></td>
<td><code>einclmin</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>icnl_e_max</code></td>
<td><code>einclmax</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>inc_elf_control</code></td>
<td><code>incelf</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>icnl_elf_e_min</code></td>
<td><code>eielfmin</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>icnl_elf_e_max</code></td>
<td><code>eielfmax</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>jqmd_2</code></td>
<td><code>irqmd</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>scinful_qmd</code></td>
<td><code>iscinful</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>kerma_mode</code></td>
<td><code>kerma</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>pseudo_reaction_e</code></td>
<td><code>epseudo</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>proton_time_cutoff</code></td>
<td><code>tmax(1)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_time_cutoff</code></td>
<td><code>tmax(2)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionp_time_cutoff</code></td>
<td><code>tmax(3)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pion0_time_cutoff</code></td>
<td><code>tmax(4)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionm_time_cutoff</code></td>
<td><code>tmax(5)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonp_time_cutoff</code></td>
<td><code>tmax(6)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonm_time_cutoff</code></td>
<td><code>tmax(7)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonp_time_cutoff</code></td>
<td><code>tmax(8)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaon0_time_cutoff</code></td>
<td><code>tmax(9)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonm_time_cutoff</code></td>
<td><code>tmax(10)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>other_time_cutoff</code></td>
<td><code>tmax(11)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_time_cutoff</code></td>
<td><code>tmax(12)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>positron_time_cutoff</code></td>
<td><code>tmax(13)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_time_cutoff</code></td>
<td><code>tmax(14)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>deuteron_time_cutoff</code></td>
<td><code>tmax(15)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>triton_time_cutoff</code></td>
<td><code>tmax(16)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he3_time_cutoff</code></td>
<td><code>tmax(17)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he4_time_cutoff</code></td>
<td><code>tmax(18)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>nucleon_time_cutoff</code></td>
<td><code>tmax(19)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>proton_weight_min</code></td>
<td><code>wc1(1)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_weight_min</code></td>
<td><code>wc1(2)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionp_weight_min</code></td>
<td><code>wc1(3)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pion0_weight_min</code></td>
<td><code>wc1(4)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionm_weight_min</code></td>
<td><code>wc1(5)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonp_weight_min</code></td>
<td><code>wc1(6)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonm_weight_min</code></td>
<td><code>wc1(7)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonp_weight_min</code></td>
<td><code>wc1(8)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaon0_weight_min</code></td>
<td><code>wc1(9)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonm_weight_min</code></td>
<td><code>wc1(10)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>other_weight_min</code></td>
<td><code>wc1(11)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_weight_min</code></td>
<td><code>wc1(12)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>positron_weight_min</code></td>
<td><code>wc1(13)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_weight_min</code></td>
<td><code>wc1(14)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>deuteron_weight_min</code></td>
<td><code>wc1(15)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>triton_weight_min</code></td>
<td><code>wc1(16)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he3_weight_min</code></td>
<td><code>wc1(17)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he4_weight_min</code></td>
<td><code>wc1(18)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>nucleon_weight_min</code></td>
<td><code>wc1(19)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>proton_weight_cutoff</code></td>
<td><code>wc2(1)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_weight_cutoff</code></td>
<td><code>wc2(2)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionp_weight_cutoff</code></td>
<td><code>wc2(3)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pion0_weight_cutoff</code></td>
<td><code>wc2(4)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>pionm_weight_cutoff</code></td>
<td><code>wc2(5)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonp_weight_cutoff</code></td>
<td><code>wc2(6)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muonm_weight_cutoff</code></td>
<td><code>wc2(7)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonp_weight_cutoff</code></td>
<td><code>wc2(8)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaon0_weight_cutoff</code></td>
<td><code>wc2(9)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>kaonm_weight_cutoff</code></td>
<td><code>wc2(10)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>other_weight_cutoff</code></td>
<td><code>wc2(11)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>electron_weight_cutoff</code></td>
<td><code>wc2(12)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>positron_weight_cutoff</code></td>
<td><code>wc2(13)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_weight_cutoff</code></td>
<td><code>wc2(14)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>deuteron_weight_cutoff</code></td>
<td><code>wc2(15)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>triton_weight_cutoff</code></td>
<td><code>wc2(16)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he3_weight_cutoff</code></td>
<td><code>wc2(17)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>he4_weight_cutoff</code></td>
<td><code>wc2(18)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>nucleon_weight_cutoff</code></td>
<td><code>wc2(19)</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>weight_window_max</code></td>
<td><code>wupn</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>survival_weight</code></td>
<td><code>wsurvn</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>ww_bias</code></td>
<td><code>iwwbias</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>std_cutoff</code></td>
<td><code>istdcut</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>stopping_model</code></td>
<td><code>ndedx</code></td>
<td>One of the keys in {'SPAR_nucleus_only+NTMC': 0, 'ATIMA+NTMC': 1, 'SPAR+NTMC': 2, 'ATIMA': 3}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>atima_db_max</code></td>
<td><code>mdbatima</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td><code>atima_e_cutoff</code></td>
<td><code>dbcutoff</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>atima_water_ion_e</code></td>
<td><code>ih2o</code></td>
<td>Either None or a number.</td>
</tr>
<tr>
<td><code>atima_effective_charge</code></td>
<td><code>ifixchg</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>restricted_delta_LET</code></td>
<td><code>irlet</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>elastic_scattering</code></td>
<td><code>ielas</code></td>
<td>One of the keys in {None: 0, 'neutron': 1, 'both': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>elastic_angle_groups</code></td>
<td><code>ielms</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td><code>nucleon_model</code></td>
<td><code>icxnp</code></td>
<td>One of the keys in {'JAM': 0, 'JENDL': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>nucleon_nucleus_model</code></td>
<td><code>icxsni</code></td>
<td>One of the keys in {'Perlstein-Niita': 0, 'KUROTAMA': 1, 'Sato': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>nucleus_nucleus_model</code></td>
<td><code>icrhi</code></td>
<td>One of the keys in {'Shen': 0, 'NASA': 1, 'KUROTAMA': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>deuteron_model</code></td>
<td><code>icrdm</code></td>
<td>One of the keys in {'nuclear': 0, 'MWO': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>pion_induced_model</code></td>
<td><code>icxspi</code></td>
<td>One of the keys in {'geometrical': 0, 'Hashimoto': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>evap_model</code></td>
<td><code>nevap</code></td>
<td>One of the keys in {None: 0, 'GEM': 3}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>gem_version</code></td>
<td><code>ngem</code></td>
<td>One of the keys in {1: 1, 2: 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>fission_model</code></td>
<td><code>ifission</code></td>
<td>One of the keys in {'PHITS': 1, 'Iwamoto': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>gamma_decay_model</code></td>
<td><code>igamma</code></td>
<td>One of the keys in {None: 0, 'PHITS': 1, 'EBITEM': 2, 'EBITEM isomer': 3, 'PHITS no Doppler': -1, 'EBITEM no Doppler': -3}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>statistical_multifrag_model</code></td>
<td><code>ismm</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>event_generator</code></td>
<td><code>e-mode</code></td>
<td>One of the keys in {None: 0, 'simple': 1, 'complicated': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>event_generator_max_e</code></td>
<td><code>em-emode</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutron_kerma</code></td>
<td><code>ikerman</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>photon_kerma</code></td>
<td><code>ikermap</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>photon_adjoint</code></td>
<td><code>iadjoint</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>bertini_nucleon_cross_section</code></td>
<td><code>inmed</code></td>
<td>One of the keys in {'free': 0, 'cugnon_old': 1, 'cugnon_new': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>bertini_angular_distribution</code></td>
<td><code>andit</code></td>
<td>One of the keys in {'split': 0, 'isotropic': 1, 'forward': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>experimental_neutron_fission</code></td>
<td><code>iidfs</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>discrete_dwba_spectra</code></td>
<td><code>idwba</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>neutron_capture_cutoff</code></td>
<td><code>emcnf</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>fission_delayed_neutrons</code></td>
<td><code>dnb</code></td>
<td>Either one of the keys in {'natural': -1, None: 0}, with the value being the corresponding PHITS value, or float &gt; 0.</td>
</tr>
<tr>
<td><code>fission_neutron_production</code></td>
<td><code>nonu</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>s_matrix_interpolation</code></td>
<td><code>isaba</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>detailed_photon_cutoff</code></td>
<td><code>emcpf</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_coherent_scatter</code></td>
<td><code>nocoh</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>simple_brem</code></td>
<td><code>ibad</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>brem_photon_count</code></td>
<td><code>bnum</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>xray_photon_count</code></td>
<td><code>xnum</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>substep_brem</code></td>
<td><code>numb</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>multiple_scattering</code></td>
<td><code>imsegs</code></td>
<td>One of the keys in {'PHITS-EGS5': 1, 'EGS5': 0}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>egs_rand_seed</code></td>
<td><code>iegsrand</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>edge_photons</code></td>
<td><code>iedgfl</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>edge_auger_electrons</code></td>
<td><code>iauger</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>coherent_reyleigh_scattering</code></td>
<td><code>iraylr</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>egs_material_size</code></td>
<td><code>chard</code></td>
<td>Float.</td>
</tr>
<tr>
<td><code>icru90_corrections</code></td>
<td><code>epstfl</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>densest_gas</code></td>
<td><code>gasegs</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>compton_incoherent_scattering</code></td>
<td><code>incohr</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>compton_doppler_broadening</code></td>
<td><code>iprofr</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electron_impact_ionization</code></td>
<td><code>impacr</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electron_impact_xray_split</code></td>
<td><code>ieispl</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electron_impact_xray_count</code></td>
<td><code>neispl</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td><code>brem_sample_polar_angle</code></td>
<td><code>ibrdst</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electron_pair_sample_polar_angle</code></td>
<td><code>iprdst</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>photoelectron_sample_angle</code></td>
<td><code>iphter</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>compton_bound_cross_section</code></td>
<td><code>ibound</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>brem_cross_section_correction</code></td>
<td><code>iaprim</code></td>
<td>One of the keys in {None: 2, 'modeled': 1, 'empirical': 0}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>photonuclear_reactions</code></td>
<td><code>ipnint</code></td>
<td>One of the keys in {None: 0, 'no_flourescence': 1, 'all': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>photonuclear_probability_weight</code></td>
<td><code>pnimul</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>photon_induced_muon_production</code></td>
<td><code>igmuppd</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>muon_capture</code></td>
<td><code>imucap</code></td>
<td>One of the keys in {False: 0, True: 1, 'custom_xray': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>muon_induced_reactions</code></td>
<td><code>imuint</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>muon_induced_brem</code></td>
<td><code>imubrm</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>muon_induced_pairs</code></td>
<td><code>imuppd</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>muon_induced_reaction_min</code></td>
<td><code>emumin</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>muon_induced_reaction_max</code></td>
<td><code>emumax</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>neutrino_induced_reaction</code></td>
<td><code>ntrnore</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>angle_straggling</code></td>
<td><code>nspred</code></td>
<td>One of the keys in {'Lynch': 2, 'NTMCC': 1, None: 0}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>lynch_params</code></td>
<td><code>('ascat1', 'ascat2')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>energy_straggling</code></td>
<td><code>nedisp</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>gravity</code></td>
<td><code>('gravx', 'gravy', 'gravz')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>magnetic_field</code></td>
<td><code>imagnf</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>electromagnetic_field</code></td>
<td><code>ielctf</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parameters():
    &#34;&#34;&#34;A &#34;dictionary with an attitude&#34; representing an entry in the [Parameters] section of an input file.
    Any extra keyword arguments to any constructors are minted into parameter objects.


    &gt;&gt;&gt; print(Parameters(ndedx=2, dbcutoff=3.3).definition())
    ndedx = 2
    dbcutoff = 3.3
    &#34;&#34;&#34;
    name = &#34;parameters&#34;
    syntax = {&#34;control&#34;: (&#34;icntl&#34;, FinBij({&#34;normal&#34;: 0, &#34;output_cross-section&#34;: 1, &#34;output_echo_only&#34;: 3, &#34;all_reg_void&#34;: 5,
                                           &#34;source_check&#34;: 6, &#34;show_geometry&#34;: 7, &#34;show_geometry_with_xyz&#34;: 8, &#34;show_regions&#34;: 9,
                                           &#34;show_regions_with_tally&#34;: 10, &#34;show_3d_geometry&#34;: 11, &#34;use_dumpall&#34;: 12, &#34;sum_tally&#34;: 13,
                                           &#34;auto_volume&#34;: 14, &#34;ww_bias_tally&#34;: 15, &#34;analysis_script&#34;: 16, &#34;anatally&#34;: 17}), None),
              &#34;max_histories&#34;: (&#34;maxcas&#34;, PosInt(), None),
              &#34;max_batches&#34;: (&#34;maxbch&#34;, PosInt(), None),
              &#34;nuclear_memory_rescale&#34;: (&#34;xsmemory&#34;, PosReal(), None),
              &#34;timeout&#34;: (&#34;timeout&#34;, NegDisable(), None),
              &#34;stdev_control&#34;: (&#34;istdev&#34;, FinBij({&#34;history_restart&#34;: -2, &#34;batch_restart&#34;: -1, &#34;normal&#34;: 0, &#34;batch&#34;: 1, &#34;history&#34;: 2}), None),
              &#34;share_tallies&#34;: (&#34;italsh&#34;, Choice10(), None),
              &#34;check_consistency&#34;: (&#34;ireschk&#34;, Choice10(c_style=True), None),
              &#34;xor_prng&#34;: (&#34;nrandgen&#34;, Choice10(), None),
              # &#34;seed_skip&#34;: (&#34;irskeep&#34;, Integer(), None),
              &#34;random_seed&#34;: (&#34;rseed&#34;, Real(), None),
              &#34;seed_from_time&#34;: (&#34;itimrand&#34;, Choice10(), None),
              # bitrseed?,

              &#34;proton_e_cutoff&#34;: (&#34;emin(1)&#34;, PosReal(), None),
              &#34;neutron_e_cutoff&#34;: (&#34;emin(2)&#34;, PosReal(), None),
              &#34;pionp_e_cutoff&#34;: (&#34;emin(3)&#34;, PosReal(), None),
              &#34;pion0_e_cutoff&#34;: (&#34;emin(4)&#34;, PosReal(), None),
              &#34;pionm_e_cutoff&#34;: (&#34;emin(5)&#34;, PosReal(), None),
              &#34;muonp_e_cutoff&#34;: (&#34;emin(6)&#34;, PosReal(), None),
              &#34;muonm_e_cutoff&#34;: (&#34;emin(7)&#34;, PosReal(), None),
              &#34;kaonp_e_cutoff&#34;: (&#34;emin(8)&#34;, PosReal(), None),
              &#34;kaon0_e_cutoff&#34;: (&#34;emin(9)&#34;, PosReal(), None),
              &#34;kaonm_e_cutoff&#34;: (&#34;emin(10)&#34;, PosReal(), None),
              &#34;other_e_cutoff&#34;: (&#34;emin(11)&#34;, PosReal(), None),
              &#34;electron_e_cutoff&#34;: (&#34;emin(12)&#34;, PosReal(), None),
              &#34;positron_e_cutoff&#34;: (&#34;emin(13)&#34;, PosReal(), None),
              &#34;photon_e_cutoff&#34;: (&#34;emin(14)&#34;, PosReal(), None),
              &#34;deuteron_e_cutoff&#34;: (&#34;emin(15)&#34;, PosReal(), None),
              &#34;triton_e_cutoff&#34;: (&#34;emin(16)&#34;, PosReal(), None),
              &#34;he3_e_cutoff&#34;: (&#34;emin(17)&#34;, PosReal(), None),
              &#34;he4_e_cutoff&#34;: (&#34;emin(18)&#34;, PosReal(), None),
              &#34;nucleon_e_cutoff&#34;: (&#34;emin(19)&#34;, PosReal(), None),
              &#34;proton_e_max&#34;: (&#34;dmax(1)&#34;, PosReal(), None),
              &#34;neutron_e_max&#34;: (&#34;dmax(2)&#34;, PosReal(), None),
              &#34;electron_e_max&#34;: (&#34;dmax(12)&#34;, PosReal(), None),
              &#34;positron_e_max&#34;: (&#34;dmax(13)&#34;, PosReal(), None),
              &#34;photon_e_max&#34;: (&#34;dmax(14)&#34;, PosReal(), None),
              &#34;deuteron_e_max&#34;: (&#34;dmax(15)&#34;, PosReal(), None),
              &#34;he4_e_max&#34;: (&#34;dmax(18)&#34;, PosReal(), None),
              # &#34;photonuclear_e_max&#34;: (&#34;dpnmax&#34;, PosReal(), None),
              # lib(i)??
                  &#34;proton_react_cutoff&#34;: (&#34;cmin(1)&#34;, PosReal(), None),
              &#34;neutron_react_cutoff&#34;: (&#34;cmin(2)&#34;, PosReal(), None),
              &#34;pionp_react_cutoff&#34;: (&#34;cmin(3)&#34;, PosReal(), None),
              &#34;pion0_react_cutoff&#34;: (&#34;cmin(4)&#34;, PosReal(), None),
              &#34;pionm_react_cutoff&#34;: (&#34;cmin(5)&#34;, PosReal(), None),
              &#34;muonp_react_cutoff&#34;: (&#34;cmin(6)&#34;, PosReal(), None),
              &#34;muonm_react_cutoff&#34;: (&#34;cmin(7)&#34;, PosReal(), None),
              &#34;kaonp_react_cutoff&#34;: (&#34;cmin(8)&#34;, PosReal(), None),
              &#34;kaon0_react_cutoff&#34;: (&#34;cmin(9)&#34;, PosReal(), None),
              &#34;kaonm_react_cutoff&#34;: (&#34;cmin(10)&#34;, PosReal(), None),
              &#34;other_react_cutoff&#34;: (&#34;cmin(11)&#34;, PosReal(), None),
              &#34;electron_react_cutoff&#34;: (&#34;cmin(12)&#34;, PosReal(), None),
              &#34;positron_react_cutoff&#34;: (&#34;cmin(13)&#34;, PosReal(), None),
              &#34;photon_react_cutoff&#34;: (&#34;cmin(14)&#34;, PosReal(), None),
              &#34;deuteron_react_cutoff&#34;: (&#34;cmin(15)&#34;, PosReal(), None),
              &#34;triton_react_cutoff&#34;: (&#34;cmin(16)&#34;, PosReal(), None),
              &#34;he3_react_cutoff&#34;: (&#34;cmin(17)&#34;, PosReal(), None),
              &#34;he4_react_cutoff&#34;: (&#34;cmin(18)&#34;, PosReal(), None),
              &#34;nucleon_react_cutoff&#34;: (&#34;cmin(19)&#34;, PosReal(), None),
              &#34;charged_e_min&#34;: (&#34;esmin&#34;, PosReal(), None),
              &#34;charged_e_max&#34;: (&#34;esmax&#34;, PosReal(), None),
              &#34;electron_positron_track_structure_e_min&#34;: (&#34;etsmin&#34;, PosReal(), None),
              &#34;electron_positron_track_structure_e_max&#34;: (&#34;etsmax&#34;, PosReal(), None),
              &#34;nucleon_track_structure_e_max&#34;: (&#34;tsmax&#34;, PosReal(), None),
              &#34;electric_transport_type&#34;: (&#34;negs&#34;, FinBij({&#34;PHITS&#34;: -1, &#34;ignore&#34;: 0, &#34;EGS5&#34;: 1}), None),
              &#34;automatic_e_bounds&#34;: (&#34;nucdata&#34;, Choice10(), None),
              &#34;electron_positron_adjust_weight_over_e_max&#34;: (&#34;ieleh&#34;, Choice10(), None),
              &#34;nucleon_nucleus_model_switch_e&#34;: (&#34;ejamnu&#34;, PosReal(), None),
              &#34;pion_nucleus_model_switch_e&#34;: (&#34;ejampi&#34;, PosReal(), None),
              &#34;isobar_max_e&#34;: (&#34;eisobar&#34;, PosReal(), None),
              &#34;isobar_model&#34;: (&#34;isobar&#34;, Choice10(), None),
              &#34;bertini_jqmd_switch_e&#34;: (&#34;eqmdnu&#34;, PosReal(), None),
              &#34;jqmd_e_min&#34;: (&#34;eqmdmin&#34;, PosReal(), None),
              &#34;jqmd_jamqmd_switch_e&#34;: (&#34;ejamqmd&#34;, PosReal(), None),
              &#34;incl_control&#34;:  (&#34;inclg&#34;, FinBij({None: 0, &#34;all&#34;: 1, &#34;no_He&#34;: 2}), None),
              &#34;icnl_e_min&#34;: (&#34;einclmin&#34;, PosReal(), None),
              &#34;icnl_e_max&#34;: (&#34;einclmax&#34;, PosReal(), None),
              &#34;inc_elf_control&#34;: (&#34;incelf&#34;, Choice10(), None),
              &#34;icnl_elf_e_min&#34;: (&#34;eielfmin&#34;, PosReal(), None),
              &#34;icnl_elf_e_max&#34;: (&#34;eielfmax&#34;, PosReal(), None),
              &#34;jqmd_2&#34;: (&#34;irqmd&#34;, Choice10(), None),
              &#34;scinful_qmd&#34;: (&#34;iscinful&#34;, Choice10(), None),
              &#34;kerma_mode&#34;: (&#34;kerma&#34;, Choice10(), None),
              &#34;pseudo_reaction_e&#34;: (&#34;epseudo&#34;, PosReal(), None),
              &#34;proton_time_cutoff&#34;: (&#34;tmax(1)&#34;, PosReal(), None),
              &#34;neutron_time_cutoff&#34;: (&#34;tmax(2)&#34;, PosReal(), None),
              &#34;pionp_time_cutoff&#34;: (&#34;tmax(3)&#34;, PosReal(), None),
              &#34;pion0_time_cutoff&#34;: (&#34;tmax(4)&#34;, PosReal(), None),
              &#34;pionm_time_cutoff&#34;: (&#34;tmax(5)&#34;, PosReal(), None),
              &#34;muonp_time_cutoff&#34;: (&#34;tmax(6)&#34;, PosReal(), None),
              &#34;muonm_time_cutoff&#34;: (&#34;tmax(7)&#34;, PosReal(), None),
              &#34;kaonp_time_cutoff&#34;: (&#34;tmax(8)&#34;, PosReal(), None),
              &#34;kaon0_time_cutoff&#34;: (&#34;tmax(9)&#34;, PosReal(), None),
              &#34;kaonm_time_cutoff&#34;: (&#34;tmax(10)&#34;, PosReal(), None),
              &#34;other_time_cutoff&#34;: (&#34;tmax(11)&#34;, PosReal(), None),
              &#34;electron_time_cutoff&#34;: (&#34;tmax(12)&#34;, PosReal(), None),
              &#34;positron_time_cutoff&#34;: (&#34;tmax(13)&#34;, PosReal(), None),
              &#34;photon_time_cutoff&#34;: (&#34;tmax(14)&#34;, PosReal(), None),
              &#34;deuteron_time_cutoff&#34;: (&#34;tmax(15)&#34;, PosReal(), None),
              &#34;triton_time_cutoff&#34;: (&#34;tmax(16)&#34;, PosReal(), None),
              &#34;he3_time_cutoff&#34;: (&#34;tmax(17)&#34;, PosReal(), None),
              &#34;he4_time_cutoff&#34;: (&#34;tmax(18)&#34;, PosReal(), None),
              &#34;nucleon_time_cutoff&#34;: (&#34;tmax(19)&#34;, PosReal(), None),
              &#34;proton_weight_min&#34;: (&#34;wc1(1)&#34;, PosReal(), None),
              &#34;neutron_weight_min&#34;: (&#34;wc1(2)&#34;, PosReal(), None),
              &#34;pionp_weight_min&#34;: (&#34;wc1(3)&#34;, PosReal(), None),
              &#34;pion0_weight_min&#34;: (&#34;wc1(4)&#34;, PosReal(), None),
              &#34;pionm_weight_min&#34;: (&#34;wc1(5)&#34;, PosReal(), None),
              &#34;muonp_weight_min&#34;: (&#34;wc1(6)&#34;, PosReal(), None),
              &#34;muonm_weight_min&#34;: (&#34;wc1(7)&#34;, PosReal(), None),
              &#34;kaonp_weight_min&#34;: (&#34;wc1(8)&#34;, PosReal(), None),
              &#34;kaon0_weight_min&#34;: (&#34;wc1(9)&#34;, PosReal(), None),
              &#34;kaonm_weight_min&#34;: (&#34;wc1(10)&#34;, PosReal(), None),
              &#34;other_weight_min&#34;: (&#34;wc1(11)&#34;, PosReal(), None),
              &#34;electron_weight_min&#34;: (&#34;wc1(12)&#34;, PosReal(), None),
              &#34;positron_weight_min&#34;: (&#34;wc1(13)&#34;, PosReal(), None),
              &#34;photon_weight_min&#34;: (&#34;wc1(14)&#34;, PosReal(), None),
              &#34;deuteron_weight_min&#34;: (&#34;wc1(15)&#34;, PosReal(), None),
              &#34;triton_weight_min&#34;: (&#34;wc1(16)&#34;, PosReal(), None),
              &#34;he3_weight_min&#34;: (&#34;wc1(17)&#34;, PosReal(), None),
              &#34;he4_weight_min&#34;: (&#34;wc1(18)&#34;, PosReal(), None),
              &#34;nucleon_weight_min&#34;: (&#34;wc1(19)&#34;, PosReal(), None),
              &#34;proton_weight_cutoff&#34;: (&#34;wc2(1)&#34;, PosReal(), None),
              &#34;neutron_weight_cutoff&#34;: (&#34;wc2(2)&#34;, PosReal(), None),
              &#34;pionp_weight_cutoff&#34;: (&#34;wc2(3)&#34;, PosReal(), None),
              &#34;pion0_weight_cutoff&#34;: (&#34;wc2(4)&#34;, PosReal(), None),
              &#34;pionm_weight_cutoff&#34;: (&#34;wc2(5)&#34;, PosReal(), None),
              &#34;muonp_weight_cutoff&#34;: (&#34;wc2(6)&#34;, PosReal(), None),
              &#34;muonm_weight_cutoff&#34;: (&#34;wc2(7)&#34;, PosReal(), None),
              &#34;kaonp_weight_cutoff&#34;: (&#34;wc2(8)&#34;, PosReal(), None),
              &#34;kaon0_weight_cutoff&#34;: (&#34;wc2(9)&#34;, PosReal(), None),
              &#34;kaonm_weight_cutoff&#34;: (&#34;wc2(10)&#34;, PosReal(), None),
              &#34;other_weight_cutoff&#34;: (&#34;wc2(11)&#34;, PosReal(), None),
              &#34;electron_weight_cutoff&#34;: (&#34;wc2(12)&#34;, PosReal(), None),
              &#34;positron_weight_cutoff&#34;: (&#34;wc2(13)&#34;, PosReal(), None),
              &#34;photon_weight_cutoff&#34;: (&#34;wc2(14)&#34;, PosReal(), None),
              &#34;deuteron_weight_cutoff&#34;: (&#34;wc2(15)&#34;, PosReal(), None),
              &#34;triton_weight_cutoff&#34;: (&#34;wc2(16)&#34;, PosReal(), None),
              &#34;he3_weight_cutoff&#34;: (&#34;wc2(17)&#34;, PosReal(), None),
              &#34;he4_weight_cutoff&#34;: (&#34;wc2(18)&#34;, PosReal(), None),
              &#34;nucleon_weight_cutoff&#34;: (&#34;wc2(19)&#34;, PosReal(), None),
              # &#34;proton_source_weight_min&#34;: (&#34;swc1(1)&#34;, PosReal(), None),
              # &#34;neutron_source_weight_min&#34;: (&#34;swc1(2)&#34;, PosReal(), None),
              # &#34;pionp_source_weight_min&#34;: (&#34;swc1(3)&#34;, PosReal(), None),
              # &#34;pion0_source_weight_min&#34;: (&#34;swc1(4)&#34;, PosReal(), None),
              # &#34;pionm_source_weight_min&#34;: (&#34;swc1(5)&#34;, PosReal(), None),
              # &#34;muonp_source_weight_min&#34;: (&#34;swc1(6)&#34;, PosReal(), None),
              # &#34;muonm_source_weight_min&#34;: (&#34;swc1(7)&#34;, PosReal(), None),
              # &#34;kaonp_source_weight_min&#34;: (&#34;swc1(8)&#34;, PosReal(), None),
              # &#34;kaon0_source_weight_min&#34;: (&#34;swc1(9)&#34;, PosReal(), None),
              # &#34;kaonm_source_weight_min&#34;: (&#34;swc1(10)&#34;, PosReal(), None),
              # &#34;other_source_weight_min&#34;: (&#34;swc1(11)&#34;, PosReal(), None),
              # &#34;electron_source_weight_min&#34;: (&#34;swc1(12)&#34;, PosReal(), None),
              # &#34;positron_source_weight_min&#34;: (&#34;swc1(13)&#34;, PosReal(), None),
              # &#34;photon_source_weight_min&#34;: (&#34;swc1(14)&#34;, PosReal(), None),
              # &#34;deuteron_source_weight_min&#34;: (&#34;swc1(15)&#34;, PosReal(), None),
              # &#34;triton_source_weight_min&#34;: (&#34;swc1(16)&#34;, PosReal(), None),
              # &#34;he3_source_weight_min&#34;: (&#34;swc1(17)&#34;, PosReal(), None),
              # &#34;he4_source_weight_min&#34;: (&#34;swc1(18)&#34;, PosReal(), None),
              # &#34;nucleon_source_weight_min&#34;: (&#34;swc1(19)&#34;, PosReal(), None),
              &#34;weight_window_max&#34;: (&#34;wupn&#34;, PosReal(), None),
              &#34;survival_weight&#34;: (&#34;wsurvn&#34;, PosReal(), None),
              # &#34;max_split&#34;: (&#34;mxwpln&#34;, PosReal(), None),
              # &#34;window_at&#34;: (&#34;mwhere&#34;, FinBij({&#34;reaction&#34;: -1, &#34;both&#34;: 0, &#34;reg_crossing&#34;: 1}), None),
              &#34;ww_bias&#34;: (&#34;iwwbias&#34;, Choice10(), None),
              &#34;std_cutoff&#34;: (&#34;istdcut&#34;, Choice10(), None),
              # &#34;only_cut_after_batch&#34;: (&#34;istdbat&#34;, PosInt(), None),
              &#34;stopping_model&#34;: (&#34;ndedx&#34;, FinBij({&#34;SPAR_nucleus_only+NTMC&#34;: 0, &#34;ATIMA+NTMC&#34;: 1, &#34;SPAR+NTMC&#34;: 2, &#34;ATIMA&#34;: 3}), None),
              &#34;atima_db_max&#34;: (&#34;mdbatima&#34;, PosInt(), None),
              &#34;atima_e_cutoff&#34;: (&#34;dbcutoff&#34;, PosReal(), None),
              &#34;atima_water_ion_e&#34;: (&#34;ih2o&#34;, NegDisable(), None),
              &#34;atima_effective_charge&#34;: (&#34;ifixchg&#34;, Choice10(), None),
              &#34;restricted_delta_LET&#34;: (&#34;irlet&#34;, Choice10(), None),
              &#34;elastic_scattering&#34;: (&#34;ielas&#34;, FinBij({None: 0, &#34;neutron&#34;: 1, &#34;both&#34;: 2}), None),
              &#34;elastic_angle_groups&#34;: (&#34;ielms&#34;, PosInt(), None),
              &#34;nucleon_model&#34;: (&#34;icxnp&#34;, FinBij({&#34;JAM&#34;: 0, &#34;JENDL&#34;: 1}), None),
              &#34;nucleon_nucleus_model&#34;: (&#34;icxsni&#34;, FinBij({&#34;Perlstein-Niita&#34;: 0, &#34;KUROTAMA&#34;: 1, &#34;Sato&#34;: 2}), None),
              &#34;nucleus_nucleus_model&#34;: (&#34;icrhi&#34;, FinBij({&#34;Shen&#34;: 0, &#34;NASA&#34;: 1, &#34;KUROTAMA&#34;: 2}), None),
              &#34;deuteron_model&#34;: (&#34;icrdm&#34;, FinBij({&#34;nuclear&#34;: 0, &#34;MWO&#34;: 1}), None),
              &#34;pion_induced_model&#34;: (&#34;icxspi&#34;, FinBij({&#34;geometrical&#34;: 0, &#34;Hashimoto&#34;: 1}), None),
              &#34;evap_model&#34;: (&#34;nevap&#34;, FinBij({None: 0, &#34;GEM&#34;: 3}), None),
              &#34;gem_version&#34;: (&#34;ngem&#34;, FinBij({1: 1, 2: 2}), None),
              &#34;fission_model&#34;: (&#34;ifission&#34;, FinBij({&#34;PHITS&#34;: 1, &#34;Iwamoto&#34;: 2}), None),
              &#34;gamma_decay_model&#34;: (&#34;igamma&#34;, FinBij({None: 0, &#34;PHITS&#34;: 1, &#34;EBITEM&#34;: 2, &#34;EBITEM isomer&#34;: 3,
                                                      &#34;PHITS no Doppler&#34;: -1, &#34;EBITEM no Doppler&#34;: -2, &#34;EBITEM no Doppler&#34;: -3}), None),
              &#34;statistical_multifrag_model&#34;: (&#34;ismm&#34;, Choice10(), None),
              &#34;event_generator&#34;: (&#34;e-mode&#34;, FinBij({None: 0, &#34;simple&#34;: 1, &#34;complicated&#34;: 2}), None),
              &#34;event_generator_max_e&#34;: (&#34;em-emode&#34;, PosReal(), None),
              &#34;neutron_kerma&#34;: (&#34;ikerman&#34;, Choice10(c_style=True), None),
              &#34;photon_kerma&#34;: (&#34;ikermap&#34;, Choice10(c_style=True), None),
              &#34;photon_adjoint&#34;: (&#34;iadjoint&#34;, Choice10(), None),
              &#34;bertini_nucleon_cross_section&#34;: (&#34;inmed&#34;, FinBij({&#34;free&#34;: 0, &#34;cugnon_old&#34;: 1, &#34;cugnon_new&#34;: 2}), None),
              &#34;bertini_angular_distribution&#34;: (&#34;andit&#34;,  FinBij({&#34;split&#34;: 0, &#34;isotropic&#34;: 1, &#34;forward&#34;: 2}), None),
              &#34;experimental_neutron_fission&#34;: (&#34;iidfs&#34;, Choice10(c_style=True), None),
              &#34;discrete_dwba_spectra&#34;: (&#34;idwba&#34;, Choice10(), None),
              # &#34;absorb_low_e_neg&#34;: (&#34;npdik&#34;, Choice10(c_style=True), None),
              &#34;neutron_capture_cutoff&#34;: (&#34;emcnf&#34;, PosReal(), None),
              &#34;fission_delayed_neutrons&#34;: (&#34;dnb&#34;, OneOf(FinBij({&#34;natural&#34;: -1, None: 0}), PosReal()), None),
              &#34;fission_neutron_production&#34;: (&#34;nonu&#34;, Choice10(), None),
              &#34;s_matrix_interpolation&#34;: (&#34;isaba&#34;, Choice10(), None),
              &#34;detailed_photon_cutoff&#34;: (&#34;emcpf&#34;, PosReal(), None),
              &#34;photon_coherent_scatter&#34;: (&#34;nocoh&#34;, Choice10(c_style=True), None),
              &#34;simple_brem&#34;: (&#34;ibad&#34;, Choice10(), None),
              &#34;brem_photon_count&#34;: (&#34;bnum&#34;, PosReal(), None),
              &#34;xray_photon_count&#34;: (&#34;xnum&#34;, PosReal(), None),
              &#34;substep_brem&#34;: (&#34;numb&#34;, Choice10(), None),
              # ipegs
              &#34;multiple_scattering&#34;: (&#34;imsegs&#34;, FinBij({&#34;PHITS-EGS5&#34;: 1, &#34;EGS5&#34;: 0}), None),
              # iegsout
              &#34;egs_rand_seed&#34;: (&#34;iegsrand&#34;, PosReal(), None),
              &#34;edge_photons&#34;: (&#34;iedgfl&#34;, Choice10(), None),
              &#34;edge_auger_electrons&#34;: (&#34;iauger&#34;, Choice10(), None),
              &#34;coherent_reyleigh_scattering&#34;: (&#34;iraylr&#34;, Choice10(), None),
              # lpolar
              # iunrst
              &#34;egs_material_size&#34;: (&#34;chard&#34;, Real(), None),
              &#34;icru90_corrections&#34;: (&#34;epstfl&#34;, Choice10(), None),
              &#34;densest_gas&#34;: (&#34;gasegs&#34;, PosReal(), None),
              &#34;compton_incoherent_scattering&#34;: (&#34;incohr&#34;, Choice10(), None),
              &#34;compton_doppler_broadening&#34;: (&#34;iprofr&#34;, Choice10(), None),
              &#34;electron_impact_ionization&#34;: (&#34;impacr&#34;, Choice10(), None),
              &#34;electron_impact_xray_split&#34;: (&#34;ieispl&#34;, Choice10(), None),
              &#34;electron_impact_xray_count&#34;: (&#34;neispl&#34;, PosInt(), None),
              &#34;brem_sample_polar_angle&#34;: (&#34;ibrdst&#34;, Choice10(), None),
              &#34;electron_pair_sample_polar_angle&#34;: (&#34;iprdst&#34;, Choice10(), None),
              &#34;photoelectron_sample_angle&#34;: (&#34;iphter&#34;, Choice10(), None),
              &#34;compton_bound_cross_section&#34;: (&#34;ibound&#34;, Choice10(), None),
              &#34;brem_cross_section_correction&#34;: (&#34;iaprim&#34;, FinBij({None: 2, &#34;modeled&#34;: 1, &#34;empirical&#34;: 0}), None),
              &#34;photonuclear_reactions&#34;: (&#34;ipnint&#34;, FinBij({None: 0, &#34;no_flourescence&#34;: 1, &#34;all&#34;: 2}), None),
              &#34;photonuclear_probability_weight&#34;: (&#34;pnimul&#34;, PosReal(), None),
              &#34;photon_induced_muon_production&#34;: (&#34;igmuppd&#34;, Choice10(), None),
              &#34;muon_capture&#34;: (&#34;imucap&#34;, FinBij({False: 0, True: 1, &#34;custom_xray&#34;: 2}), None),
              &#34;muon_induced_reactions&#34;: (&#34;imuint&#34;, Choice10(), None),
              &#34;muon_induced_brem&#34;: (&#34;imubrm&#34;, Choice10(), None),
              &#34;muon_induced_pairs&#34;: (&#34;imuppd&#34;, Choice10(), None),
              &#34;muon_induced_reaction_min&#34;: (&#34;emumin&#34;, PosReal(), None),
              &#34;muon_induced_reaction_max&#34;: (&#34;emumax&#34;, PosReal(), None),
              &#34;neutrino_induced_reaction&#34;: (&#34;ntrnore&#34;, Choice10(), None),
              &#34;angle_straggling&#34;: (&#34;nspred&#34;, FinBij({&#34;Lynch&#34;: 2, &#34;NTMCC&#34;: 1, None: 0}), None),
              &#34;lynch_params&#34;: ((&#34;ascat1&#34;, &#34;ascat2&#34;), (Real(), Real()), None),
              &#34;energy_straggling&#34;: (&#34;nedisp&#34;, Choice10(), None),
              &#34;gravity&#34;: ((&#34;gravx&#34;, &#34;gravy&#34;, &#34;gravz&#34;), (Real(), Real(), Real()), None),
              # usrmgt, usrelst
              &#34;magnetic_field&#34;: (&#34;imagnf&#34;, Choice10(), None),
              &#34;electromagnetic_field&#34;: (&#34;ielctf&#34;, Choice10(), None),
              # TODO: decide if users can recover output files from work directory (and, accordingly, if output options are necessary)
              # &#34;binary_cells&#34;:   (&#34;icells&#34;, FinBij({False: 3, True: }))
              }

    def restrictions(self):
        wmax = self.weight_window_max if self.weight_window_max is not None else 5
        wgt = self.survival_weight if self.survival_weight is not None else 0.6 * wmax
        if not (1 &lt; wgt &lt; wmax):
            raise ValueError(f&#34;One must have 1 &lt; survival_weight &lt; weight_window_max; got survival_weight={wgt}&#34;
                             f&#34;and weight_window_max={wmax}.&#34;)

        mhist = self.max_histories if self.max_histories is not None else 10
        mbch = self.max_batches if self.max_batches is not None else 10
        if mhist * mbch &gt; 2_147_483_647:
            raise ValueError(f&#34;History and batch maxima ({self.max_histories} and {self.max_batches}) will result in overflow.&#34;)

        for wc1, wc2 in zip(sorted(filter(lambda x: &#34;wc1&#34; in x[1][0], self.syntax.items()),
                                   key=lambda x: re.search(&#34;[1-9][0-9]*&#34;, x[1][0])[0]),
                            sorted(filter(lambda x: &#34;wc2&#34; in x[1][0], self.syntax.items()),
                                   key=lambda x: re.search(&#34;[1-9][0-9]*&#34;, x[1][0])[0])):
            v1 = getattr(self, wc1[0])
            v2 = getattr(self, wc2[0])
            if (v1 is not None and v2 is not None and v1 &lt;= v2) or (v1 is None and v2 is not None and v2 &gt;= 0.5):
                raise ValueError(f&#34;One must have {wc1[1][0]} &gt; {wc2[1][0]}; got {wc1[1][0]}={v1} and {wc2[1][0]}={v1}.&#34;)


    def __init__(self, **kwargs):
        extra = {k: kwargs[k] for k in set(kwargs) - set(self.syntax)}

        assert not extra, f&#34;Unrecognized parameters {extra} in initialization of Parameters object.&#34; \
            &#34;Check that the correct parameters were passed to other objects.&#34;
        for k, (_, spec, _) in self.syntax.items():
            if k in kwargs and kwargs[k] is not None:
                if isinstance(spec, tuple):
                    map(lambda x: spec.phits(x), kwargs[k])
                else:
                    spec.phits(kwargs[k])

                setattr(self, k, kwargs[k])
            else:
                setattr(self, k, None)

        self.restrictions()

    def __getitem__(self, key):
        return self.__dict__[key]

    def empty(self):
        return True if self.__dict__ == {&#34;name&#34;: &#34;parameters&#34;} else False

    def definition(self):
        inp = &#34;&#34;
        for var, val in  self.__dict__.items():
            if val is not None:
                if var in self.syntax:
                    phits_iden, valspec = self.syntax[var][0], self.syntax[var][1]
                    if isinstance(valspec, tuple):
                        for idx, spec in enumerate(valspec):
                            mapped = spec.phits(val[idx])
                            if callable(mapped):
                                raise mapped(var)
                            else:
                                inp += f&#34;{phits_iden[idx]} = {mapped}\n&#34;
                    else:
                        mapped = valspec.phits(val)
                        if callable(mapped):
                            raise mapped(var)
                        else:
                            inp += f&#34;{phits_iden} = {mapped}\n&#34;
        return inp

    def section_title(self) -&gt; str:
        &#34;&#34;&#34;Return the section title under which a PhitsObject belongs.&#34;&#34;&#34;
        sec_name = self.name.replace(&#34;_&#34;, &#34; &#34;).title()
        return f&#34;[{sec_name}]\n&#34;


    @classmethod
    def syntax_desc(self) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of the initialization syntax of the PhitsObject in question.
        Used to generate documentation, but is useful in interactive sessions to &#34;&#34;&#34;
        required = sorted([(k, v) for k, v in self.syntax.items() if v[2] is not None], key=lambda tup: tup[1][2])
        opt = [(k, v) for k, v in self.syntax.items() if v[2] is None]
        r = &#34;&#34;
        def capfirst(st):
            return st[0].upper() + st[1:]

        if required:
            r = &#34;Required arguments:\n\n|Position|Python name|PHITS name|Accepted value|\n|----|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in required:

                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;

        if opt:
            r += &#34;\nOptional arguments:\n\n|Python name|PHITS name|Accepted value|\n|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in opt:
                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;
        return r

    @classmethod
    def syntax_for(self, attr: str) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of a specific initialization parameter of the PhitsObject in question.&#34;&#34;&#34;
        r = &#34;PHITS name\tAccepted value\tPosition\n&#34;
        r += f&#34;{self.syntax[attr][0]}\t{self.syntax[attr][1]}\t{self.syntax[attr][2]}&#34;
        return r

    @classmethod
    def required_args(self):
        &#34;&#34;&#34;The required arguments from `self.syntax`, in order.&#34;&#34;&#34;
        return list(sorted(((k, v) for k, v in self.syntax.items() if v[2] is not None), key=lambda t: t[1][2]))

    @classmethod
    def optional_args(self):
        &#34;&#34;&#34;The optional arguments from `self.syntax`.&#34;&#34;&#34;
        return list(filter(lambda t: t[1][2] is None, self.syntax.items()))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyphits.Parameters.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyphits.Parameters.syntax"><code class="name">var <span class="ident">syntax</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyphits.Parameters.optional_args"><code class="name flex">
<span>def <span class="ident">optional_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The optional arguments from <code>self.syntax</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def optional_args(self):
    &#34;&#34;&#34;The optional arguments from `self.syntax`.&#34;&#34;&#34;
    return list(filter(lambda t: t[1][2] is None, self.syntax.items()))</code></pre>
</details>
</dd>
<dt id="pyphits.Parameters.required_args"><code class="name flex">
<span>def <span class="ident">required_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The required arguments from <code>self.syntax</code>, in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def required_args(self):
    &#34;&#34;&#34;The required arguments from `self.syntax`, in order.&#34;&#34;&#34;
    return list(sorted(((k, v) for k, v in self.syntax.items() if v[2] is not None), key=lambda t: t[1][2]))</code></pre>
</details>
</dd>
<dt id="pyphits.Parameters.syntax_desc"><code class="name flex">
<span>def <span class="ident">syntax_desc</span></span>(<span>) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a readable summary of the initialization syntax of the PhitsObject in question.
Used to generate documentation, but is useful in interactive sessions to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def syntax_desc(self) -&gt; str:
    &#34;&#34;&#34;Return a readable summary of the initialization syntax of the PhitsObject in question.
    Used to generate documentation, but is useful in interactive sessions to &#34;&#34;&#34;
    required = sorted([(k, v) for k, v in self.syntax.items() if v[2] is not None], key=lambda tup: tup[1][2])
    opt = [(k, v) for k, v in self.syntax.items() if v[2] is None]
    r = &#34;&#34;
    def capfirst(st):
        return st[0].upper() + st[1:]

    if required:
        r = &#34;Required arguments:\n\n|Position|Python name|PHITS name|Accepted value|\n|----|----|----|----|\n&#34;
        for py_attr, (phits_attr, valspec, position, *s) in required:

            if isinstance(valspec, tuple):
                j = &#34;, &#34;
                r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
            else:

                r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;

    if opt:
        r += &#34;\nOptional arguments:\n\n|Python name|PHITS name|Accepted value|\n|----|----|----|\n&#34;
        for py_attr, (phits_attr, valspec, position, *s) in opt:
            if isinstance(valspec, tuple):
                j = &#34;, &#34;
                r += f&#34;|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
            else:

                r += f&#34;|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;
    return r</code></pre>
</details>
</dd>
<dt id="pyphits.Parameters.syntax_for"><code class="name flex">
<span>def <span class="ident">syntax_for</span></span>(<span>attr:str) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a readable summary of a specific initialization parameter of the PhitsObject in question.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def syntax_for(self, attr: str) -&gt; str:
    &#34;&#34;&#34;Return a readable summary of a specific initialization parameter of the PhitsObject in question.&#34;&#34;&#34;
    r = &#34;PHITS name\tAccepted value\tPosition\n&#34;
    r += f&#34;{self.syntax[attr][0]}\t{self.syntax[attr][1]}\t{self.syntax[attr][2]}&#34;
    return r</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Parameters.definition"><code class="name flex">
<span>def <span class="ident">definition</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def definition(self):
    inp = &#34;&#34;
    for var, val in  self.__dict__.items():
        if val is not None:
            if var in self.syntax:
                phits_iden, valspec = self.syntax[var][0], self.syntax[var][1]
                if isinstance(valspec, tuple):
                    for idx, spec in enumerate(valspec):
                        mapped = spec.phits(val[idx])
                        if callable(mapped):
                            raise mapped(var)
                        else:
                            inp += f&#34;{phits_iden[idx]} = {mapped}\n&#34;
                else:
                    mapped = valspec.phits(val)
                    if callable(mapped):
                        raise mapped(var)
                    else:
                        inp += f&#34;{phits_iden} = {mapped}\n&#34;
    return inp</code></pre>
</details>
</dd>
<dt id="pyphits.Parameters.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(self):
    return True if self.__dict__ == {&#34;name&#34;: &#34;parameters&#34;} else False</code></pre>
</details>
</dd>
<dt id="pyphits.Parameters.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    wmax = self.weight_window_max if self.weight_window_max is not None else 5
    wgt = self.survival_weight if self.survival_weight is not None else 0.6 * wmax
    if not (1 &lt; wgt &lt; wmax):
        raise ValueError(f&#34;One must have 1 &lt; survival_weight &lt; weight_window_max; got survival_weight={wgt}&#34;
                         f&#34;and weight_window_max={wmax}.&#34;)

    mhist = self.max_histories if self.max_histories is not None else 10
    mbch = self.max_batches if self.max_batches is not None else 10
    if mhist * mbch &gt; 2_147_483_647:
        raise ValueError(f&#34;History and batch maxima ({self.max_histories} and {self.max_batches}) will result in overflow.&#34;)

    for wc1, wc2 in zip(sorted(filter(lambda x: &#34;wc1&#34; in x[1][0], self.syntax.items()),
                               key=lambda x: re.search(&#34;[1-9][0-9]*&#34;, x[1][0])[0]),
                        sorted(filter(lambda x: &#34;wc2&#34; in x[1][0], self.syntax.items()),
                               key=lambda x: re.search(&#34;[1-9][0-9]*&#34;, x[1][0])[0])):
        v1 = getattr(self, wc1[0])
        v2 = getattr(self, wc2[0])
        if (v1 is not None and v2 is not None and v1 &lt;= v2) or (v1 is None and v2 is not None and v2 &gt;= 0.5):
            raise ValueError(f&#34;One must have {wc1[1][0]} &gt; {wc2[1][0]}; got {wc1[1][0]}={v1} and {wc2[1][0]}={v1}.&#34;)</code></pre>
</details>
</dd>
<dt id="pyphits.Parameters.section_title"><code class="name flex">
<span>def <span class="ident">section_title</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the section title under which a PhitsObject belongs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def section_title(self) -&gt; str:
    &#34;&#34;&#34;Return the section title under which a PhitsObject belongs.&#34;&#34;&#34;
    sec_name = self.name.replace(&#34;_&#34;, &#34; &#34;).title()
    return f&#34;[{sec_name}]\n&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.PhitsObject"><code class="flex name class">
<span>class <span class="ident">PhitsObject</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base factory class distinguishing objects that are intended to end up in some section of a <code>.inp</code> file,
and defining equality and hashability of such objects in sensible ways.</p>
<p>PhitsObject values always correspond to some section of an input file.</p>
<p>Arguments are interpreted according to <code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">PhitsObject.syntax</a></code>, and then any leftovers in <code>kwargs</code> are used to create a <code><a title="pyphits.Parameters" href="#pyphits.Parameters">Parameters</a></code>
object, which is then assigned to a <code>parameters</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhitsObject:
    &#34;&#34;&#34;The base factory class distinguishing objects that are intended to end up in some section of a `.inp` file,
    and defining equality and hashability of such objects in sensible ways.

    PhitsObject values always correspond to some section of an input file.
    &#34;&#34;&#34;

    name = None
    &#34;&#34;&#34;A string corresponding to the PHITS .inp section an object appears in. See `PhitsObject.names`&#34;&#34;&#34;

    syntax = dict()
    &#34;&#34;&#34;A dictionary with entries of the form `&#34;python_identifier&#34;: (&#34;PHITS_identifier&#34;, acceptable_ValSpec, arg_position, Optional(none_val))`.
    The key is the attribute on the Python PhitsObject instance, and the keyword argument necessary to set it.
    The second is what type the object must be, as a ValSpec.
    The third is what index in `*args` the argument must have; if it is set to `None`, the argument is optional.
    The last is a value to put in the .inp if the attribute is `None` at compile-time; ordinarily, it&#39;s just nothing.
    The first two arguments can be tuples, in which case the passed value must be a tuple of the specified type;
    the single Python assignment corresponds to the entrywise assignments of this tuple to the PHITS identifiers in the .inp.&#34;&#34;&#34;

    shape = tuple()
    &#34;&#34;&#34;A tuple that details how the object is to be represented in the .inp file.
    The syntax is inspired by Emacs Lisp skeletons, with some optimizations to tailor it for this use-case.
    In general, the strings in the tuple are inserted verbatim, with a newline in between them.
    If an entry is the name of an attribute of the instance, say `&#34;attr&#34;` whose value is not `None`,
    then the string `PHITS_identifier = acceptable_ValSpec.phits(self.attr)`, based on a lookup of `attr` in `PhitsObject.syntax`, is inserted.
    If an entry is `self`, then `self.index` is inserted.
    To avoid the above two behaviors, and insert a string verbatim, prepend a quote `&#39;`.
    If an entry is another tuple, that tuple gets evaluated as above, but the `identifier = ` is not inserted,
    and a mere space separates the entries.
    Appending a `\\` to any string disables the insertion of the spacing that would otherwise follow;
    similarly, having `\\` as the last string of a tuple entry disables the newline that would otherwise follow.

    If this attribute is callable, it gets called on the instance of the PhitsObject, and the result is processed according to the rules above.
    &#34;&#34;&#34;

    index = None
    &#34;&#34;&#34;The compile-time assigned number of an object. Should not be set directly.&#34;&#34;&#34;

    # no_hash = {&#34;index&#34;, &#34;value_map&#34;, &#34;ident_map&#34;, &#34;nones&#34;, &#34;shape&#34;, &#34;subobjects&#34;, &#34;required&#34;, &#34;positional&#34;, &#34;optional&#34;,
    #            &#34;group_by&#34;, &#34;separator&#34;, &#34;prelude&#34;, &#34;max_groups&#34;, &#34;group_size&#34;, &#34;parser&#34;, &#34;validator&#34;}
    # &#34;&#34;&#34;Attributes that don&#39;t affect the identity of a PhitsObject.&#34;&#34;&#34;

    names = {&#34;parameters&#34;, &#34;source&#34;, &#34;material&#34;, &#34;surface&#34;, &#34;cell&#34;, &#34;transform&#34;, &#34;temperature&#34;,&#34;mat_time_change&#34;,&#34;magnetic_field&#34;,
             &#34;electromagnetic_field&#34;, &#34;frag_data&#34;, &#34;data_max&#34;,
             &#34;delta_ray&#34;, &#34;track_structure&#34;, &#34;super_mirror&#34;, &#34;elastic_option&#34;, &#34;importance&#34;, &#34;weight_window&#34;, &#34;ww_bias&#34;,
             &#34;forced_collisions&#34;, &#34;repeated_collisions&#34;, &#34;volume&#34;, &#34;multiplier&#34;, &#34;mat_name_color&#34;, &#34;reg_name&#34;, &#34;counter&#34;, &#34;timer&#34;,
             &#34;t-track&#34;, &#34;t-cross&#34;, &#34;t-point&#34;, &#34;t-adjoint&#34;, &#34;t-deposit&#34;, &#34;t-deposit2&#34;, &#34;t-heat&#34;, &#34;t-yield&#34;, &#34;t-product&#34;, &#34;t-dpa&#34;,
             &#34;t-let&#34;, &#34;t-sed&#34;, &#34;t-time&#34;, &#34;t-interact&#34;, &#34;t-dchain&#34;, &#34;t-wwg&#34;, &#34;t-wwbg&#34;, &#34;t-volume&#34;, &#34;t-gshow&#34;, &#34;t-rshow&#34;,&#34;t-3dshow&#34;}
    &#34;&#34;&#34;The permissible `PhitsObject.name`s.&#34;&#34;&#34;

    group_by = None
    &#34;&#34;&#34;A key function by which to group PhitsObjects together.
    These groups are necessary, for instance, in the `Importance` section, where one can set different importances for different particles
    in the same cell.&#34;&#34;&#34;

    separator = None
    &#34;&#34;&#34;A function returning a string to be placed between the definitions of the groups; see `PhitsObject.group_by`.&#34;&#34;&#34;

    max_groups = None
    &#34;&#34;&#34;The maximum number of groups of objects of a given type; see `PhitsObject.group_by`.&#34;&#34;&#34;

    prelude = tuple()
    &#34;&#34;&#34;A skeleton just like `PhitsObject.shape`, but inserted before all definitions of the `PhitsObject` subclass in question.&#34;&#34;&#34;
    subobjects = []
    &#34;&#34;&#34;A list of all `PhitsObject.name`s that can appear as attributes of the object in question.&#34;&#34;&#34;
    superobjects = []
    &#34;&#34;&#34;A list of all `PhitsObject.name`s that this object ought to be defined from.&#34;&#34;&#34;
    restrictions = lambda self: tuple()
    &#34;&#34;&#34;A function that&#39;s called right at the end of initialization. Should be used to raise errors for any combination of values
    that is incorect but not easily expressible via `ValSpec`s.&#34;&#34;&#34;
    def __init__(self, *args,  **kwargs):
        &#34;&#34;&#34;Arguments are interpreted according to `PhitsObject.syntax`, and then any leftovers in `kwargs` are used to create a `Parameters`
        object, which is then assigned to a `parameters` attribute.&#34;&#34;&#34;
        assert self.name in self.names, f&#34;Unrecognized PHITS type {self.name} in PhitsObject initialization.&#34;

        # Handle required args
        required = list(map(lambda tup: tup[0], self.required_args()))

        assert len(args) == len(required), f&#34;Wrong number of positional arguments specified in the definition of {self} object.&#34;
        for idx, arg in enumerate(args):
            # Validate first
            details = self.syntax[required[idx]]
            valspec = details[1]
            if isinstance(valspec, tuple):
                for id2, spec in enumerate(valspec):
                    mapped = spec.phits(arg[id2])
                    if callable(mapped):
                        raise mapped(required[idx])
            else:
                mapped = valspec.phits(arg)
                if callable(mapped):
                    raise mapped(required[idx])

            # Then set the attribute
            setattr(self, required[idx], arg if not isinstance(arg, list) else _tuplify(arg))

        # Handle optional args
        for arg in self.syntax:
            valspec, position = self.syntax[arg][1], self.syntax[arg][2]
            if position == None:
                if arg in kwargs:
                    # Validate first
                    if kwargs[arg] is not None:
                        if isinstance(valspec, tuple):
                            for idx, spec in enumerate(valspec):
                                mapped = spec.phits(kwargs[arg][idx])
                                if callable(mapped):
                                    raise mapped(arg)
                        else:
                            mapped = valspec.phits(kwargs[arg])
                            if callable(mapped):
                                raise mapped(arg)

                        # Then set the attribute
                        setattr(self, arg, kwargs[arg] if not isinstance(kwargs[arg], list) else _tuplify(kwargs[arg]))
                    else:
                        setattr(self, arg, None)
                else:
                    # Handle unpassed
                    setattr(self, arg, None)


        for attr in self.subobjects:
            if hasattr(self, attr):
                child = getattr(self, attr)
                if child is not None:
                    setattr(child, self.name, self)

        # for attr in self.superobjects:
        #     setattr(self, attr, None) # subobjects are instantiated before superobjects

        remaining = {k: v for k, v in kwargs.items() if k not in self.syntax and k not in self.subobjects}
        if remaining:
            self.parameters = Parameters(**remaining)

        # check restrictions satisfied
        self.restrictions()

    def _add_definition(self, how: tuple, to: str, assignments: bool = True) -&gt; str:
        &#34;&#34;&#34;Recursively performs skeleton insertions according to `how` at the end of `to`.&#34;&#34;&#34;
        if callable(how):
            how = how()

        for attr in how:

            endstr = &#34;\n&#34; if assignments else &#34; &#34;
            spacing = &#34; &#34;

            if isinstance(attr, str) and len(attr) &gt; 0 and attr[0] == &#34;&#39;&#34;:
                to += attr[1:]
                to += endstr
                continue

            if isinstance(attr, str) and len(attr) &gt; 0 and attr[-1] == &#34;\\&#34;:
                endstr = &#34; &#34;
                spacing = &#34;&#34;
                attr = attr[:-1]

            if isinstance(attr, tuple):
                to += self._add_definition(attr, &#34;&#34;, assignments=False)
                if attr[-1] == &#34;\\&#34;:
                    to += &#34; &#34;
                else:
                    to += &#34;\n&#34;

            elif attr in self.syntax:
                val = getattr(self, attr)
                phits_iden = self.syntax[attr][0]
                valspec = self.syntax[attr][1]
                noneval = &#34;&#34;
                if len(self.syntax[attr]) &gt; 3:
                    noneval = self.syntax[attr][3]

                if val is not None:
                    if isinstance(phits_iden, tuple):
                        for i, (phits, spec) in enumerate(zip(phits_iden, valspec)):
                            assign = f&#34;{phits}{spacing}={spacing}&#34; if assignments else &#34;&#34;
                            v = spec.phits(val[i])
                            if callable(v):
                                raise v(attr)
                            else:
                                to += f&#34;{assign}{v}{endstr}&#34;
                    else:
                        assign = f&#34;{phits_iden}{spacing}={spacing}&#34; if assignments else &#34;&#34;
                        v = valspec.phits(val)
                        if callable(v):
                            raise v(attr)
                        else:
                            to += f&#34;{assign}{v}{endstr}&#34;

                elif noneval != &#34;&#34; and noneval is not None: # I think we don&#39;t use nones for anything except the simplest case
                    to += str(noneval)
                    to += endstr


            else:
                if attr == &#34;self&#34;:
                    to += str(self.index)
                    to += endstr

                elif attr in self.superobjects: # can&#39;t use syntax because impredicativity in module imports
                    to += str(getattr(self, attr).index)
                    to += endstr
                else:
                    to += attr
                    to += endstr
        return to

    def prelude_str(self) -&gt; str:
        &#34;&#34;&#34;Return a string to appear before the collection of all definitions of subclass instances in an `.inp` file.&#34;&#34;&#34;
        inp = self._add_definition(self.prelude, &#34;&#34;)

        return inp

    def definition(self) -&gt; str:
        &#34;&#34;&#34;Return the string representing the particular PhitsObject in an `.inp` file.&#34;&#34;&#34;
        inp = self._add_definition(self.shape, &#34;&#34;)
        if self.name in [&#34;surface&#34;, &#34;cell&#34;]:
            return _continue_lines(inp)
        else:
            return inp

    def section_title(self) -&gt; str:
        &#34;&#34;&#34;Return the section title under which a PhitsObject belongs.&#34;&#34;&#34;
        sec_name = self.name.replace(&#34;_&#34;, &#34; &#34;).title()
        return f&#34;[{sec_name}]\n&#34;

    @classmethod
    def syntax_desc(self) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of the initialization syntax of the PhitsObject in question.
        Used to generate documentation, but is useful in interactive sessions to &#34;&#34;&#34;
        required = sorted([(k, v) for k, v in self.syntax.items() if v[2] is not None], key=lambda tup: tup[1][2])
        opt = [(k, v) for k, v in self.syntax.items() if v[2] is None]
        r = &#34;&#34;
        def capfirst(st):
            return st[0].upper() + st[1:]

        if required:
            r = &#34;Required arguments:\n\n|Position|Python name|PHITS name|Accepted value|\n|----|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in required:

                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;

        if opt:
            r += &#34;\nOptional arguments:\n\n|Python name|PHITS name|Accepted value|\n|----|----|----|\n&#34;
            for py_attr, (phits_attr, valspec, position, *s) in opt:
                if isinstance(valspec, tuple):
                    j = &#34;, &#34;
                    r += f&#34;|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
                else:

                    r += f&#34;|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;
        return r


    @classmethod
    def syntax_for(self, attr: str, phits=False) -&gt; str:
        &#34;&#34;&#34;Return a readable summary of a specific initialization parameter of the PhitsObject in question.&#34;&#34;&#34;
        if phits:
            rev = self._syntax_reversed()
            r = &#34;Python name\tAccepted value\tPosition\n&#34;
            r += f&#34;{rev[attr][0]}\t{rev[attr][1]}\t{rev[attr][2]}&#34;
            return r
        else:
            r = &#34;PHITS name\tAccepted value\tPosition\n&#34;
            r += f&#34;{self.syntax[attr][0]}\t{self.syntax[attr][1]}\t{self.syntax[attr][2]}&#34;
            return r

    def _sanitize(self, iden: str) -&gt; str:
        &#34;&#34;&#34;Make a PHITS identifier Python-acceptable.
        See `readable_syntax`.
        &#34;&#34;&#34;
        r = iden.replace(&#34;-&#34;, &#34;_&#34;)
        r = r.replace(&#34;(&#34;, &#34;&#34;)
        r = r.replace(&#34;)&#34;, &#34;&#34;)
        if r[0].isdigit():
            if m := re.match(&#34;.*?_&#34;, r):
                r = r[m.end():] + &#34;_&#34; + r[:m.end() - 1]

        return r

    def _syntax_reversed(self):
        &#34;&#34;&#34;Produce a dictionary analogous to `PhitsObject.syntax` but using PHITS&#39;s names.&#34;&#34;&#34;
        return {v[0]: (k, *v[1:]) for k, v in self.syntax.items()}

    def __eq__(self, other: &#34;PhitsObject&#34;) -&gt; bool:
        &#34;&#34;&#34;PhitsObjects should be equal if their definitions would be the same.&#34;&#34;&#34;
        if type(self) != type(other):
            return False
        elif hasattr(self, &#34;__dict__&#34;) and hasattr(other, &#34;__dict__&#34;):
            d1 = {k: v for k, v in self.__dict__.items() if k in self.syntax}
            d2 = {k: v for k, v in other.__dict__.items() if k in self.syntax}
            return d1 == d2

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;PhitsObjects have the hash of their identity-defining attributes.&#34;&#34;&#34;
        return hash(tuple(v for k, v in sorted(self.__dict__.items())
                          if k in self.syntax and (self not in v.__dict__.values() if hasattr(v, &#34;__dict__&#34;) else True)))

    def _repr_pretty_(self, p, cycle) -&gt; str:
        &#34;&#34;&#34;Hypothesis uses this when printing failing cases.&#34;&#34;&#34;
        try:
            p.text(str(self.__dict__) + &#34;\n\n&#34; + self.definition())
        except:
            p.text(str(self.__dict__))

    @classmethod
    def required_args(self):
        &#34;&#34;&#34;The required arguments from `self.syntax`, in order.&#34;&#34;&#34;
        return list(sorted(((k, v) for k, v in self.syntax.items() if v[2] is not None), key=lambda t: t[1][2]))

    @classmethod
    def optional_args(self):
        &#34;&#34;&#34;The optional arguments from `self.syntax`.&#34;&#34;&#34;
        return list(filter(lambda t: t[1][2] is None, self.syntax.items()))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyphits.AngleDistribution" href="#pyphits.AngleDistribution">AngleDistribution</a></li>
<li><a title="pyphits.Beam" href="#pyphits.Beam">Beam</a></li>
<li><a title="pyphits.Box" href="#pyphits.Box">Box</a></li>
<li><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></li>
<li><a title="pyphits.Cone" href="#pyphits.Cone">Cone</a></li>
<li><a title="pyphits.Conical" href="#pyphits.Conical">Conical</a></li>
<li><a title="pyphits.Counter" href="#pyphits.Counter">Counter</a></li>
<li><a title="pyphits.Cylinder" href="#pyphits.Cylinder">Cylinder</a></li>
<li><a title="pyphits.Cylindrical" href="#pyphits.Cylindrical">Cylindrical</a></li>
<li><a title="pyphits.DataMax" href="#pyphits.DataMax">DataMax</a></li>
<li><a title="pyphits.DeltaRay" href="#pyphits.DeltaRay">DeltaRay</a></li>
<li><a title="pyphits.DumpFluence" href="#pyphits.DumpFluence">DumpFluence</a></li>
<li><a title="pyphits.DumpProduction" href="#pyphits.DumpProduction">DumpProduction</a></li>
<li><a title="pyphits.DumpTime" href="#pyphits.DumpTime">DumpTime</a></li>
<li><a title="pyphits.ElasticOption" href="#pyphits.ElasticOption">ElasticOption</a></li>
<li><a title="pyphits.ElectromagneticField" href="#pyphits.ElectromagneticField">ElectromagneticField</a></li>
<li><a title="pyphits.EllipticalCylinder" href="#pyphits.EllipticalCylinder">EllipticalCylinder</a></li>
<li><a title="pyphits.EnergyDistribution" href="#pyphits.EnergyDistribution">EnergyDistribution</a></li>
<li><a title="pyphits.ForcedCollisions" href="#pyphits.ForcedCollisions">ForcedCollisions</a></li>
<li><a title="pyphits.FragData" href="#pyphits.FragData">FragData</a></li>
<li><a title="pyphits.Gaussian" href="#pyphits.Gaussian">Gaussian</a></li>
<li><a title="pyphits.GaussianSlices" href="#pyphits.GaussianSlices">GaussianSlices</a></li>
<li><a title="pyphits.GeneralConic" href="#pyphits.GeneralConic">GeneralConic</a></li>
<li><a title="pyphits.Importance" href="#pyphits.Importance">Importance</a></li>
<li><a title="pyphits.MagneticField" href="#pyphits.MagneticField">MagneticField</a></li>
<li><a title="pyphits.MappedElectromagneticField" href="#pyphits.MappedElectromagneticField">MappedElectromagneticField</a></li>
<li><a title="pyphits.MappedMagneticField" href="#pyphits.MappedMagneticField">MappedMagneticField</a></li>
<li><a title="pyphits.MatNameColor" href="#pyphits.MatNameColor">MatNameColor</a></li>
<li><a title="pyphits.MatTimeChange" href="#pyphits.MatTimeChange">MatTimeChange</a></li>
<li><a title="pyphits.Material" href="#pyphits.Material">Material</a></li>
<li><a title="pyphits.NeutronMagneticField" href="#pyphits.NeutronMagneticField">NeutronMagneticField</a></li>
<li><a title="pyphits.OuterVoid" href="#pyphits.OuterVoid">OuterVoid</a></li>
<li><a title="pyphits.Parabolic" href="#pyphits.Parabolic">Parabolic</a></li>
<li><a title="pyphits.ParabolicSlices" href="#pyphits.ParabolicSlices">ParabolicSlices</a></li>
<li><a title="pyphits.ParallelPlane" href="#pyphits.ParallelPlane">ParallelPlane</a></li>
<li><a title="pyphits.Plane" href="#pyphits.Plane">Plane</a></li>
<li><a title="pyphits.PointPlane" href="#pyphits.PointPlane">PointPlane</a></li>
<li><a title="pyphits.Rectangular" href="#pyphits.Rectangular">Rectangular</a></li>
<li><a title="pyphits.RegionName" href="#pyphits.RegionName">RegionName</a></li>
<li><a title="pyphits.RepeatedCollisions" href="#pyphits.RepeatedCollisions">RepeatedCollisions</a></li>
<li><a title="pyphits.SimpleConic" href="#pyphits.SimpleConic">SimpleConic</a></li>
<li><a title="pyphits.Sphere" href="#pyphits.Sphere">Sphere</a></li>
<li><a title="pyphits.Spherical" href="#pyphits.Spherical">Spherical</a></li>
<li><a title="pyphits.Spheroid" href="#pyphits.Spheroid">Spheroid</a></li>
<li><a title="pyphits.SuperMirror" href="#pyphits.SuperMirror">SuperMirror</a></li>
<li><a title="pyphits.SurfaceSource" href="#pyphits.SurfaceSource">SurfaceSource</a></li>
<li><a title="pyphits.Tetrahedral" href="#pyphits.Tetrahedral">Tetrahedral</a></li>
<li><a title="pyphits.TetrahedralSource" href="#pyphits.TetrahedralSource">TetrahedralSource</a></li>
<li><a title="pyphits.TetrahedronBox" href="#pyphits.TetrahedronBox">TetrahedronBox</a></li>
<li><a title="pyphits.TimeDistribution" href="#pyphits.TimeDistribution">TimeDistribution</a></li>
<li><a title="pyphits.Timer" href="#pyphits.Timer">Timer</a></li>
<li><a title="pyphits.Torus" href="#pyphits.Torus">Torus</a></li>
<li><a title="pyphits.TrackStructure" href="#pyphits.TrackStructure">TrackStructure</a></li>
<li><a title="pyphits.Transform" href="#pyphits.Transform">Transform</a></li>
<li><a title="pyphits.TriangularPrism" href="#pyphits.TriangularPrism">TriangularPrism</a></li>
<li><a title="pyphits.Void" href="#pyphits.Void">Void</a></li>
<li><a title="pyphits.WWBias" href="#pyphits.WWBias">WWBias</a></li>
<li><a title="pyphits.Wedge" href="#pyphits.Wedge">Wedge</a></li>
<li><a title="pyphits.WeightWindow" href="#pyphits.WeightWindow">WeightWindow</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyphits.PhitsObject.group_by"><code class="name">var <span class="ident">group_by</span></code></dt>
<dd>
<div class="desc"><p>A key function by which to group PhitsObjects together.
These groups are necessary, for instance, in the <code><a title="pyphits.Importance" href="#pyphits.Importance">Importance</a></code> section, where one can set different importances for different particles
in the same cell.</p></div>
</dd>
<dt id="pyphits.PhitsObject.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"><p>The compile-time assigned number of an object. Should not be set directly.</p></div>
</dd>
<dt id="pyphits.PhitsObject.max_groups"><code class="name">var <span class="ident">max_groups</span></code></dt>
<dd>
<div class="desc"><p>The maximum number of groups of objects of a given type; see <code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">PhitsObject.group_by</a></code>.</p></div>
</dd>
<dt id="pyphits.PhitsObject.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>A string corresponding to the PHITS .inp section an object appears in. See <code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">PhitsObject.names</a></code></p></div>
</dd>
<dt id="pyphits.PhitsObject.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><p>The permissible <code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">PhitsObject.name</a></code>s.</p></div>
</dd>
<dt id="pyphits.PhitsObject.prelude"><code class="name">var <span class="ident">prelude</span></code></dt>
<dd>
<div class="desc"><p>A skeleton just like <code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">PhitsObject.shape</a></code>, but inserted before all definitions of the <code><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></code> subclass in question.</p></div>
</dd>
<dt id="pyphits.PhitsObject.separator"><code class="name">var <span class="ident">separator</span></code></dt>
<dd>
<div class="desc"><p>A function returning a string to be placed between the definitions of the groups; see <code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">PhitsObject.group_by</a></code>.</p></div>
</dd>
<dt id="pyphits.PhitsObject.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>A tuple that details how the object is to be represented in the .inp file.
The syntax is inspired by Emacs Lisp skeletons, with some optimizations to tailor it for this use-case.
In general, the strings in the tuple are inserted verbatim, with a newline in between them.
If an entry is the name of an attribute of the instance, say <code>"attr"</code> whose value is not <code>None</code>,
then the string <code>PHITS_identifier = acceptable_ValSpec.phits(self.attr)</code>, based on a lookup of <code>attr</code> in <code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">PhitsObject.syntax</a></code>, is inserted.
If an entry is <code>self</code>, then <code>self.index</code> is inserted.
To avoid the above two behaviors, and insert a string verbatim, prepend a quote <code>'</code>.
If an entry is another tuple, that tuple gets evaluated as above, but the <code>identifier =</code> is not inserted,
and a mere space separates the entries.
Appending a <code>\</code> to any string disables the insertion of the spacing that would otherwise follow;
similarly, having <code>\</code> as the last string of a tuple entry disables the newline that would otherwise follow.</p>
<p>If this attribute is callable, it gets called on the instance of the PhitsObject, and the result is processed according to the rules above.</p></div>
</dd>
<dt id="pyphits.PhitsObject.subobjects"><code class="name">var <span class="ident">subobjects</span></code></dt>
<dd>
<div class="desc"><p>A list of all <code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">PhitsObject.name</a></code>s that can appear as attributes of the object in question.</p></div>
</dd>
<dt id="pyphits.PhitsObject.superobjects"><code class="name">var <span class="ident">superobjects</span></code></dt>
<dd>
<div class="desc"><p>A list of all <code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">PhitsObject.name</a></code>s that this object ought to be defined from.</p></div>
</dd>
<dt id="pyphits.PhitsObject.syntax"><code class="name">var <span class="ident">syntax</span></code></dt>
<dd>
<div class="desc"><p>A dictionary with entries of the form <code>"python_identifier": ("PHITS_identifier", acceptable_ValSpec, arg_position, Optional(none_val))</code>.
The key is the attribute on the Python PhitsObject instance, and the keyword argument necessary to set it.
The second is what type the object must be, as a ValSpec.
The third is what index in <code>*args</code> the argument must have; if it is set to <code>None</code>, the argument is optional.
The last is a value to put in the .inp if the attribute is <code>None</code> at compile-time; ordinarily, it's just nothing.
The first two arguments can be tuples, in which case the passed value must be a tuple of the specified type;
the single Python assignment corresponds to the entrywise assignments of this tuple to the PHITS identifiers in the .inp.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyphits.PhitsObject.optional_args"><code class="name flex">
<span>def <span class="ident">optional_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The optional arguments from <code>self.syntax</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def optional_args(self):
    &#34;&#34;&#34;The optional arguments from `self.syntax`.&#34;&#34;&#34;
    return list(filter(lambda t: t[1][2] is None, self.syntax.items()))</code></pre>
</details>
</dd>
<dt id="pyphits.PhitsObject.required_args"><code class="name flex">
<span>def <span class="ident">required_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The required arguments from <code>self.syntax</code>, in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def required_args(self):
    &#34;&#34;&#34;The required arguments from `self.syntax`, in order.&#34;&#34;&#34;
    return list(sorted(((k, v) for k, v in self.syntax.items() if v[2] is not None), key=lambda t: t[1][2]))</code></pre>
</details>
</dd>
<dt id="pyphits.PhitsObject.syntax_desc"><code class="name flex">
<span>def <span class="ident">syntax_desc</span></span>(<span>) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a readable summary of the initialization syntax of the PhitsObject in question.
Used to generate documentation, but is useful in interactive sessions to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def syntax_desc(self) -&gt; str:
    &#34;&#34;&#34;Return a readable summary of the initialization syntax of the PhitsObject in question.
    Used to generate documentation, but is useful in interactive sessions to &#34;&#34;&#34;
    required = sorted([(k, v) for k, v in self.syntax.items() if v[2] is not None], key=lambda tup: tup[1][2])
    opt = [(k, v) for k, v in self.syntax.items() if v[2] is None]
    r = &#34;&#34;
    def capfirst(st):
        return st[0].upper() + st[1:]

    if required:
        r = &#34;Required arguments:\n\n|Position|Python name|PHITS name|Accepted value|\n|----|----|----|----|\n&#34;
        for py_attr, (phits_attr, valspec, position, *s) in required:

            if isinstance(valspec, tuple):
                j = &#34;, &#34;
                r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
            else:

                r += f&#34;|{position}|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;

    if opt:
        r += &#34;\nOptional arguments:\n\n|Python name|PHITS name|Accepted value|\n|----|----|----|\n&#34;
        for py_attr, (phits_attr, valspec, position, *s) in opt:
            if isinstance(valspec, tuple):
                j = &#34;, &#34;
                r += f&#34;|`{py_attr}`|`{phits_attr}`|A tuple ({j.join(map(lambda x: x.description(), valspec))}).|\n&#34;
            else:

                r += f&#34;|`{py_attr}`|`{phits_attr}`|{capfirst(valspec.description())}.|\n&#34;
    return r</code></pre>
</details>
</dd>
<dt id="pyphits.PhitsObject.syntax_for"><code class="name flex">
<span>def <span class="ident">syntax_for</span></span>(<span>attr:str, phits=False) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a readable summary of a specific initialization parameter of the PhitsObject in question.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def syntax_for(self, attr: str, phits=False) -&gt; str:
    &#34;&#34;&#34;Return a readable summary of a specific initialization parameter of the PhitsObject in question.&#34;&#34;&#34;
    if phits:
        rev = self._syntax_reversed()
        r = &#34;Python name\tAccepted value\tPosition\n&#34;
        r += f&#34;{rev[attr][0]}\t{rev[attr][1]}\t{rev[attr][2]}&#34;
        return r
    else:
        r = &#34;PHITS name\tAccepted value\tPosition\n&#34;
        r += f&#34;{self.syntax[attr][0]}\t{self.syntax[attr][1]}\t{self.syntax[attr][2]}&#34;
        return r</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyphits.PhitsObject.definition"><code class="name flex">
<span>def <span class="ident">definition</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the string representing the particular PhitsObject in an <code>.inp</code> file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def definition(self) -&gt; str:
    &#34;&#34;&#34;Return the string representing the particular PhitsObject in an `.inp` file.&#34;&#34;&#34;
    inp = self._add_definition(self.shape, &#34;&#34;)
    if self.name in [&#34;surface&#34;, &#34;cell&#34;]:
        return _continue_lines(inp)
    else:
        return inp</code></pre>
</details>
</dd>
<dt id="pyphits.PhitsObject.prelude_str"><code class="name flex">
<span>def <span class="ident">prelude_str</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a string to appear before the collection of all definitions of subclass instances in an <code>.inp</code> file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prelude_str(self) -&gt; str:
    &#34;&#34;&#34;Return a string to appear before the collection of all definitions of subclass instances in an `.inp` file.&#34;&#34;&#34;
    inp = self._add_definition(self.prelude, &#34;&#34;)

    return inp</code></pre>
</details>
</dd>
<dt id="pyphits.PhitsObject.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">restrictions = lambda self: tuple()</code></pre>
</details>
</dd>
<dt id="pyphits.PhitsObject.section_title"><code class="name flex">
<span>def <span class="ident">section_title</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the section title under which a PhitsObject belongs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def section_title(self) -&gt; str:
    &#34;&#34;&#34;Return the section title under which a PhitsObject belongs.&#34;&#34;&#34;
    sec_name = self.name.replace(&#34;_&#34;, &#34; &#34;).title()
    return f&#34;[{sec_name}]\n&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.Plane"><code class="flex name class">
<span>class <span class="ident">Plane</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A plane of the form Ax + By + Cz - D = 0.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>A</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>1</td>
<td><code>B</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>2</td>
<td><code>C</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>3</td>
<td><code>D</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plane(PhitsObject):
    &#34;&#34;&#34;A plane of the form Ax + By + Cz - D = 0.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;A&#34;: (None, Real(), 0),
                       &#34;B&#34;: (None, Real(), 1),
                       &#34;C&#34;: (None, Real(), 2),
                       &#34;D&#34;: (None, Real(), 3)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;P&#34;, &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;),)

    def restrictions(self):
        if self.A == 0 and self.B == 0 and self.C == 0:
            raise ValueError(&#34;For Plane: at least one of A, B, or C must be nonzero.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Plane.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.A == 0 and self.B == 0 and self.C == 0:
        raise ValueError(&#34;For Plane: at least one of A, B, or C must be nonzero.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.PointPlane"><code class="flex name class">
<span>class <span class="ident">PointPlane</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A plane specified by three points.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>p1</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>p2</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>p3</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointPlane(PhitsObject):
    &#34;&#34;&#34;A plane specified by three points.&#34;&#34;&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;p1&#34;: (None, Tuple(Real(), Real(), Real()), 0),
                       &#34;p2&#34;: (None, Tuple(Real(), Real(), Real()), 1),
                       &#34;p3&#34;: (None, Tuple(Real(), Real(), Real()), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;P&#34;,
                           f&#34;{self.p1[0]}&#34;, f&#34;{self.p1[1]}&#34;, f&#34;{self.p1[2]}&#34;,
                           f&#34;{self.p2[0]}&#34;, f&#34;{self.p2[1]}&#34;, f&#34;{self.p2[2]}&#34;,
                           f&#34;{self.p3[0]}&#34;, f&#34;{self.p3[1]}&#34;, f&#34;{self.p3[2]}&#34;),)

    def restrictions(self):
        if self.p1[0] * (self.p2[1] - self.p3[1]) + self.p2[0] * (self.p3[1] - self.p1[1]) \
           + self.p3[0] * (self.p1[1] - self.p2[1]) == 0: # i.e. points are colinear
            raise ValueError(&#34;For PointPlane: p1, p2, and p3 must not line on a line;&#34;
                             f&#34; got p1={self.p1}, p2={self.p2}, and p3={self.p3}.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.PointPlane.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.p1[0] * (self.p2[1] - self.p3[1]) + self.p2[0] * (self.p3[1] - self.p1[1]) \
       + self.p3[0] * (self.p1[1] - self.p2[1]) == 0: # i.e. points are colinear
        raise ValueError(&#34;For PointPlane: p1, p2, and p3 must not line on a line;&#34;
                         f&#34; got p1={self.p1}, p2={self.p2}, and p3={self.p3}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Rectangular"><code class="flex name class">
<span>class <span class="ident">Rectangular</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A rectangular solid source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>xbounds</code></td>
<td><code>('x0', 'x1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>ybounds</code></td>
<td><code>('x0', 'x1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>zbounds</code></td>
<td><code>('x0', 'x1')</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rectangular(PhitsObject):
    &#34;&#34;&#34;A rectangular solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;xbounds&#34;: ((&#34;x0&#34;, &#34;x1&#34;), (Real(), Real()), None),
                       &#34;ybounds&#34;: ((&#34;x0&#34;, &#34;x1&#34;), (Real(), Real()), None),
                       &#34;zbounds&#34;: ((&#34;x0&#34;, &#34;x1&#34;), (Real(), Real()), None)} | _source_semi_common

    shape = lambda self: (&#34;s-type = 2&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;charge_override&#34;, &#34;counter_start&#34;,
                          &#34;fissile&#34;, &#34;xbounds&#34;, &#34;ybounds&#34;, &#34;zbounds&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.RegionName"><code class="flex name class">
<span>class <span class="ident">RegionName</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Names a region in graphical output. Useful when <code><a title="pyphits.make_input" href="#pyphits.make_input">make_input()</a></code>ing to visualise geometries.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>reg_name</code></td>
<td><code>None</code></td>
<td>A string.</td>
</tr>
<tr>
<td>1</td>
<td><code>size</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegionName(PhitsObject):
    &#34;&#34;&#34;Names a region in graphical output. Useful when `make_input`ing to visualise geometries.&#34;&#34;&#34;
    name = &#34;reg_name&#34;
    syntax = {&#34;reg_name&#34;: (None, Text(), 0),
              &#34;size&#34;: (None, PosReal(), 1),
              }
    superobjects = [&#34;cell&#34;]
    shape = ((&#34;cell&#34;, &#34;reg_name&#34;, &#34;size&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.RepeatedCollisions"><code class="flex name class">
<span>class <span class="ident">RepeatedCollisions</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to <code><a title="pyphits.ForcedCollisions" href="#pyphits.ForcedCollisions">ForcedCollisions</a></code>, changes tally calculation in a region for low-probability interactions,
but with an eye towards rare, secondary-particle-producing reactions.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td>1</td>
<td><code>collision_reps</code></td>
<td><code>None</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td>2</td>
<td><code>evaporation_reps</code></td>
<td><code>None</code></td>
<td>Int &gt; zero.</td>
</tr>
<tr>
<td>3</td>
<td><code>mother</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ebounds</code></td>
<td><code>('emin', 'emax')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0).</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RepeatedCollisions(PhitsObject):
    &#34;&#34;&#34;Similar to `ForcedCollisions`, changes tally calculation in a region for low-probability interactions, \
    but with an eye towards rare, secondary-particle-producing reactions.&#34;&#34;&#34;
    name = &#34;repeated_collisions&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(fake=True), unique=True), 0),
              &#34;collision_reps&#34;: (None, PosInt(), 1),
              &#34;evaporation_reps&#34;:  (None, PosInt(), 2),
              &#34;mother&#34;: (None, List(Nuclide(fake=True)), 3),
              &#34;ebounds&#34;: ((&#34;emin&#34;, &#34;emax&#34;), (PosReal(), PosReal()), None),

              }

    superobjects = [&#34;cell&#34;]
    prelude = lambda self: (&#34;particles&#34;,
                            f&#34;mother = {len(self.mother)}&#34; if self.mother else &#34;&#34;,
                            (&#34;mother&#34;,),
                            &#34;ebounds&#34;, (&#34;reg&#34;, &#34;n-coll&#34;, &#34;n-evap&#34;))
    shape = ((&#34;cell&#34;, &#34;collision_reps&#34;, &#34;evaporation_reps&#34;),)

    group_by = lambda self: (self.particles, self.mother)
    separator = lambda self: self.section_title()
    max_groups = 6

    def restrictions(self):
        if self.collision_reps * self.evaporation_reps &lt;= 1 or self.collision_reps * self.evaporation_reps &gt;= 2_147_483_647:
            raise ValueError(f&#34;RepeatedCollisions&#39; product of repititions must be more than 1 as an int32;&#34;
                             f&#34; got collsion_reps={self.collision_reps} and evaporation_reps={self.evaporation_reps}.&#34;)
        if self.ebounds is not None and self.ebounds[0] &gt;= self.ebounds[1]:

            raise ValueError(f&#34;RepeatedCollisions&#39; ebounds must be ordered; got {self.ebounds}.&#34;)

    @classmethod
    def global_restrictions(self, type_divided):
        for rc in type_divided[&#34;repeated_collisions&#34;]:
            possible = set(map(lambda x: kf_encode(x[0]), rc.cell.material.composition))
            if any(kf_encode(x) not in possible for x in rc.mother):
                raise ValueError(f&#34;Integration problem: RepeatedCollisions&#39; mother nuclei must be among its cell&#39;s material&#39;s nuclei;&#34;
                                 f&#34; got {set(rc.mother) - possible} extra.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyphits.RepeatedCollisions.global_restrictions"><code class="name flex">
<span>def <span class="ident">global_restrictions</span></span>(<span>type_divided)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def global_restrictions(self, type_divided):
    for rc in type_divided[&#34;repeated_collisions&#34;]:
        possible = set(map(lambda x: kf_encode(x[0]), rc.cell.material.composition))
        if any(kf_encode(x) not in possible for x in rc.mother):
            raise ValueError(f&#34;Integration problem: RepeatedCollisions&#39; mother nuclei must be among its cell&#39;s material&#39;s nuclei;&#34;
                             f&#34; got {set(rc.mother) - possible} extra.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyphits.RepeatedCollisions.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.collision_reps * self.evaporation_reps &lt;= 1 or self.collision_reps * self.evaporation_reps &gt;= 2_147_483_647:
        raise ValueError(f&#34;RepeatedCollisions&#39; product of repititions must be more than 1 as an int32;&#34;
                         f&#34; got collsion_reps={self.collision_reps} and evaporation_reps={self.evaporation_reps}.&#34;)
    if self.ebounds is not None and self.ebounds[0] &gt;= self.ebounds[1]:

        raise ValueError(f&#34;RepeatedCollisions&#39; ebounds must be ordered; got {self.ebounds}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.SimpleConic"><code class="flex name class">
<span>class <span class="ident">SimpleConic</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An ellipsoid, hyperboloid, or paraboloid parallel to an axis, of the mathematical form
(A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+2D(x-x0)+2E(y-y0)+2F(z-z0)+G = 0).Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>quadratic</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>linear</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>constant</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>3</td>
<td><code>center</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleConic(PhitsObject): # ellipsoid, hyperboloid, or paraboloid parallel to an axis of the form
                   # A(x-x0)^2+B(y-y0)^2+C(z-z0)^2+2D(x-x0)+2E(y-y0)+2F(z-z0)+G = 0
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;quadratic&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;linear&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;constant&#34;: (None, Real(), 2),
                       &#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 3)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;SQ&#34;, &#34;quadratic&#34;, &#34;linear&#34;, &#34;constant&#34;, &#34;center&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A sphere of radius R centered on (x0, y0, z0).Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>radius</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>1</td>
<td><code>center</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sphere(PhitsObject):
    &#34;A sphere of radius R centered on (x0, y0, z0).&#34;
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;radius&#34;: (None, PosReal(), 0),
                       &#34;center&#34;: (None, Tuple(Real(), Real(), Real()), 1)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;,
                           &#34;SPH&#34;, f&#34;{self.center[0]}&#34;, f&#34;{self.center[1]}&#34;, f&#34;{self.center[2]}&#34;, &#34;radius&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Spherical"><code class="flex name class">
<span>class <span class="ident">Spherical</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A spherical or spherical-shell solid source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>center</code></td>
<td><code>('x0', 'y0', 'z0')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>r_in</code></td>
<td><code>r1</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>r_out</code></td>
<td><code>r2</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'all': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>resample_cutoff</code></td>
<td><code>isbias</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spherical(PhitsObject):
    &#34;&#34;&#34;A spherical or spherical-shell solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;center&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;r_in&#34;: (&#34;r1&#34;, PosReal(), None),
                       &#34;r_out&#34;: (&#34;r2&#34;, PosReal(), None),
                       # &#34;elevation_bounds&#34;: ((&#34;ag1&#34;, &#34;ag2&#34;), (Real(), Real()), None),
                       # &#34;azimuth_bounds&#34;: ((&#34;pg1&#34;, &#34;pg2&#34;), (Real(), Real()), None),
                       &#34;elevation&#34;: (&#34;dir&#34;, OneOf(RealBetween(0.0, 1.0), FinBij({&#34;all&#34;: &#34;all&#34;}), IsA(AngleDistribution)), None),
                       # TODO: this elevation and this elevation only doesn&#39;t work if I set FinBij({&#34;isotropic&#34;: &#34;all&#34;}).
                       &#34;resample_cutoff&#34;: (&#34;isbias&#34;, Choice10(), None),
                       &#34;spectrum&#34;: (None, IsA(EnergyDistribution), 1)}
    shape = lambda self: (&#34;s-type = 9&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;center&#34;, &#34;r_in&#34;, &#34;r_out&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;resample_cutoff&#34;, (&#34;spectrum&#34;,))

    def restrictions(self):
        if (self.elevation == &#34;isotropic&#34; and self.r_in is not None and (self.r_out is None or self.r_out == 0)) \
           or (self.elevation == &#34;isotropic&#34; and self.r_in is not None and self.r_out is not None and self.r_in &lt;= self.r_out):
            raise ValueError(&#34;Spherical sources with isotropic elevation must have greater inner radius than outer radius;&#34;
                             f&#34;got r_in={self.r_in} and r_out={self.r_out}.&#34;)


        if (self.elevation != &#34;isotropic&#34; and self.r_in is not None and (self.r_out is None or self.r_out == 0)) \
           or (self.elevation != &#34;isotropic&#34; and self.r_in is not None and self.r_out is not None and self.r_in &gt; self.r_out):
            raise ValueError(&#34;Spherical sources that specify an inner radius must also specify a greater outer radius;&#34;
                             f&#34;got r_in={self.r_in} and r_out={self.r_out}.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Spherical.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if (self.elevation == &#34;isotropic&#34; and self.r_in is not None and (self.r_out is None or self.r_out == 0)) \
       or (self.elevation == &#34;isotropic&#34; and self.r_in is not None and self.r_out is not None and self.r_in &lt;= self.r_out):
        raise ValueError(&#34;Spherical sources with isotropic elevation must have greater inner radius than outer radius;&#34;
                         f&#34;got r_in={self.r_in} and r_out={self.r_out}.&#34;)


    if (self.elevation != &#34;isotropic&#34; and self.r_in is not None and (self.r_out is None or self.r_out == 0)) \
       or (self.elevation != &#34;isotropic&#34; and self.r_in is not None and self.r_out is not None and self.r_in &gt; self.r_out):
        raise ValueError(&#34;Spherical sources that specify an inner radius must also specify a greater outer radius;&#34;
                         f&#34;got r_in={self.r_in} and r_out={self.r_out}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Spheroid"><code class="flex name class">
<span>class <span class="ident">Spheroid</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An ellipsoid of revolution given by two foci and an axis length (major is positive, minor is negative).Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>focus1</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>focus2</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>major_axis</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spheroid(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;focus1&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;focus2&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;major_axis&#34;: (None, Real(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;ELL&#34;, &#34;focus1&#34;, &#34;focus2&#34;, &#34;major_axis&#34;),)
    def restrictions(self):
        if self.focus1 == self.focus2:
            raise ValueError(f&#34;Spheroid must have distinct foci; got focus1={self.focus1} and focus2={self.focus2}.&#34;)

        if self.major_axis == 0:
            raise ValueError(&#34;Spheroid must have a nonzero major axis length.&#34;)

        if self.major_axis - np.linalg.norm(np.array(self.focus1) - np.array(self.focus2)) &lt;= 0:
            raise ValueError(&#34;Spheroid must have nonzero major axis length larger than the distance betwen its foci;&#34;
                             f&#34; got major_axis={self.major_axis}, focus1={self.focus1}, and focus2={self.focus2}.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Spheroid.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.focus1 == self.focus2:
        raise ValueError(f&#34;Spheroid must have distinct foci; got focus1={self.focus1} and focus2={self.focus2}.&#34;)

    if self.major_axis == 0:
        raise ValueError(&#34;Spheroid must have a nonzero axis length.&#34;)

    if self.major_axis - np.linalg.norm(np.array(self.focus1) - np.array(self.focus2)) &lt;= 0:
        raise ValueError(&#34;Spheroid must have nonzero axis length larger than the distance betwen its foci;&#34;
                         f&#34; got major_axis={self.major_axis}, focus1={self.focus1}, and focus2={self.focus2}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.SuperMirror"><code class="flex name class">
<span>class <span class="ident">SuperMirror</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables calculation of low-energy neutron super-mirror reflections off the boundary between two <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code>s via an empirical formula.
Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>into</code></td>
<td><code>r-in</code></td>
<td>An instance of Cell.</td>
</tr>
<tr>
<td>1</td>
<td><code>from</code></td>
<td><code>r-out</code></td>
<td>An instance of Cell.</td>
</tr>
<tr>
<td>2</td>
<td><code>reflection_surface</code></td>
<td><code>(None, None)</code></td>
<td>A tuple (either an instance of Plane, an instance of PointPlane, an instance of ParallelPlane, an instance of Sphere, an instance of Cylinder, an instance of Cone, an instance of SimpleConic, an instance of GeneralConic, an instance of Box, an instance of EllipticalCylinder, an instance of Spheroid, an instance of Wedge, or an instance of TetrahedronBox, either an instance of Plane, an instance of PointPlane, an instance of ParallelPlane, an instance of Sphere, an instance of Cylinder, an instance of Cone, an instance of SimpleConic, an instance of GeneralConic, an instance of Box, an instance of EllipticalCylinder, an instance of Spheroid, an instance of Wedge, or an instance of TetrahedronBox).</td>
</tr>
<tr>
<td>3</td>
<td><code>material_constant</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>4</td>
<td><code>reflectivity</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>5</td>
<td><code>critical_q</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>6</td>
<td><code>falloff_rate</code></td>
<td><code>None</code></td>
<td>Float.</td>
</tr>
<tr>
<td>7</td>
<td><code>cutoff_width</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SuperMirror(PhitsObject):
    &#34;&#34;&#34;Enables calculation of low-energy neutron super-mirror reflections off the boundary between two `Cell`s via an empirical formula.\
    &#34;&#34;&#34;
    name = &#34;super_mirror&#34;
    syntax = {&#34;into&#34;: (&#34;r-in&#34;, IsA(Cell, index=True), 0),
              &#34;from&#34;: (&#34;r-out&#34;, IsA(Cell, index=True), 1),
              &#34;reflection_surface&#34;: ((None, None), (_surface_spec, _surface_spec), 2),
              &#34;material_constant&#34;: (None, Real(), 3),
              &#34;reflectivity&#34;: (None, Real(), 4),
              &#34;critical_q&#34;: (None, Real(), 5),
              &#34;falloff_rate&#34;: (None, Real(), 6),
              &#34;cutoff_width&#34;: (None, PosReal(), 7)}

    prelude = ((&#34;r-in&#34;, &#34;r-out&#34;, &#34;mm&#34;, &#34;r0&#34;, &#34;qc&#34;, &#34;am&#34;, &#34;wm&#34;),)
    shape = ((&#34;reflection_surface&#34;, &#34;material_constant&#34;, &#34;reflectivity&#34;, &#34;critical_q&#34;, &#34;falloff_rate&#34;, &#34;cutoff_width&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.SurfaceSource"><code class="flex name class">
<span>class <span class="ident">SurfaceSource</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A solid source defined by some part of a surface.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
<tr>
<td>2</td>
<td><code>surface</code></td>
<td><code>suf</code></td>
<td>Either an instance of Plane, an instance of PointPlane, an instance of ParallelPlane, an instance of Sphere, an instance of Cylinder, an instance of Cone, an instance of SimpleConic, an instance of GeneralConic, an instance of Box, an instance of EllipticalCylinder, an instance of Spheroid, an instance of Wedge, or an instance of TetrahedronBox.</td>
</tr>
<tr>
<td>3</td>
<td><code>cut</code></td>
<td><code>cut</code></td>
<td>A list of values, each of which is either an instance of Plane, an instance of PointPlane, an instance of ParallelPlane, an instance of Sphere, an instance of Cylinder, an instance of Cone, an instance of SimpleConic, an instance of GeneralConic, an instance of Box, an instance of EllipticalCylinder, an instance of Spheroid, an instance of Wedge, or an instance of TetrahedronBox.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurfaceSource(PhitsObject):
    &#34;&#34;&#34;A solid source defined by some part of a surface.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;surface&#34;: (&#34;suf&#34;, _surface_spec, 2),
                               &#34;cut&#34;: (&#34;cut&#34;, List(_surface_spec, max_len=8), 3)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 26&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;surface&#34;, &#34;cut&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Tetrahedral"><code class="flex name class">
<span>class <span class="ident">Tetrahedral</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code> that's a box filled with tetrahedrons from a file. Extremely computationally efficient.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>regions</code></td>
<td><code>None</code></td>
<td>An instance of TetrahedronBox.</td>
</tr>
<tr>
<td>1</td>
<td><code>material</code></td>
<td><code>None</code></td>
<td>An instance of Material.</td>
</tr>
<tr>
<td>1</td>
<td><code>tet_format</code></td>
<td><code>None</code></td>
<td>One of the keys in {'tetgen': 'tetgen', 'NASTRAN': 'NASTRAN'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>2</td>
<td><code>density</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td>2</td>
<td><code>tet_file</code></td>
<td><code>None</code></td>
<td>A valid file name.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>magnetic_field</code></td>
<td><code>None</code></td>
<td>Either an instance of MagneticField, or an instance of NeutronMagneticField.</td>
</tr>
<tr>
<td><code>electromagnetic_field</code></td>
<td><code>None</code></td>
<td>Either , or an instance of ElectromagneticField.</td>
</tr>
<tr>
<td><code>delta_ray</code></td>
<td><code>None</code></td>
<td>An instance of DeltaRay.</td>
</tr>
<tr>
<td><code>track_structure</code></td>
<td><code>None</code></td>
<td>An instance of TrackStructure.</td>
</tr>
<tr>
<td><code>elastic_option</code></td>
<td><code>None</code></td>
<td>An instance of ElasticOption.</td>
</tr>
<tr>
<td><code>importance</code></td>
<td><code>None</code></td>
<td>An instance of Importance.</td>
</tr>
<tr>
<td><code>weight_window</code></td>
<td><code>None</code></td>
<td>An instance of WeightWindow.</td>
</tr>
<tr>
<td><code>ww_bias</code></td>
<td><code>None</code></td>
<td>An instance of WWBias.</td>
</tr>
<tr>
<td><code>forced_collisions</code></td>
<td><code>None</code></td>
<td>An instance of ForcedCollisions.</td>
</tr>
<tr>
<td><code>repeated_collisions</code></td>
<td><code>None</code></td>
<td>An instance of RepeatedCollisions.</td>
</tr>
<tr>
<td><code>reg_name</code></td>
<td><code>None</code></td>
<td>An instance of RegionName.</td>
</tr>
<tr>
<td><code>counter</code></td>
<td><code>None</code></td>
<td>An instance of Counter.</td>
</tr>
<tr>
<td><code>timer</code></td>
<td><code>None</code></td>
<td>An instance of Timer.</td>
</tr>
<tr>
<td><code>volume</code></td>
<td><code>VOL</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>temperature</code></td>
<td><code>TMP</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>TRCL</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>scale_factor</code></td>
<td><code>TSFAC</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tetrahedral(PhitsObject):
    &#34;&#34;&#34;A `Cell` that&#39;s a box filled with tetrahedrons from a file. Extremely computationally efficient.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, IsA(TetrahedronBox, index=True), 0),
                              &#34;material&#34;: (None, IsA(Material, index=True), 1),
                              &#34;density&#34;: (None, PosReal(), 2),
                              &#34;tet_format&#34;: (None, FinBij({&#34;tetgen&#34;: &#34;tetgen&#34;, &#34;NASTRAN&#34;: &#34;NASTRAN&#34;}), 1),
                              &#34;tet_file&#34;: (None, Path(), 2),
                              &#34;scale_factor&#34;: (&#34;TSFAC&#34;, PosReal(), None)}

    shape = lambda self: ((&#34;self&#34;, &#34;material&#34;, &#34;density&#34;, &#34;regions&#34;, &#34;\\&#34;),
                          &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;LAT=3\\&#34;,
                          f&#34;tfile={self.tet_file}&#34; if self.tet_format == &#34;tetgen&#34; else f&#34;nfile={self.tet_file}&#34;, &#34;scale_factor&#34;)

    subobjects = set(_subobject_syntax.keys())

    # def restrictions(self):
    #     if len(self.regions) != 1:
    #         raise ValueError(f&#34;Tetrahedral cells may have only one TetrahedronBox region; got {self.regions}&#34;)
        # if self.forced_collisions is not None and self.repeated_collisions is not None:
        #     raise ValueError(f&#34;Cannot set both forced_collisions and repeated_collisions on a Tetrahedral cell.&#34;)

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r
    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.TetrahedralSource"><code class="flex name class">
<span>class <span class="ident">TetrahedralSource</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="pyphits.Tetrahedral" href="#pyphits.Tetrahedral">Tetrahedral</a></code>ly-defined solid source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
<tr>
<td>2</td>
<td><code>cell</code></td>
<td><code>tetreg</code></td>
<td>An instance of Tetrahedral.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TetrahedralSource(PhitsObject): # TODO: subobjects
    &#34;&#34;&#34;A `Tetrahedral`ly-defined solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;cell&#34;: (&#34;tetreg&#34;, IsA(Tetrahedral, index=True), 2)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 24&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;cell&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;, &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.TetrahedronBox"><code class="flex name class">
<span>class <span class="ident">TetrahedronBox</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An especially simple <code><a title="pyphits.Box" href="#pyphits.Box">Box</a></code> whose sides are parallel to the axes; required as the surface containing <code><a title="pyphits.Tetrahedral" href="#pyphits.Tetrahedral">Tetrahedral</a></code>'s
tetrahedrons.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>xrange</code></td>
<td><code>(None, None)</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>yrange</code></td>
<td><code>(None, None)</code></td>
<td>A tuple (float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>zrange</code></td>
<td><code>(None, None)</code></td>
<td>A tuple (float, float).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TetrahedronBox(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;xrange&#34;: ((None, None), Interval(), 0),
                               &#34;yrange&#34;: ((None, None), Interval(), 1),
                               &#34;zrange&#34;: ((None, None), Interval(), 2)}

    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                            (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                            &#34;transform&#34;, &#34;RPP&#34;, &#34;xrange&#34;, &#34;yrange&#34;, &#34;zrange&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.TetrahedronBox.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.xrange[0] &gt;= self.xrange[1] or self.yrange[0] &gt;= self.yrange[1] or self.zrange[0] &gt;= self.zrange[1]:
        raise ValueError(&#34;EllipticalCylinder must have well-formed range intevals;&#34;
                         f&#34; got xrange={self.xrange}, yrange={self.yrange}, zrange={self.zrange}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.TimeDistribution"><code class="flex name class">
<span>class <span class="ident">TimeDistribution</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An arbitrary distribution of source weights over time.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>bins</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is (float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td>1</td>
<td><code>last_bin</code></td>
<td><code>None</code></td>
<td>Float &gt; 0.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>particle_production</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is float &gt; 0.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeDistribution(PhitsObject):
    &#34;&#34;&#34;An arbitrary distribution of source weights over time.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = {&#34;bins&#34;: (None, List(Tuple(PosReal(), PosReal())), 0),
              &#34;last_bin&#34;: (None, PosReal(), 1),
              &#34;particle_production&#34;: (None, List(PosReal()), None)}

    shape = lambda slf: (&#34;t-type = 4&#34; if slf.particle_production else &#34;t-type = 3&#34;,
                         f&#34;ntt = {len(slf.bins)}&#34;,
                         &#34;\n&#34;.join(zastr(j[0]) + &#34; &#34; + str(j[1]) for j in slf.bins),
                         (&#34;last_bin&#34;,),
                         &#34;o-type = 1\n&#34; + &#34; &#34;.join((str(i) for i in slf.particle_production)) if slf.particle_production else &#34;&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Timer"><code class="flex name class">
<span>class <span class="ident">Timer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the way time-of-flight is calculated within a regionRequired arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>entry</code></td>
<td><code>None</code></td>
<td>One of the keys in {'zero': -1, 'nothing': 0, 'stop': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>2</td>
<td><code>exit</code></td>
<td><code>None</code></td>
<td>One of the keys in {'zero': -1, 'nothing': 0, 'stop': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>3</td>
<td><code>collision</code></td>
<td><code>None</code></td>
<td>One of the keys in {'zero': -1, 'nothing': 0, 'stop': 1}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>4</td>
<td><code>reflection</code></td>
<td><code>None</code></td>
<td>One of the keys in {'zero': -1, 'nothing': 0, 'stop': 1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timer(PhitsObject):
    &#34;&#34;&#34;Configures the way time-of-flight is calculated within a region&#34;&#34;&#34;
    name = &#34;timer&#34;
    syntax = {&#34;entry&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 1),
              &#34;exit&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 2),
              &#34;collision&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 3),
              &#34;reflection&#34;: (None, FinBij({&#34;zero&#34;: -1, &#34;nothing&#34;: 0, &#34;stop&#34;: 1}), 4),
              }
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;in&#34;, &#34;out&#34;, &#34;coll&#34;, &#34;ref&#34;),)
    shape = ((&#34;cell&#34;, &#34;entry&#34;, &#34;exit&#34;, &#34;collision&#34;, &#34;reflection&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Torus"><code class="flex name class">
<span>class <span class="ident">Torus</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A torus parallel to an axis, of the mathematical form
((x - x_0)^2/B^2 + (\sqrt{(y - y_0)^2 + (z - z_0)^2} - A)^2 - 1 = 0) (where the variable quantities may be permuted).Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>axis</code></td>
<td><code>None</code></td>
<td>One of the keys in {'x': 'X', 'y': 'Y', 'z': 'Z'}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td>1</td>
<td><code>center</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>2</td>
<td><code>scales</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float &gt; 0, float &gt; 0).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Torus(PhitsObject): # torus parallel to an axis of the form
             # (axisvar - axis0)^2/B^2 + (quadrature(&lt;non-axis displacements&gt;) - A)^2 - 1 = 0
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;axis&#34;: (None, FinBij({&#34;x&#34;: &#34;X&#34;, &#34;y&#34;: &#34;Y&#34;, &#34;z&#34;:&#34;Z&#34;}), 0),
                       &#34;center&#34;: ((None, None, None), (Real(), Real(), Real()), 1),
                       &#34;scales&#34;: ((None, None, None), (PosReal(), PosReal(), PosReal()), 2)}
    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           f&#34;T{self.axis}&#34;, &#34;center&#34;, &#34;scales&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.Torus.restrictions"><code class="name flex">
<span>def <span class="ident">restrictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restrictions(self):
    if self.scales[0] == 0 or self.scales[1] == 0 or self.scales[2] == 0:
        raise ValueError(f&#34;Torus&#39;s scales must be nonzero; got {self.scales}&#34;)
    # if self.transform is not None and not self.transform.rotate_first: # skew
    #     raise ValueError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.TrackStructure"><code class="flex name class">
<span>class <span class="ident">TrackStructure</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Cell-by-cell setting of the track-structure model used for electrons/positrons.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>model</code></td>
<td><code>None</code></td>
<td>One of the keys in {'none': 0, 'general': -1, 'optimized': 1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrackStructure(PhitsObject):
    &#34;&#34;&#34;Cell-by-cell setting of the track-structure model used for electrons/positrons.&#34;&#34;&#34;
    name = &#34;track_structure&#34;
    syntax = {&#34;model&#34;: (None, FinBij({&#34;none&#34;: 0, &#34;general&#34;: -1, &#34;optimized&#34;: 1}), 0)}
    superobjects = [&#34;cell&#34;]
    prelude = ((&#34;reg&#34;, &#34;mID&#34;),)
    shape = lambda self: ((&#34;cell&#34;, &#34;model&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Transform"><code class="flex name class">
<span>class <span class="ident">Transform</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An (\mathbb{R}^3) isometry represented by a translation vector and a rotation matrix.
Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>translation</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>rotation</code></td>
<td><code>None</code></td>
<td>(float, float, float).</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rotate_first</code></td>
<td><code>None</code></td>
<td>One of the keys in {True: 2, False: -2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>units</code></td>
<td><code>None</code></td>
<td>One of the keys in {'degrees': 'degrees', 'radians': 'radians'}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transform(PhitsObject): #
    &#34;&#34;&#34;An \\(\\mathbb{R}^3\\) isometry represented by a translation vector and a rotation matrix.
    &#34;&#34;&#34;
    name = &#34;transform&#34;
    syntax = {&#34;translation&#34;: (None, Tuple(Real(), Real(), Real()), 0),
              &#34;rotation&#34;: (None, Tuple(Real(), Real(), Real()), 1),
              &#34;rotate_first&#34;: (None, FinBij({True: 2, False: -2}), None, -2),
              &#34;units&#34;: (None, FinBij({&#34;degrees&#34;: &#34;degrees&#34;, &#34;radians&#34;: &#34;radians&#34;}), None)}
    shape = lambda self: ((f&#34;*TR{self.index}&#34; if self.units == &#34;degrees&#34; else f&#34;TR{self.index}&#34;,
                           &#34; &#34;.join(str(i) for i in self.translation),
                           &#34; &#34;.join(str(i) for i in self.rotation),
                           &#34;0 0 0 0 0 0&#34;,
                           &#34;rotate_first&#34;),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.TriangularPrism"><code class="flex name class">
<span>class <span class="ident">TriangularPrism</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A triangular-prism solid source.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>projectile</code></td>
<td><code>proj</code></td>
<td>A list of values, each of which is either a particle name, or a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208.</td>
</tr>
<tr>
<td>1</td>
<td><code>spectrum</code></td>
<td><code>None</code></td>
<td>An instance of EnergyDistribution.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spin</code></td>
<td><code>('sx', 'sy', 'sz')</code></td>
<td>A tuple (float &gt; 0, float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>('reg', 'ntmax')</code></td>
<td>A tuple (an instance of Cell, int &gt; zero).</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>trcl</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>wgt</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>charge_override</code></td>
<td><code>izst</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>counter_start</code></td>
<td><code>('cnt(1)', 'cnt(2)', 'cnt(3)')</code></td>
<td>A tuple (int &gt; zero, int &gt; zero, int &gt; zero).</td>
</tr>
<tr>
<td><code>fissile</code></td>
<td><code>ispfs</code></td>
<td>One of the keys in {False: 0, 'fissions': 1, 'neutrons': 2}, with the value being the corresponding PHITS value.</td>
</tr>
<tr>
<td><code>origin</code></td>
<td><code>('x0', 'y0', 'z0')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>side1</code></td>
<td><code>('x1', 'y1', 'z1')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>side2</code></td>
<td><code>('x2', 'y2', 'z2')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>extrusion</code></td>
<td><code>('x3', 'y3', 'z3')</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td><code>attenuation</code></td>
<td><code>exa</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>elevation</code></td>
<td><code>dir</code></td>
<td>Either float between 0.0 and 1.0, one of the keys in {'isotropic': 'all'}, with the value being the corresponding PHITS value, or an instance of AngleDistribution.</td>
</tr>
<tr>
<td><code>azimuth</code></td>
<td><code>phi</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>dispersion</code></td>
<td><code>dom</code></td>
<td>Either float &gt; 0, or one of the keys in {'cos^2': -1}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriangularPrism(PhitsObject):
    &#34;&#34;&#34;A triangular-prism solid source.&#34;&#34;&#34;
    name = &#34;source&#34;
    syntax = _source_common | {&#34;origin&#34;: ((&#34;x0&#34;, &#34;y0&#34;, &#34;z0&#34;), (Real(), Real(), Real()), None),
                       &#34;side1&#34;: ((&#34;x1&#34;, &#34;y1&#34;, &#34;z1&#34;), (Real(), Real(), Real()), None),
                       &#34;side2&#34;: ((&#34;x2&#34;, &#34;y2&#34;, &#34;z2&#34;), (Real(), Real(), Real()), None),
                       &#34;extrusion&#34;: ((&#34;x3&#34;, &#34;y3&#34;, &#34;z3&#34;), (Real(), Real(), Real()), None),
                       &#34;attenuation&#34;: (&#34;exa&#34;, PosReal(), None)} | _source_semi_common
    shape = lambda self: (&#34;s-type = 20&#34;, &#34;projectile&#34;, &#34;spin&#34;, &#34;mask&#34;, &#34;transform&#34;, &#34;weight&#34;, &#34;counter_start&#34;,
                          &#34;charge_override&#34;, &#34;fissile&#34;, &#34;origin&#34;, &#34;side1&#34;, &#34;side2&#34;, &#34;extrusion&#34;, &#34;attenuation&#34;,
                          (f&#34;dir = data\n{self.elevation.definition()}&#34; if isinstance(self.elevation, AngleDistribution) \
                           else f&#34;dir = {self.elevation}&#34;) if self.elevation is not None else &#34;&#34;, &#34;azimuth&#34;,
                          &#34;dispersion&#34;, (&#34;spectrum&#34;,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Void"><code class="flex name class">
<span>class <span class="ident">Void</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code> with no material, just vacuum.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>regions</code></td>
<td><code>None</code></td>
<td>A recursive tuple of surfaces with set operation semantics: "~" negates what follows, infix "</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>magnetic_field</code></td>
<td><code>None</code></td>
<td>Either an instance of MagneticField, or an instance of NeutronMagneticField.</td>
</tr>
<tr>
<td><code>electromagnetic_field</code></td>
<td><code>None</code></td>
<td>Either , or an instance of ElectromagneticField.</td>
</tr>
<tr>
<td><code>delta_ray</code></td>
<td><code>None</code></td>
<td>An instance of DeltaRay.</td>
</tr>
<tr>
<td><code>track_structure</code></td>
<td><code>None</code></td>
<td>An instance of TrackStructure.</td>
</tr>
<tr>
<td><code>elastic_option</code></td>
<td><code>None</code></td>
<td>An instance of ElasticOption.</td>
</tr>
<tr>
<td><code>importance</code></td>
<td><code>None</code></td>
<td>An instance of Importance.</td>
</tr>
<tr>
<td><code>weight_window</code></td>
<td><code>None</code></td>
<td>An instance of WeightWindow.</td>
</tr>
<tr>
<td><code>ww_bias</code></td>
<td><code>None</code></td>
<td>An instance of WWBias.</td>
</tr>
<tr>
<td><code>forced_collisions</code></td>
<td><code>None</code></td>
<td>An instance of ForcedCollisions.</td>
</tr>
<tr>
<td><code>repeated_collisions</code></td>
<td><code>None</code></td>
<td>An instance of RepeatedCollisions.</td>
</tr>
<tr>
<td><code>reg_name</code></td>
<td><code>None</code></td>
<td>An instance of RegionName.</td>
</tr>
<tr>
<td><code>counter</code></td>
<td><code>None</code></td>
<td>An instance of Counter.</td>
</tr>
<tr>
<td><code>timer</code></td>
<td><code>None</code></td>
<td>An instance of Timer.</td>
</tr>
<tr>
<td><code>volume</code></td>
<td><code>VOL</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>temperature</code></td>
<td><code>TMP</code></td>
<td>Float &gt; 0.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>TRCL</code></td>
<td>An instance of Transform.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Void(PhitsObject):
    &#34;&#34;&#34;A `Cell` with no material, just vacuum.&#34;&#34;&#34;
    name = &#34;cell&#34;
    syntax = _cell_common_syntax | {&#34;regions&#34;: (None, RegionTuple(_surface_spec), 0)}
    shape = lambda self: ((&#34;self&#34;, &#34;0&#34;, &#34;regions&#34;, &#34;\\&#34;), &#34;volume\\&#34;, &#34;temperature\\&#34;, &#34;transform\\&#34;, &#34;&#34;)
    subobjects = set(_subobject_syntax.keys())

    def __or__(self, other): # Union of cells; adopts leftmost&#39;s properties
        r = deepcopy(self)
        setattr(r, &#34;regions&#34;, (self.regions,) + (&#34;|&#34;,) + (other.regions,))
        return r

    def __invert__(self): # Set complement of cell; new cell has old properties
        r = deepcopy(self)
        r.regions = (&#34;~&#34;, (self.regions,))
        return r

    def __and__(self, other): # Intersection of cells; drops properties
        r = deepcopy(self)
        r.regions = (self.regions,) + (other.regions,)
        return r

    def __rshift__(self, other): # returns other&#39;s regions with self&#39;s properties
        r = deepcopy(self)
        r.regions = other.regions
        return r

    def __lshift__(self, other): # returns self&#39;s region with other&#39;s properties
        r = deepcopy(other)
        r.regions = self.regions
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.WWBias"><code class="flex name class">
<span>class <span class="ident">WWBias</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Some magic with regards to the "variance reduction tecnique.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td>1</td>
<td><code>biases</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is (float &gt; 0, float &gt; 0).</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WWBias(PhitsObject):
    &#34;&#34;&#34;Some magic with regards to the &#34;variance reduction tecnique.&#34;&#34;&#34;
    name = &#34;ww_bias&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;biases&#34;: (None, List(Tuple(PosReal(), PosReal())), 1),
              }
    superobjects = [&#34;cell&#34;]
    prelude = lambda self: (&#34;particles&#34;, f&#34;eng = {len(self.biases)}&#34;, &#34; &#34;.join(map(lambda t: str(t[0]), self.biases)),
                            (&#34;reg&#34;, &#34; &#34;.join(f&#34;wwb{i}&#34; for i in range(1, len(self.biases) + 1))))
    shape = lambda self: ((&#34;cell&#34;, &#34; &#34;.join(map(lambda t: str(t[1]), self.biases))),)
    group_by = lambda self: self.particles
    separator = lambda self: self.section_title()
    max_groups = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.Wedge"><code class="flex name class">
<span>class <span class="ident">Wedge</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A (right-triangle) wedge shape given by a tip point and three orthogonal vectors forming the sides.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>tip</code></td>
<td><code>(None, None, None)</code></td>
<td>A tuple (float, float, float).</td>
</tr>
<tr>
<td>1</td>
<td><code>sides</code></td>
<td><code>None</code></td>
<td>An orthogonal matrix (AA^T = I) representing a rotation.</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<table>
<thead>
<tr>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflective</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>white</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>None</code></td>
<td>An instance of Transform.</td>
</tr>
<tr>
<td><code>inside</code></td>
<td><code>None</code></td>
<td>Either True or False.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wedge(PhitsObject):
    name = &#34;surface&#34;
    syntax = surface_common | {&#34;tip&#34;: ((None, None, None), (Real(), Real(), Real()), 0),
                       &#34;sides&#34;: (None, OrthogonalMatrix(), 1)}


    shape = lambda self: ((f&#34;*{self.index}&#34; if self.reflective else
                           (f&#34;+{self.index}&#34; if self.white else f&#34;{self.index}&#34;),
                           &#34;transform&#34;, &#34;WED&#34;, &#34;tip&#34;, &#34; &#34;.join(&#34; &#34;.join(str(i) for i in j) for j in self.sides)),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyphits.WeightWindow"><code class="flex name class">
<span>class <span class="ident">WeightWindow</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the tally weight of some particle(s) in a region a function of time or energy.Required arguments:</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Python name</th>
<th>PHITS name</th>
<th>Accepted value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>particles</code></td>
<td><code>part</code></td>
<td>A list of values, each of which is a particle name.</td>
</tr>
<tr>
<td>1</td>
<td><code>windows</code></td>
<td><code>None</code></td>
<td>A list of values, each of which is (float &gt; 0, float &gt; 0).</td>
</tr>
<tr>
<td>2</td>
<td><code>variable</code></td>
<td><code>None</code></td>
<td>One of the keys in {'energy': 'energy', 'time': 'time'}, with the value being the corresponding PHITS value.</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightWindow(PhitsObject):
    &#34;&#34;&#34;Makes the tally weight of some particle(s) in a region a function of time or energy.&#34;&#34;&#34;
    name = &#34;weight_window&#34;
    syntax = {&#34;particles&#34;: (&#34;part&#34;, List(Particle(), unique=True), 0),
              &#34;variable&#34;: (None, FinBij({&#34;energy&#34;: &#34;energy&#34;, &#34;time&#34;: &#34;time&#34;}), 2),
              &#34;windows&#34;: (None, List(Tuple(PosReal(), PosReal())), 1),
              }
    superobjects = [&#34;cell&#34;]
    prelude = lambda self: (&#34;mesh = reg&#34;, &#34;particles&#34;,
                            f&#34;eng = {len(self.windows)}&#34; if self.variable == &#34;energy&#34; else f&#34;tim = {len(self.windows)}&#34;,
                            &#34; &#34;.join(map(lambda t: str(t[0]), self.windows)),
                            (&#34;reg&#34;, &#34; &#34;.join(f&#34;ww{i}&#34; for i in range(1, len(self.windows) + 1))))
    shape = lambda self: ((&#34;cell&#34;, &#34; &#34;.join(map(lambda t: str(t[1]), self.windows))),)
    group_by = lambda self: (self.particles, self.variable)
    separator = lambda self: self.section_title()
    max_groups = 6

    @classmethod
    def global_restrictions(self, type_divided):
        all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;weight_window&#34;])))
        if len(set(all_particles)) &lt; len(all_particles):
            raise ValueError(&#34;Integration problem: all WeightWindows must have mutually disjoint lists of particles.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyphits.WeightWindow.global_restrictions"><code class="name flex">
<span>def <span class="ident">global_restrictions</span></span>(<span>type_divided)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def global_restrictions(self, type_divided):
    all_particles = list(it.chain.from_iterable(map(lambda x: x.particles, type_divided[&#34;weight_window&#34;])))
    if len(set(all_particles)) &lt; len(all_particles):
        raise ValueError(&#34;Integration problem: all WeightWindows must have mutually disjoint lists of particles.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyphits.valspec" href="valspec.html">pyphits.valspec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pyphits.readable_remapping" href="#pyphits.readable_remapping">readable_remapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyphits.interval" href="#pyphits.interval">interval</a></code></li>
<li><code><a title="pyphits.make_input" href="#pyphits.make_input">make_input</a></code></li>
<li><code><a title="pyphits.read_dump" href="#pyphits.read_dump">read_dump</a></code></li>
<li><code><a title="pyphits.run_phits" href="#pyphits.run_phits">run_phits</a></code></li>
<li><code><a title="pyphits.tuplified_lists" href="#pyphits.tuplified_lists">tuplified_lists</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyphits.AngleDistribution" href="#pyphits.AngleDistribution">AngleDistribution</a></code></h4>
<ul class="">
<li><code><a title="pyphits.AngleDistribution.restrictions" href="#pyphits.AngleDistribution.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.Beam" href="#pyphits.Beam">Beam</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Box" href="#pyphits.Box">Box</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Cell" href="#pyphits.Cell">Cell</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Cone" href="#pyphits.Cone">Cone</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Cone.restrictions" href="#pyphits.Cone.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.Conical" href="#pyphits.Conical">Conical</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Counter" href="#pyphits.Counter">Counter</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Cylinder" href="#pyphits.Cylinder">Cylinder</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Cylinder.restrictions" href="#pyphits.Cylinder.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.Cylindrical" href="#pyphits.Cylindrical">Cylindrical</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Cylindrical.restrictions" href="#pyphits.Cylindrical.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.DataMax" href="#pyphits.DataMax">DataMax</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.DeltaRay" href="#pyphits.DeltaRay">DeltaRay</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.DumpFluence" href="#pyphits.DumpFluence">DumpFluence</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.DumpProduction" href="#pyphits.DumpProduction">DumpProduction</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.DumpTime" href="#pyphits.DumpTime">DumpTime</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.ElasticOption" href="#pyphits.ElasticOption">ElasticOption</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.ElectromagneticField" href="#pyphits.ElectromagneticField">ElectromagneticField</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.EllipticalCylinder" href="#pyphits.EllipticalCylinder">EllipticalCylinder</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.EnergyDistribution" href="#pyphits.EnergyDistribution">EnergyDistribution</a></code></h4>
<ul class="">
<li><code><a title="pyphits.EnergyDistribution.restrictions" href="#pyphits.EnergyDistribution.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.ForcedCollisions" href="#pyphits.ForcedCollisions">ForcedCollisions</a></code></h4>
<ul class="">
<li><code><a title="pyphits.ForcedCollisions.global_restrictions" href="#pyphits.ForcedCollisions.global_restrictions">global_restrictions</a></code></li>
<li><code><a title="pyphits.ForcedCollisions.restrictions" href="#pyphits.ForcedCollisions.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.FragData" href="#pyphits.FragData">FragData</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Gaussian" href="#pyphits.Gaussian">Gaussian</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.GaussianSlices" href="#pyphits.GaussianSlices">GaussianSlices</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.GeneralConic" href="#pyphits.GeneralConic">GeneralConic</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Importance" href="#pyphits.Importance">Importance</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Importance.global_restrictions" href="#pyphits.Importance.global_restrictions">global_restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.MagneticField" href="#pyphits.MagneticField">MagneticField</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.MappedElectromagneticField" href="#pyphits.MappedElectromagneticField">MappedElectromagneticField</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.MappedMagneticField" href="#pyphits.MappedMagneticField">MappedMagneticField</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.MatNameColor" href="#pyphits.MatNameColor">MatNameColor</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.MatTimeChange" href="#pyphits.MatTimeChange">MatTimeChange</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Material" href="#pyphits.Material">Material</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Material.restrictions" href="#pyphits.Material.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.NeutronMagneticField" href="#pyphits.NeutronMagneticField">NeutronMagneticField</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.OuterVoid" href="#pyphits.OuterVoid">OuterVoid</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Parabolic" href="#pyphits.Parabolic">Parabolic</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Parabolic.restrictions" href="#pyphits.Parabolic.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.ParabolicSlices" href="#pyphits.ParabolicSlices">ParabolicSlices</a></code></h4>
<ul class="">
<li><code><a title="pyphits.ParabolicSlices.restrictions" href="#pyphits.ParabolicSlices.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.ParallelPlane" href="#pyphits.ParallelPlane">ParallelPlane</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Parameters" href="#pyphits.Parameters">Parameters</a></code></h4>
<ul class="two-column">
<li><code><a title="pyphits.Parameters.definition" href="#pyphits.Parameters.definition">definition</a></code></li>
<li><code><a title="pyphits.Parameters.empty" href="#pyphits.Parameters.empty">empty</a></code></li>
<li><code><a title="pyphits.Parameters.name" href="#pyphits.Parameters.name">name</a></code></li>
<li><code><a title="pyphits.Parameters.optional_args" href="#pyphits.Parameters.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.Parameters.required_args" href="#pyphits.Parameters.required_args">required_args</a></code></li>
<li><code><a title="pyphits.Parameters.restrictions" href="#pyphits.Parameters.restrictions">restrictions</a></code></li>
<li><code><a title="pyphits.Parameters.section_title" href="#pyphits.Parameters.section_title">section_title</a></code></li>
<li><code><a title="pyphits.Parameters.syntax" href="#pyphits.Parameters.syntax">syntax</a></code></li>
<li><code><a title="pyphits.Parameters.syntax_desc" href="#pyphits.Parameters.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.Parameters.syntax_for" href="#pyphits.Parameters.syntax_for">syntax_for</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.PhitsObject" href="#pyphits.PhitsObject">PhitsObject</a></code></h4>
<ul class="two-column">
<li><code><a title="pyphits.PhitsObject.definition" href="#pyphits.PhitsObject.definition">definition</a></code></li>
<li><code><a title="pyphits.PhitsObject.group_by" href="#pyphits.PhitsObject.group_by">group_by</a></code></li>
<li><code><a title="pyphits.PhitsObject.index" href="#pyphits.PhitsObject.index">index</a></code></li>
<li><code><a title="pyphits.PhitsObject.max_groups" href="#pyphits.PhitsObject.max_groups">max_groups</a></code></li>
<li><code><a title="pyphits.PhitsObject.name" href="#pyphits.PhitsObject.name">name</a></code></li>
<li><code><a title="pyphits.PhitsObject.names" href="#pyphits.PhitsObject.names">names</a></code></li>
<li><code><a title="pyphits.PhitsObject.optional_args" href="#pyphits.PhitsObject.optional_args">optional_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude" href="#pyphits.PhitsObject.prelude">prelude</a></code></li>
<li><code><a title="pyphits.PhitsObject.prelude_str" href="#pyphits.PhitsObject.prelude_str">prelude_str</a></code></li>
<li><code><a title="pyphits.PhitsObject.required_args" href="#pyphits.PhitsObject.required_args">required_args</a></code></li>
<li><code><a title="pyphits.PhitsObject.restrictions" href="#pyphits.PhitsObject.restrictions">restrictions</a></code></li>
<li><code><a title="pyphits.PhitsObject.section_title" href="#pyphits.PhitsObject.section_title">section_title</a></code></li>
<li><code><a title="pyphits.PhitsObject.separator" href="#pyphits.PhitsObject.separator">separator</a></code></li>
<li><code><a title="pyphits.PhitsObject.shape" href="#pyphits.PhitsObject.shape">shape</a></code></li>
<li><code><a title="pyphits.PhitsObject.subobjects" href="#pyphits.PhitsObject.subobjects">subobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.superobjects" href="#pyphits.PhitsObject.superobjects">superobjects</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax" href="#pyphits.PhitsObject.syntax">syntax</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_desc" href="#pyphits.PhitsObject.syntax_desc">syntax_desc</a></code></li>
<li><code><a title="pyphits.PhitsObject.syntax_for" href="#pyphits.PhitsObject.syntax_for">syntax_for</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.Plane" href="#pyphits.Plane">Plane</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Plane.restrictions" href="#pyphits.Plane.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.PointPlane" href="#pyphits.PointPlane">PointPlane</a></code></h4>
<ul class="">
<li><code><a title="pyphits.PointPlane.restrictions" href="#pyphits.PointPlane.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.Rectangular" href="#pyphits.Rectangular">Rectangular</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.RegionName" href="#pyphits.RegionName">RegionName</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.RepeatedCollisions" href="#pyphits.RepeatedCollisions">RepeatedCollisions</a></code></h4>
<ul class="">
<li><code><a title="pyphits.RepeatedCollisions.global_restrictions" href="#pyphits.RepeatedCollisions.global_restrictions">global_restrictions</a></code></li>
<li><code><a title="pyphits.RepeatedCollisions.restrictions" href="#pyphits.RepeatedCollisions.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.SimpleConic" href="#pyphits.SimpleConic">SimpleConic</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Sphere" href="#pyphits.Sphere">Sphere</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Spherical" href="#pyphits.Spherical">Spherical</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Spherical.restrictions" href="#pyphits.Spherical.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.Spheroid" href="#pyphits.Spheroid">Spheroid</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Spheroid.restrictions" href="#pyphits.Spheroid.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.SuperMirror" href="#pyphits.SuperMirror">SuperMirror</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.SurfaceSource" href="#pyphits.SurfaceSource">SurfaceSource</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Tetrahedral" href="#pyphits.Tetrahedral">Tetrahedral</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.TetrahedralSource" href="#pyphits.TetrahedralSource">TetrahedralSource</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.TetrahedronBox" href="#pyphits.TetrahedronBox">TetrahedronBox</a></code></h4>
<ul class="">
<li><code><a title="pyphits.TetrahedronBox.restrictions" href="#pyphits.TetrahedronBox.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.TimeDistribution" href="#pyphits.TimeDistribution">TimeDistribution</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Timer" href="#pyphits.Timer">Timer</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Torus" href="#pyphits.Torus">Torus</a></code></h4>
<ul class="">
<li><code><a title="pyphits.Torus.restrictions" href="#pyphits.Torus.restrictions">restrictions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.TrackStructure" href="#pyphits.TrackStructure">TrackStructure</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Transform" href="#pyphits.Transform">Transform</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.TriangularPrism" href="#pyphits.TriangularPrism">TriangularPrism</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Void" href="#pyphits.Void">Void</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.WWBias" href="#pyphits.WWBias">WWBias</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.Wedge" href="#pyphits.Wedge">Wedge</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.WeightWindow" href="#pyphits.WeightWindow">WeightWindow</a></code></h4>
<ul class="">
<li><code><a title="pyphits.WeightWindow.global_restrictions" href="#pyphits.WeightWindow.global_restrictions">global_restrictions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>