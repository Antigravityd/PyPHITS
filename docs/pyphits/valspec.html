<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyphits.valspec API documentation</title>
<meta name="description" content="Type definitions used to streamline: class definitions, error handling and reporting, and testing." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyphits.valspec</code></h1>
</header>
<section id="section-intro">
<p>Type definitions used to streamline: class definitions, error handling and reporting, and testing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Type definitions used to streamline: class definitions, error handling and reporting, and testing.&#34;&#34;&#34;

from functools import partial
from hypothesis.strategies import *
from hypothesis import assume
import re
from scipy.stats import ortho_group
import numpy as np
from numpy.linalg import det

# TODO: think about if the python() methods are necessary



class ValSpec():
    # in principle, this&#39;d be cleaner were it a class attribute.
    def __init__(self, strat):
        self.strat = strat
    def __or__(self, other):
        # TODO: think about if copying is necessary
        if isinstance(self, OneOf) and isinstance(other, OneOf):
            self.choices.append(other.choices)
            return self
        elif isinstance(self, OneOf) and not isinstance(other, OneOf):
            self.choices.append(other)
            return self
        elif not isinstance(self, OneOf) and isinstance(other, OneOf):
            other.choices.append(self)
            return other
        elif not isinstance(self, OneOf) and not isinstance(other, OneOf):
            return OneOf(self, other)


class Choice10(ValSpec):
    def __init__(self, c_style=False, true=True, false=False):
        super().__init__(one_of(just(false), just(true)))
        self.c_style = c_style
        self.true = true
        self.false = false

    def phits(self, val):
        if val == self.true:
            return 0 if self.c_style else 1
        elif val == self.false:
            return 1 if self.c_style else 0
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be either True or False; got {va}.&#34;), val)

    def python(self, val):
        if val == 0:
                return self.true if self.c_style else self.false
        elif val == 1:
            return self.false if self.c_style else self.true
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be either 0 or 1; got {va}.&#34;), val)

    def description(self):
        return f&#34;either {self.true} or {self.false}&#34;


class Integer(ValSpec):
    def __init__(self):
        super().__init__(integers())
    def phits(self, val):
        if isinstance(val, int):
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be an integer; got {va}.&#34;), val)

    def python(self, val):
        if val % 1 == 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be an integer; got {va}.&#34;), val)
    def description(self):
        return &#34;int&#34;

class Real(ValSpec):
    def __init__(self):
        super().__init__(floats(allow_nan=False, allow_infinity=False, allow_subnormal=False, width=16))
    def phits(self, val):
        if isinstance(val, float) or isinstance(val, int):
            return float(val)
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a float; got {va}.&#34;), val)

    def python(self, val):
        return val

    def description(self):
        return &#34;float&#34;

class PosInt(ValSpec):
    def __init__(self):
        super().__init__(integers(min_value=1))

    def phits(self, val):
        if isinstance(val, int) and val &gt; 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive integer; got {va}.&#34;), val)

    def python(self, val):
        if val &gt; 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be positive; got {va}.&#34;), val)

    def description(self):
        return &#34;int &gt; zero&#34;


class PosReal(ValSpec):
    def __init__(self):
        super().__init__(floats(min_value=0, exclude_min=True, allow_nan=False, allow_infinity=False, allow_subnormal=False,
                                width=16))
    def phits(self, val):
        if (isinstance(val, float) or isinstance(val, int)) and val &gt; 0:
            return float(val)
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive float; got {va}.&#34;), val)

    def python(self, val):
        if val &gt; 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be positive; got {va}.&#34;), val)

    def description(self):
        return &#34;float &gt; 0&#34;




class NegDisable(ValSpec):
    def __init__(self):
        super().__init__(one_of(none(), integers(min_value=0), floats(min_value=0, allow_nan=False, allow_infinity=False,
                                                                      allow_subnormal=False, width=16)))
    def phits(self, val):
        if isinstance(val, float) or isinstance(val, int) and val &gt;= 0:
            return val
        elif val is None:
            return -1.0
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive integer or None; got {va}.&#34;), val)

    def python(self, val):
        if val &gt; 0:
            return val
        else:
            return None

    def description(self):
        return &#34;either None or a number&#34;

class RealBetween(ValSpec):
    def __init__(self, start, stop):
        super().__init__(floats(min_value=start, max_value=stop, allow_nan=False, allow_infinity=False, allow_subnormal=False,
                                width=16))
        self.start = start
        self.stop = stop

    def phits(self, val):
        if isinstance(val, float) and (self.start is None or val &gt;= self.start) and (self.stop is None or val &lt;= self.stop):
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be a float between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)


    def python(self, val):
        if val &gt;= self.start and val &lt;= self.stop:
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be a float between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)

    def description(self):
        return f&#34;float between {self.start} and {self.stop}&#34;

class Between(ValSpec):
    def __init__(self, start, stop):
        super().__init__(integers(min_value=start, max_value=stop))
        self.start = start
        self.stop = stop

    def phits(self, val):
        if isinstance(val, int) and val &gt;= self.start and val &lt;= self.stop:
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be an integer between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)


    def python(self, val):
        if val &gt;= self.start and val &lt;= self.stop:
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be an integer between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)

    def description(self):
        return f&#34;integer between {self.start} and {self.stop}&#34;



class ZeroSpecial(ValSpec):
    def __init__(self, zero):
        super().__init__(one_of(just(zero), integers()))
        self.zero = zero

    def phits(self, val):
        if isinstance(val, int):
            if val == self.zero:
                return 0
            else:
                return val
        else:
            return partial(lambda va, zero, var: ValueError(f&#34;`{var}` must be an integer or {zero}; got {va}.&#34;), val, self.zero)

    def python(self, val):
        if val == 0:
            return self.zero
        else:
            return val

    def description(self):
        return f&#34;either {self.zero} or an integer&#34;

class FinBij(ValSpec):
    def __init__(self, dic):
        super().__init__(sampled_from(list(dic.keys())))
        self.dic = dic

    def phits(self, val):
        if val in self.dic:
            return self.dic[val]
        else:
            return partial(lambda va, keys, var: ValueError(f&#34;`{var}` must be one of {keys}; got {va}.&#34;), val, list(self.dic.keys()))


    def python(self, val):
        rev = {v: k for k, v in self.dic.items()}
        if val in rev:
            return rev[val]
        else:
            return partial(lambda va, keys, var: ValueError(f&#34;`{var}` must be one of {keys}; got {va}.&#34;), val, list(rev.keys()))

    def description(self):
        return f&#34;one of the keys in {self.dic}, with the value being the corresponding PHITS value&#34;


@composite
def builds_right(draw, cls, omit=lambda x: True):
    req = list(map(lambda x: tuples(*[i.strat for i in x[1][1]]) if isinstance(x[1][1], tuple) else x[1][1].strat,
                   filter(omit, cls.required_args())))
    opt = dict(map(lambda x: (x[0], one_of(none(), tuples(*[i.strat for i in x[1][1]])) if isinstance(x[1][1], tuple) \
                              else one_of(none(), x[1][1].strat)),
                   filter(omit, cls.optional_args())))

    try:
        ob = draw(builds(cls, *req, **opt))
    except ValueError as e:
        ob = None

    assume(ob)
    return ob


class IsA(ValSpec):
    def __init__(self, cls, index=False):
        super().__init__(builds_right(cls))
        self.cls = cls
        self.index = index

    def phits(self, val):
        if not isinstance(val, self.cls):
            return partial(lambda va, cls, var: ValueError(f&#34;`{var}` must be an instance of {cls}; got {va}.&#34;), val, self.cls)

        if self.index:
            if self.index is None:
                breakpoint()
            return val.index
        else:
            return val.definition()

    def python(self, val):
        return val

    def description(self):
        return f&#34;an instance of {self.cls.__name__}&#34;


# TODO: min_val
class List(ValSpec):
    def __init__(self, entr, max_len=None, unique=False, unique_by=None):
        super().__init__(lists(entr.strat, min_size=1, max_size=max_len, unique=unique, unique_by=unique_by))
        self.entr = entr
        self.max_len = max_len
        self.unique = unique
        self.unique_by = unique_by

    def phits(self, val):
        if self.unique or self.unique_by is not None:
            l = len(set(map(lambda x: self.unique_by(x), val))) if self.unique_by is not None else len(set(val))
            if l &lt; len(val):
                return partial(lambda va, var: ValueError(f&#34;`{var}` must be a list with distinct elements; got {va}.&#34;), val)

        if self.max_len is not None:
            if len(val) &gt; self.max_len:
                return partial(lambda va, var: ValueError(f&#34;`{var}` must be a list of length less than {self.max_len};&#34;
                                                          f&#34; got {va}.&#34;), val)
        if val == []:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a nonempty list; got {va}.&#34;), val)

        return &#34; &#34;.join(map(lambda v: str(self.entr.phits(v)), val))


    def python(self, val):
        return &#34; &#34;.join(map(lambda v: str(self.entr.python(v)), val))

    def description(self):
        return f&#34;a list of values, each of which is {self.entr.description()}&#34;

class Tuple(ValSpec):
    def __init__(self, *entr):
        super().__init__(tuples(*[i.strat for i in entr]))
        self.entr = entr

    def phits(self, val):
        return &#34; &#34;.join(str(i) for i in tuple(map(lambda t: self.entr[t[0]].phits(t[1]), enumerate(val))))

    def python(self, val):
        return tuple(map(lambda t: self.entr[t[0]].python(t[1]), enumerate(val)))

    def description(self):
        j = &#34;, &#34;
        return f&#34;({j.join((i.description() for i in self.entr))})&#34;


class OneOf(ValSpec):
    def __init__(self, *args):
        assert all(map(lambda x: isinstance(x, ValSpec), args)), &#34;All arguments to OneOf must be value specifications.&#34;
        super().__init__(one_of(*[i.strat for i in args]))
        self.choices = args

    def phits(self, val):
        app = self.that_which_applies(val, &#34;phits&#34;)
        if callable(app):
            return app
        else:
            return app.phits(val)

    def that_which_applies(self, val, wh):
        def _applies(s, val, wh):
            if wh == &#34;phits&#34;:
                r = s.phits(val)
                if callable(r) or isinstance(r, Exception):
                    return False
                else:
                    return True
            else:
                r = s.python(val)
                if callable(r) or isinstance(r, Exception):
                    return False
                else:
                    return True

        applicable = list(filter(lambda x: _applies(x, val, wh), self.choices))
        if len(applicable) == 0:
            nice = &#34; &#34;.join(map(lambda x: x.description(), self.choices))
            return partial(lambda va, var: ValueError(f&#34;{var} must be one of {nice}; got {va}.&#34;), val)
        else:
            if len(applicable) != 1:
                breakpoint()
            assert len(applicable) == 1, f&#34;Ambiguous OneOf value specification {self.choices}&#34;
            return applicable[0]

    def description(self):
        return &#34;either &#34; + &#34;, &#34;.join(map(lambda x: x.description(), self.choices[:-1])) + &#34;, or &#34; + self.choices[-1].description()



# Generated from the file $PHITSHOME/data/xsdir.jnd; &lt;atomic number&gt;: (&#39;symbol&#39;, &#39;name&#39;, ((&lt;atomic_weight&gt;, &#39;library_code&#39;))).
# Atomic weight of zero I presume corresponds to a measurement of an average over atomic weights.
elements = {1: (&#39;H&#39;, &#39;Hydrogen&#39;, ((1, &#39;50c&#39;), (2, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (1, &#39;51c&#39;), (2, &#39;51c&#39;), (1, &#39;51h&#39;), (2, &#39;51h&#39;))),
            2: (&#39;He&#39;, &#39;Helium&#39;, ((3, &#39;50c&#39;), (4, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            3: (&#39;Li&#39;, &#39;Lithium&#39;, ((6, &#39;50c&#39;), (7, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (6, &#39;51h&#39;), (7, &#39;51h&#39;))),
            4: (&#39;Be&#39;, &#39;Beryllium&#39;, ((9, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (9, &#39;51h&#39;))),
            5: (&#39;B&#39;, &#39;Boron&#39;, ((10, &#39;50c&#39;), (11, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            6: (&#39;C&#39;, &#39;Carbon&#39;, ((0, &#39;50c&#39;), (12, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (0, &#39;51c&#39;), (12, &#39;51c&#39;), (13, &#39;51c&#39;), (0, &#39;51h&#39;),
                                (12, &#39;51h&#39;), (13, &#39;51h&#39;))),
            7: (&#39;N&#39;, &#39;Nitrogen&#39;, ((14, &#39;50c&#39;), (15, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (14, &#39;51c&#39;), (14, &#39;51h&#39;))),
            8: (&#39;O&#39;, &#39;Oxygen&#39;, ((16, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (16, &#39;51c&#39;), (16, &#39;51h&#39;))),
            9: (&#39;F&#39;, &#39;Fluorine&#39;, ((19, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            10: (&#39;Ne&#39;, &#39;Neon&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            11: (&#39;Na&#39;, &#39;Sodium&#39;, ((23, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            12: (&#39;Mg&#39;, &#39;Magnesium&#39;, ((24, &#39;50c&#39;), (25, &#39;50c&#39;), (26, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            13: (&#39;Al&#39;, &#39;Aluminum&#39;, ((27, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (27, &#39;51c&#39;), (27, &#39;51h&#39;))),
            14: (&#39;Si&#39;, &#39;Silicon&#39;, ((28, &#39;50c&#39;), (29, &#39;50c&#39;), (30, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (28, &#39;51c&#39;), (29, &#39;51c&#39;), (30, &#39;51c&#39;),
                                   (28, &#39;51h&#39;), (29, &#39;51h&#39;), (30, &#39;51h&#39;))),
            15: (&#39;P&#39;, &#39;Phosphorus&#39;, ((31, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            16: (&#39;S&#39;, &#39;Sulfur&#39;, ((32, &#39;50c&#39;), (33, &#39;50c&#39;), (34, &#39;50c&#39;), (36, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            17: (&#39;Cl&#39;, &#39;Chlorine&#39;, ((35, &#39;50c&#39;), (37, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            18: (&#39;Ar&#39;, &#39;Argon&#39;, ((40, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            19: (&#39;K&#39;, &#39;Potassium&#39;, ((39, &#39;50c&#39;), (40, &#39;50c&#39;), (41, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            20: (&#39;Ca&#39;, &#39;Calcium&#39;, ((40, &#39;50c&#39;), (42, &#39;50c&#39;), (43, &#39;50c&#39;), (44, &#39;50c&#39;), (46, &#39;50c&#39;), (48, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            21: (&#39;Sc&#39;, &#39;Scandium&#39;, ((45, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            22: (&#39;Ti&#39;, &#39;Titanium&#39;, ((46, &#39;50c&#39;), (47, &#39;50c&#39;), (48, &#39;50c&#39;), (49, &#39;50c&#39;), (50, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            23: (&#39;V&#39;, &#39;Vanadium&#39;, ((50, &#39;50c&#39;), (51, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            24: (&#39;Cr&#39;, &#39;Chromium&#39;, ((50, &#39;50c&#39;), (52, &#39;50c&#39;), (53, &#39;50c&#39;), (54, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            25: (&#39;Mn&#39;, &#39;Manganese&#39;, ((55, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            26: (&#39;Fe&#39;, &#39;Iron&#39;, ((54, &#39;50c&#39;), (56, &#39;50c&#39;), (57, &#39;50c&#39;), (58, &#39;50c&#39;), (59, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (54, &#39;51c&#39;),
                                (56, &#39;51c&#39;), (57, &#39;51c&#39;), (58, &#39;51c&#39;), (54, &#39;51h&#39;), (56, &#39;51h&#39;), (57, &#39;51h&#39;), (58, &#39;51h&#39;))),
            27: (&#39;Co&#39;, &#39;Cobalt&#39;, ((59, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            28: (&#39;Ni&#39;, &#39;Nickel&#39;, ((58, &#39;50c&#39;), (59, &#39;50c&#39;), (60, &#39;50c&#39;), (61, &#39;50c&#39;), (62, &#39;50c&#39;), (64, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            29: (&#39;Cu&#39;, &#39;Copper&#39;, ((63, &#39;50c&#39;), (65, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (63, &#39;51c&#39;), (65, &#39;51c&#39;), (63, &#39;51h&#39;), (65, &#39;51h&#39;))),
            30: (&#39;Zn&#39;, &#39;Zinc&#39;, ((64, &#39;50c&#39;), (65, &#39;50c&#39;), (66, &#39;50c&#39;), (67, &#39;50c&#39;), (68, &#39;50c&#39;), (70, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            31: (&#39;Ga&#39;, &#39;Gallium&#39;, ((69, &#39;50c&#39;), (71, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            32: (&#39;Ge&#39;, &#39;Germanium&#39;, ((70, &#39;50c&#39;), (72, &#39;50c&#39;), (73, &#39;50c&#39;), (74, &#39;50c&#39;), (76, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            33: (&#39;As&#39;, &#39;Arsenic&#39;, ((75, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            34: (&#39;Se&#39;, &#39;Selenium&#39;, ((74, &#39;50c&#39;), (76, &#39;50c&#39;), (77, &#39;50c&#39;), (78, &#39;50c&#39;), (79, &#39;50c&#39;), (80, &#39;50c&#39;), (82, &#39;50c&#39;), (0, &#39;50p&#39;),
                                    (0, &#39;50e&#39;))),
            35: (&#39;Br&#39;, &#39;Bromine&#39;, ((79, &#39;50c&#39;), (81, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            36: (&#39;Kr&#39;, &#39;Krypton&#39;, ((78, &#39;50c&#39;), (80, &#39;50c&#39;), (82, &#39;50c&#39;), (83, &#39;50c&#39;), (84, &#39;50c&#39;), (85, &#39;50c&#39;), (86, &#39;50c&#39;), (0, &#39;50p&#39;),
                                   (0, &#39;50e&#39;))),
            37: (&#39;Rb&#39;, &#39;Rubidium&#39;, ((85, &#39;50c&#39;), (86, &#39;50c&#39;), (87, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            38: (&#39;Sr&#39;, &#39;Strontium&#39;, ((84, &#39;50c&#39;), (86, &#39;50c&#39;), (87, &#39;50c&#39;), (88, &#39;50c&#39;), (89, &#39;50c&#39;), (90, &#39;50c&#39;), (0, &#39;50p&#39;),
                                     (0, &#39;50e&#39;))),
            39: (&#39;Y&#39;, &#39;Yttrium&#39;, ((89, &#39;50c&#39;), (90, &#39;50c&#39;), (91, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            40: (&#39;Zr&#39;, &#39;Zirconium&#39;, ((90, &#39;50c&#39;), (91, &#39;50c&#39;), (92, &#39;50c&#39;), (93, &#39;50c&#39;), (94, &#39;50c&#39;), (95, &#39;50c&#39;), (96, &#39;50c&#39;), (0, &#39;50p&#39;),
                                     (0, &#39;50e&#39;))),
            41: (&#39;Nb&#39;, &#39;Niobium&#39;, ((93, &#39;50c&#39;), (94, &#39;50c&#39;), (95, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            42: (&#39;Mo&#39;, &#39;Molybdenum&#39;, ((92, &#39;50c&#39;), (94, &#39;50c&#39;), (95, &#39;50c&#39;), (96, &#39;50c&#39;), (97, &#39;50c&#39;), (98, &#39;50c&#39;), (99, &#39;50c&#39;),
                                      (100, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            43: (&#39;Tc&#39;, &#39;Technetium&#39;, ((99, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            44: (&#39;Ru&#39;, &#39;Ruthenium&#39;, ((96, &#39;50c&#39;), (98, &#39;50c&#39;), (99, &#39;50c&#39;), (100, &#39;50c&#39;), (101, &#39;50c&#39;), (102, &#39;50c&#39;), (103, &#39;50c&#39;),
                                     (104, &#39;50c&#39;), (105, &#39;50c&#39;), (106, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            45: (&#39;Rh&#39;, &#39;Rhodium&#39;, ((103, &#39;50c&#39;), (105, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            46: (&#39;Pd&#39;, &#39;Palladium&#39;, ((102, &#39;50c&#39;), (104, &#39;50c&#39;), (105, &#39;50c&#39;), (106, &#39;50c&#39;), (107, &#39;50c&#39;), (108, &#39;50c&#39;), (110, &#39;50c&#39;),
                                     (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            47: (&#39;Ag&#39;, &#39;Silver&#39;, ((107, &#39;50c&#39;), (109, &#39;50c&#39;), (190, &#39;50c&#39;), (111, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            48: (&#39;Cd&#39;, &#39;Cadmium&#39;, ((106, &#39;50c&#39;), (108, &#39;50c&#39;), (110, &#39;50c&#39;), (111, &#39;50c&#39;), (112, &#39;50c&#39;), (113, &#39;50c&#39;), (114, &#39;50c&#39;),
                                   (116, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            49: (&#39;In&#39;, &#39;Indium&#39;, ((113, &#39;50c&#39;), (115, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            50: (&#39;Sn&#39;, &#39;Tin&#39;, ((112, &#39;50c&#39;), (114, &#39;50c&#39;), (115, &#39;50c&#39;), (116, &#39;50c&#39;), (117, &#39;50c&#39;), (118, &#39;50c&#39;), (119, &#39;50c&#39;),
                               (120, &#39;50c&#39;), (122, &#39;50c&#39;), (123, &#39;50c&#39;), (124, &#39;50c&#39;), (126, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            51: (&#39;Sb&#39;, &#39;Antimony&#39;, ((121, &#39;50c&#39;), (123, &#39;50c&#39;), (124, &#39;50c&#39;), (125, &#39;50c&#39;), (126, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            52: (&#39;Te&#39;, &#39;Tellurium&#39;, ((120, &#39;50c&#39;), (122, &#39;50c&#39;), (123, &#39;50c&#39;), (124, &#39;50c&#39;), (125, &#39;50c&#39;), (126, &#39;50c&#39;), (197, &#39;50c&#39;),
                                     (128, &#39;50c&#39;), (199, &#39;50c&#39;), (130, &#39;50c&#39;), (132, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            53: (&#39;I&#39;, &#39;Iodine&#39;, ((127, &#39;50c&#39;), (129, &#39;50c&#39;), (130, &#39;50c&#39;), (131, &#39;50c&#39;), (135, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            54: (&#39;Xe&#39;, &#39;Xenon&#39;, ((124, &#39;50c&#39;), (126, &#39;50c&#39;), (128, &#39;50c&#39;), (129, &#39;50c&#39;), (130, &#39;50c&#39;), (131, &#39;50c&#39;), (132, &#39;50c&#39;),
                                 (133, &#39;50c&#39;), (134, &#39;50c&#39;), (135, &#39;50c&#39;), (136, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            55: (&#39;Cs&#39;, &#39;Cesium&#39;, ((133, &#39;50c&#39;), (134, &#39;50c&#39;), (135, &#39;50c&#39;), (136, &#39;50c&#39;), (137, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            56: (&#39;Ba&#39;, &#39;Barium&#39;, ((130, &#39;50c&#39;), (132, &#39;50c&#39;), (134, &#39;50c&#39;), (135, &#39;50c&#39;), (136, &#39;50c&#39;), (137, &#39;50c&#39;), (138, &#39;50c&#39;),
                                  (140, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            57: (&#39;La&#39;, &#39;Lanthanum&#39;, ((138, &#39;50c&#39;), (139, &#39;50c&#39;), (140, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            58: (&#39;Ce&#39;, &#39;Cerium&#39;, ((140, &#39;50c&#39;), (141, &#39;50c&#39;), (142, &#39;50c&#39;), (143, &#39;50c&#39;), (144, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            59: (&#39;Pr&#39;, &#39;Praseodymium&#39;, ((141, &#39;50c&#39;), (143, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            60: (&#39;Nd&#39;, &#39;Neodymium&#39;, ((142, &#39;50c&#39;), (143, &#39;50c&#39;), (144, &#39;50c&#39;), (145, &#39;50c&#39;), (146, &#39;50c&#39;), (147, &#39;50c&#39;), (148, &#39;50c&#39;),
                                     (150, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            61: (&#39;Pm&#39;, &#39;Promethium&#39;, ((147, &#39;50c&#39;), (148, &#39;50c&#39;), (198, &#39;50c&#39;), (149, &#39;50c&#39;), (151, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            62: (&#39;Sm&#39;, &#39;Samarium&#39;, ((144, &#39;50c&#39;), (147, &#39;50c&#39;), (148, &#39;50c&#39;), (149, &#39;50c&#39;), (150, &#39;50c&#39;), (151, &#39;50c&#39;), (152, &#39;50c&#39;),
                                    (153, &#39;50c&#39;), (154, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            63: (&#39;Eu&#39;, &#39;Europium&#39;, ((151, &#39;50c&#39;), (152, &#39;50c&#39;), (153, &#39;50c&#39;), (154, &#39;50c&#39;), (155, &#39;50c&#39;), (156, &#39;50c&#39;), (157, &#39;50c&#39;),
                                    (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            64: (&#39;Gd&#39;, &#39;Gadolinium&#39;, ((152, &#39;50c&#39;), (153, &#39;50c&#39;), (154, &#39;50c&#39;), (155, &#39;50c&#39;), (156, &#39;50c&#39;), (157, &#39;50c&#39;), (158, &#39;50c&#39;),
                                      (160, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            65: (&#39;Tb&#39;, &#39;Terbium&#39;, ((159, &#39;50c&#39;), (160, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            66: (&#39;Dy&#39;, &#39;Dysprosium&#39;, ((154, &#39;50c&#39;), (156, &#39;50c&#39;), (158, &#39;50c&#39;), (159, &#39;50c&#39;), (160, &#39;50c&#39;), (161, &#39;50c&#39;), (162, &#39;50c&#39;),
                                      (163, &#39;50c&#39;), (164, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            67: (&#39;Ho&#39;, &#39;Holmium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            68: (&#39;Er&#39;, &#39;Erbium&#39;, ((162, &#39;50c&#39;), (164, &#39;50c&#39;), (166, &#39;50c&#39;), (167, &#39;50c&#39;), (168, &#39;50c&#39;), (170, &#39;50c&#39;), (0, &#39;50p&#39;),
                                  (0, &#39;50e&#39;))),
            69: (&#39;Tm&#39;, &#39;Thulium&#39;, ((169, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            70: (&#39;Yb&#39;, &#39;Ytterbium&#39;, ((168, &#39;50c&#39;), (170, &#39;50c&#39;), (171, &#39;50c&#39;), (172, &#39;50c&#39;), (173, &#39;50c&#39;), (174, &#39;50c&#39;), (176, &#39;50c&#39;),
                                     (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            71: (&#39;Lu&#39;, &#39;Lutetium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            72: (&#39;Hf&#39;, &#39;Hafnium&#39;, ((174, &#39;50c&#39;), (176, &#39;50c&#39;), (177, &#39;50c&#39;), (178, &#39;50c&#39;), (179, &#39;50c&#39;), (180, &#39;50c&#39;), (181, &#39;50c&#39;),
                                   (182, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            73: (&#39;Ta&#39;, &#39;Tantalum&#39;, ((181, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            74: (&#39;W&#39;, &#39;Tungsten&#39;, ((180, &#39;50c&#39;), (182, &#39;50c&#39;), (183, &#39;50c&#39;), (184, &#39;50c&#39;), (186, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            75: (&#39;Re&#39;, &#39;Rhenium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            76: (&#39;Os&#39;, &#39;Osmium&#39;, ((184, &#39;50c&#39;), (186, &#39;50c&#39;), (187, &#39;50c&#39;), (188, &#39;50c&#39;), (189, &#39;50c&#39;), (190, &#39;50c&#39;), (192, &#39;50c&#39;),
                                  (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            77: (&#39;Ir&#39;, &#39;Iridium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            78: (&#39;Pt&#39;, &#39;Platinum&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            79: (&#39;Au&#39;, &#39;Gold&#39;, ((197, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            80: (&#39;Hg&#39;, &#39;Mercury&#39;, ((196, &#39;50c&#39;), (198, &#39;50c&#39;), (199, &#39;50c&#39;), (200, &#39;50c&#39;), (201, &#39;50c&#39;), (202, &#39;50c&#39;), (204, &#39;50c&#39;),
                                   (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            81: (&#39;Tl&#39;, &#39;Thallium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            82: (&#39;Pb&#39;, &#39;Lead&#39;, ((204, &#39;50c&#39;), (206, &#39;50c&#39;), (207, &#39;50c&#39;), (208, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (204, &#39;51c&#39;), (206, &#39;51c&#39;),
                                (207, &#39;51c&#39;), (208, &#39;51c&#39;), (204, &#39;51h&#39;), (206, &#39;51h&#39;), (207, &#39;51h&#39;), (208, &#39;51h&#39;))),
            83: (&#39;Bi&#39;, &#39;Bismuth&#39;, ((209, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;), (209, &#39;51c&#39;), (209, &#39;51h&#39;))),
            84: (&#39;Po&#39;, &#39;Polonium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            85: (&#39;At&#39;, &#39;Astatine&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            86: (&#39;Rn&#39;, &#39;Radon&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            87: (&#39;Fr&#39;, &#39;Francium&#39;, ((0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            88: (&#39;Ra&#39;, &#39;Radium&#39;, ((223, &#39;50c&#39;), (224, &#39;50c&#39;), (225, &#39;50c&#39;), (226, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            89: (&#39;Ac&#39;, &#39;Actinium&#39;, ((225, &#39;50c&#39;), (226, &#39;50c&#39;), (227, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            90: (&#39;Th&#39;, &#39;Thorium&#39;, ((227, &#39;50c&#39;), (228, &#39;50c&#39;), (229, &#39;50c&#39;), (230, &#39;50c&#39;), (231, &#39;50c&#39;), (232, &#39;50c&#39;), (233, &#39;50c&#39;),
                                   (234, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            91: (&#39;Pa&#39;, &#39;Protactinium&#39;, ((229, &#39;50c&#39;), (230, &#39;50c&#39;), (231, &#39;50c&#39;), (232, &#39;50c&#39;), (233, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            92: (&#39;U&#39;, &#39;Uranium&#39;, ((230, &#39;50c&#39;), (231, &#39;50c&#39;), (232, &#39;50c&#39;), (233, &#39;50c&#39;), (234, &#39;50c&#39;), (235, &#39;50c&#39;), (236, &#39;50c&#39;),
                                  (237, &#39;50c&#39;), (238, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            93: (&#39;Np&#39;, &#39;Neptunium&#39;, ((234, &#39;50c&#39;), (235, &#39;50c&#39;), (236, &#39;50c&#39;), (237, &#39;50c&#39;), (238, &#39;50c&#39;), (239, &#39;50c&#39;), (0, &#39;50p&#39;),
                                     (0, &#39;50e&#39;))),
            94: (&#39;Pu&#39;, &#39;Plutonium&#39;, ((236, &#39;50c&#39;), (237, &#39;50c&#39;), (238, &#39;50c&#39;), (239, &#39;50c&#39;), (240, &#39;50c&#39;), (241, &#39;50c&#39;), (242, &#39;50c&#39;),
                                     (244, &#39;50c&#39;), (246, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            95: (&#39;Am&#39;, &#39;Americium&#39;, ((240, &#39;50c&#39;), (241, &#39;50c&#39;), (242, &#39;50c&#39;), (292, &#39;50c&#39;), (243, &#39;50c&#39;), (244, &#39;50c&#39;), (294, &#39;50c&#39;),
                                     (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            96: (&#39;Cm&#39;, &#39;Curium&#39;, ((240, &#39;50c&#39;), (241, &#39;50c&#39;), (242, &#39;50c&#39;), (243, &#39;50c&#39;), (244, &#39;50c&#39;), (245, &#39;50c&#39;), (246, &#39;50c&#39;),
                                  (247, &#39;50c&#39;), (248, &#39;50c&#39;), (249, &#39;50c&#39;), (250, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            97: (&#39;Bk&#39;, &#39;Berkelium&#39;, ((245, &#39;50c&#39;), (246, &#39;50c&#39;), (247, &#39;50c&#39;), (248, &#39;50c&#39;), (249, &#39;50c&#39;), (250, &#39;50c&#39;), (0, &#39;50p&#39;),
                                     (0, &#39;50e&#39;))),
            98: (&#39;Cf&#39;, &#39;Californium&#39;, ((246, &#39;50c&#39;), (248, &#39;50c&#39;), (249, &#39;50c&#39;), (250, &#39;50c&#39;), (251, &#39;50c&#39;), (252, &#39;50c&#39;), (253, &#39;50c&#39;),
                                       (254, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;))),
            99: (&#39;Es&#39;, &#39;Einsteinium&#39;, ((251, &#39;50c&#39;), (252, &#39;50c&#39;), (253, &#39;50c&#39;), (254, &#39;50c&#39;), (294, &#39;50c&#39;), (255, &#39;50c&#39;), (0, &#39;50p&#39;),
                                       (0, &#39;50e&#39;))),
            100: (&#39;Fm&#39;, &#39;Fermium&#39;, ((255, &#39;50c&#39;), (0, &#39;50p&#39;), (0, &#39;50e&#39;)))}

particles = {2212: &#34;proton&#34;, 2112: &#34;neutron&#34;, 211: &#34;pion+&#34;, 111: &#34;pion0&#34;, -211: &#34;pion-&#34;, -13: &#34;muon+&#34;, 13: &#34;muon-&#34;,
             321: &#34;kaon+&#34;, 311: &#34;kaon0&#34;, -321: &#34;kaon-&#34;, 11: &#34;electron&#34;, -11: &#34;positron&#34;, 22: &#34;photon&#34;,}
             # 12: &#39;other&#39;, -12: &#39;other&#39;, 14: &#39;other&#39;, -14: &#39;other&#39;, -2212: &#39;other&#39;,
             # -2112: &#39;other&#39;, -311: &#39;other&#39;, 221: &#39;other&#39;, -221: &#39;other&#39;, 331: &#39;other&#39;, 3122: &#39;other&#39;,
             # -3122: &#39;other&#39;, 3222: &#39;other&#39;, -3222: &#39;other&#39;, 3212: &#39;other&#39;, -3212: &#39;other&#39;, 3112: &#39;other&#39;,
             # -3112: &#39;other&#39;, 3322: &#39;other&#39;, -3322: &#39;other&#39;, 3312: &#39;other&#39;, -3312: &#39;other&#39;, 3334: &#39;other&#39;,
             # -3334: &#39;other&#39;}

part_rev = {v: k for k, v in particles.items()}
elsymbol_rev = {v[0]: k for k, v in elements.items()}
elname_rev = {v[1]: k for k, v in elements.items()}
el_weights = {k: set(map(lambda x: x[0], v[2])) for k, v in elements.items()}
j4_el_weights = {k: set(map(lambda x: x[0], v[2])) for k, v in \
                 filter(lambda x: set((&#34;50c&#34;, &#34;51h&#34;)).issubset(set(map(lambda x: x[1], x[1][2]))),
                        elements.items())}

# Read in an ASCII dump file produced by a PHITS tally
def kf_decode(n: int) -&gt; str:
    &#34;&#34;&#34;Given a kf-code of a particle, return a human-readable string description.&#34;&#34;&#34;
    if n in particles:
        return particles[n]
    elif n &gt; 1000000:
        a = int(str(n)[-5:])
        z = (n - a) / 1000000
        return f&#34;{a}{elements[z][0]}&#34;
    else:
        raise ValueError(f&#34;Invalid kf-code {n}.&#34;)

def fake_kf_decode(n: int) -&gt; str:
    &#34;&#34;&#34;Given a kf-code of a particle, return a human-readable string description.&#34;&#34;&#34;
    if n in particles:
        return particles[n]
    elif n &gt;= 1000:
        a = int(str(n)[-3:])
        z = int(str(n)[:-3])
        return f&#34;{a}{elements[z][0]}&#34; if a != 0 else elements[z][0]
    else:
        raise ValueError(f&#34;Invalid fake kf-code {n}.&#34;)


def kf_encode(part: str) -&gt; int:
    &#34;&#34;&#34;Given a particle name, return the fake kf-code that PHTIS uses only for inputs.&#34;&#34;&#34;
    assert isinstance(part, str), f&#34;Invalid particle {part}; must be a string.&#34;
    if part in part_rev:
        return part_rev[part]

    elif part in elsymbol_rev:
        return int(elsymbol_rev[part]) * 1_000

    elif part in elname_rev:
        return int(elname_rev[part]) * 1_000

    elif len(re.split(&#34;-&#34;, part)) == 2: # element-weight
        pts = re.split(&#34;-&#34;, part)
        assert len(pts) == 2, f&#34;Invalid particle {part}; must be of the form 208Pb or Pb-208 (more than two components).&#34;
        capped = pts[0].title()
        if capped in elsymbol_rev:
            elt = elsymbol_rev[capped]
            weight = int(pts[1])
            assert weight in el_weights[elt], f&#34;Unsupported isotope {part}; acceptable values are {el_weights[elt]}.&#34;
            return f&#34;{elt}{weight:03d}&#34;
        elif capped in elname_rev:
            elt = elname_rev[capped]
            weight = int(pts[1])
            assert weight in el_weights[elt], f&#34;Unsupported isotope {part}; acceptable atomic weights are {el_weights[elt]}.&#34;
            return f&#34;{elt}{weight:03d}&#34;
        else:
            raise ValueError(f&#34;Invalid particle {part}; must be of the form 208Pb or Pb-208 (symbol or name not found).&#34;)

    elif m := re.match(r&#34;([1-9][0-9]{,2})([a-zA-Z]+)&#34;, part):
        capped = m[2].title()
        if capped in elsymbol_rev:
            elt = elsymbol_rev[capped]
            weight = int(m[1])
            return f&#34;{elt}{weight:03d}&#34;
        elif capped in elname_rev:
            elt = elname_rev[capped]
            weight = int(m[1])
            return f&#34;{elt}{weight:03d}&#34;
        else:
            raise ValueError(f&#34;Invalid particle {part}; must be of the form 208Pb or Pb-208 (symbol or name not found).&#34;)

    else:
        raise ValueError(f&#34;Invalid particle {part}.&#34;)




class Particle(ValSpec):
    def __init__(self, fake=False):
        super().__init__(sampled_from(list(particles.values())))
        self.fake = fake
    def phits(self, val):
        try:
            assert val in particles.values(), f&#34;Invalid particle {val}.&#34;
            return val if self.fake else kf_encode(val)
        except (AssertionError, ValueError):
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid particle; got {va}&#34;), val)

    def python(self, val):
        return val

    def description(self):
        return &#34;a particle name&#34;



# TODO: lack of  validity checking here-down
# class Element(ValSpec):
#     def __init__(self):
#         super().__init__(sampled_from(list(map(lambda x: x[1][0], elements.items()))))

#     def phits(self, val):
#         return val

#     def python(self, val):
#         return val

#     def description(self):
#         return &#34;any valid element symbol/name&#34;


class Nuclide(ValSpec):
    def __init__(self, fake=False):
        @composite
        def symbol_hyphen_weight(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{sym}-{weight}&#34;

        @composite
        def weight_then_symbol(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{sym}&#34;

        @composite
        def symbol_alone(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            assume(0 in map(lambda x: x[0], elements[elsymbol_rev[sym]][2]))
            return f&#34;{sym}&#34;

        @composite
        def name_hyphen_weight(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{name}-{weight}&#34;

        @composite
        def weight_then_name(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))

            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{name}&#34;

        @composite
        def name_alone(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            assume(0 in map(lambda x: x[0], elements[elname_rev[name]][2]))
            return f&#34;{name}&#34;




        super().__init__(one_of(symbol_hyphen_weight(), weight_then_symbol(), symbol_alone(),
                                name_hyphen_weight(), weight_then_name(), name_alone()))

        self.fake = fake

    def phits(self, val):
        try:
            assert val not in part_rev, f&#34;Particle {val} is not a nuclide.&#34;
            return fake_kf_decode(int(kf_encode(val))) if self.fake else kf_encode(val)
        except (AssertionError, ValueError) as e:

            return partial(lambda va, er, var: ValueError(f&#34;`{var}` must be a valid nuclide; {va} resulted in error:\n{er}&#34;),
                           val, e)


    def description(self):
        return &#34;a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208&#34;


class JENDL4Nuclide(ValSpec):
    def __init__(self, fake=False):
        @composite
        def symbol_hyphen_weight(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0) # TODO: necessary?
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{sym}-{weight}&#34;

        @composite
        def weight_then_symbol(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{sym}&#34;

        @composite
        def symbol_alone(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            assume(elsymbol_rev[sym] in j4_el_weights)
            assume(0 in map(lambda x: x[0], elements[elsymbol_rev[sym]][2])) # TODO: necessary?
            return f&#34;{sym}&#34;

        @composite
        def name_hyphen_weight(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{name}-{weight}&#34;

        @composite
        def weight_then_name(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))

            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{name}&#34;

        @composite
        def name_alone(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            assume(elname_rev[name] in j4_el_weights)
            assume(0 in map(lambda x: x[0], elements[elname_rev[name]][2])) # TODO: necessary?
            return f&#34;{name}&#34;




        super().__init__(one_of(symbol_hyphen_weight(), weight_then_symbol(), symbol_alone(),

                                name_hyphen_weight(), weight_then_name(), name_alone()))
        self.fake = fake
    def phits(self, val):
        try:
            assert val not in part_rev, f&#34;Particle {val} is not a nuclide.&#34;
            return fake_kf_decode(int(kf_encode(val))) if self.fake else kf_encode(val)
        except (AssertionError, ValueError) as e:

            return partial(lambda va, er, var: ValueError(f&#34;`{var}` must be a valid nuclide; {va} resulted in error:\n{er}&#34;),
                           val, e)


    def python(self, val):
        return val

    def description(self):
        return &#34;a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208&#34;


material_libs = [&#39;lmeth.20t&#39;, &#39;lwtr.20t&#39;, &#39;be.24t&#39;, &#39;smeth.20t&#39;, &#39;grph.22t&#39;, &#39;grph.26t&#39;, &#39;beo.25t&#39;, &#39;benz.25t&#39;, &#39;beo.21t&#39;, &#39;hwtr.25t&#39;,
                 &#39;grph.29t&#39;, &#39;beo.24t&#39;, &#39;be.20t&#39;, &#39;zr_h.25t&#39;, &#39;hwtr.21t&#39;, &#39;dpara.20t&#39;, &#39;grph.28t&#39;, &#39;zr_h.27t&#39;, &#39;be.22t&#39;, &#39;beo.23t&#39;,
                 &#39;benz.27t&#39;, &#39;grph.25t&#39;, &#39;lwtr.22t&#39;, &#39;grph.27t&#39;, &#39;hwtr.24t&#39;, &#39;h_zr.26t&#39;, &#39;h_zr.23t&#39;, &#39;h_zr.20t&#39;, &#39;grph.23t&#39;, &#39;be.27t&#39;,
                 &#39;poly.21t&#39;, &#39;benz.26t&#39;, &#39;hwtr.23t&#39;, &#39;grph.20t&#39;, &#39;lwtr.21t&#39;, &#39;grph.21t&#39;, &#39;zr_h.22t&#39;, &#39;h_zr.24t&#39;, &#39;benz.24t&#39;, &#39;hwtr.27t&#39;,
                 &#39;beo.22t&#39;, &#39;hwtr.22t&#39;, &#39;zr_h.24t&#39;, &#39;be.26t&#39;, &#39;lwtr.25t&#39;, &#39;be.25t&#39;, &#39;benz.20t&#39;, &#39;dortho.20t&#39;, &#39;hortho.20t&#39;, &#39;benz.21t&#39;,
                 &#39;lwtr.23t&#39;, &#39;beo.26t&#39;, &#39;lwtr.27t&#39;, &#39;hwtr.20t&#39;, &#39;grph.24t&#39;, &#39;beo.20t&#39;, &#39;zr_h.20t&#39;, &#39;be.21t&#39;, &#39;beo.27t&#39;, &#39;h_zr.22t&#39;,
                 &#39;zr_h.21t&#39;, &#39;lwtr.26t&#39;, &#39;benz.22t&#39;, &#39;h_zr.25t&#39;, &#39;benz.23t&#39;, &#39;zr_h.26t&#39;, &#39;hpara.20t&#39;, &#39;be.23t&#39;, &#39;hwtr.26t&#39;, &#39;lwtr.24t&#39;,
                 &#39;poly.20t&#39;, &#39;zr_h.23t&#39;, &#39;h_zr.27t&#39;, &#39;h_zr.21t&#39;]

class ThermalLib(ValSpec):
    def __init__(self):
        super().__init__(sampled_from(material_libs))

    def phits(self, val):
        if val in material_libs:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid material library; got {va}.&#34;), val)

    def description(self):
        return &#34;a material thermal neutron scattering law library identifier&#34;

chemicals = [&#34;H20&#34;, &#34;CO2&#34;, &#34;NH2&#34;, &#34;NH3&#34;, &#34;SF6&#34;, &#34;TeF6&#34;, &#34;CH4&#34;, &#34;CH3&#34;, &#34;C2H2&#34;, &#34;C2H4&#34;, &#34;C2H6&#34;, &#34;C6H6&#34;, &#34;CH32N3&#34;]
class Chemical(ValSpec):
    def __init__(self):
        super().__init__(sampled_from(chemicals))

    def phits(self, val):
        if val in chemicals:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid chemical; got {va}.&#34;), val)

    def python(self, val):
        return val

    def description(self):
        return f&#34;one of the chemical symbols {chemicals}&#34;

class Orientation(ValSpec):
    def __init__(self):
        super().__init__(one_of(just(&#34;&lt;&#34;), just(&#34;&gt;&#34;)))

    def phits(self, val):
        if val in [&#34;&lt;&#34;, &#34;&gt;&#34;]:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be either `&lt;` or `&gt;`; got {va}.&#34;), val)

class Path(ValSpec):
    def __init__(self):
        super().__init__(text(min_size=1, alphabet=characters(min_codepoint=0x0041, max_codepoint=0x007a)))

    def phits(self, val):
        if isinstance(val, str):
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a filename string; got {val}.&#34;), val)

    def description(self):
        return &#34;a valid file name&#34;

class OrthogonalMatrix(ValSpec):
    def __init__(self):
        listify = lambda x: list(map(tuple, ortho_group.rvs(x)))
        super().__init__(builds(listify, just(3)))

    def phits(self, val):
        if isinstance(val, np.ndarray):
            val = list(map(tuple, val))

        rounding = 2.0e-6
        if (np.array(val) @ np.transpose(val) - np.identity(3) &lt; rounding).all():
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;{var} must be a valid rotation matrix; got {va}.&#34;), val)

    def description(self):
        return &#34;an orthogonal matrix (AA^T = I) representing a rotation&#34;


class LibraryID(ValSpec):
    def __init__(self):
        # TODO: make sure I understand the libraries right
        self.ids = [&#34;50c&#34;, &#34;20t&#34;, &#34;21t&#34;, &#34;22t&#34;, &#34;23t&#34;, &#34;24t&#34;, &#34;25t&#34;, &#34;26t&#34;, &#34;27t&#34;, &#34;28t&#34;, &#34;29t&#34;, &#34;50t&#34;, &#34;50e&#34;, &#34;51c&#34;, &#34;51h&#34;, &#34;90p&#34;]
        super().__init__(sampled_from(self.ids))

    def phits(self, val):
        if val in self.ids:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;{var} must be a valid library ID (one of {self.ids}); got {va}.&#34;), val)

    def description(self):
        return f&#34;a library ID (one of {self.ids})&#34;

class Text(ValSpec):
    def __init__(self):

        super().__init__(text(min_size=1, alphabet=characters(min_codepoint=0x0041, max_codepoint=0x007a))) # TODO: make more general

    def phits(self, val):
        if isinstance(val, str) and val != &#34;&#34;:
            return &#34;{ &#34; + val + &#34; }&#34; # TODO: un-specialize if unnecessary
        else:
            return partial(lambda va, var: ValueError(f&#34;`{va}` must be a string; got {val}.&#34;), val)

    def description(self):
        return &#34;a string&#34;


named_colors = [&#34;white&#34;, &#34;lightgray&#34;, &#34;gray&#34;, &#34;darkgray&#34;, &#34;matblack&#34;, &#34;black&#34;, &#34;red&#34;, &#34;orange&#34;, &#34;yellow&#34;, &#34;green&#34;, &#34;cyan&#34;, &#34;blue&#34;,
                &#34;violet&#34;, &#34;magenta&#34;, &#34;darkred&#34;, &#34;pink&#34;, &#34;pastelpink&#34;, &#34;orange&#34;, &#34;brown&#34;, &#34;darkbrown&#34;, &#34;pastelbrown&#34;, &#34;orangeyellow&#34;,
                &#34;camel&#34;, &#34;pastelyellow&#34;, &#34;yellow&#34;, &#34;pastelgreen&#34;, &#34;yellowgreen&#34;, &#34;green&#34;, &#34;darkgreen&#34;, &#34;mossgreen&#34;, &#34;bluegreen&#34;,
                &#34;pastelcyan&#34;, &#34;pastelblue&#34;, &#34;cyan&#34;, &#34;cyanblue&#34;, &#34;violet&#34;, &#34;purple&#34;, &#34;magenta&#34;, &#34;winered&#34;, &#34;pastelmagenta&#34;,
                &#34;pastelpurple&#34;, &#34;pastelviolet&#34;]
class Color(ValSpec):
    def __init__(self):
        super().__init__(one_of(sampled_from(named_colors),
                                tuples(floats(min_value=0, max_value=1, allow_nan=False, allow_infinity=False, allow_subnormal=False),
                                       floats(min_value=0, max_value=1, allow_nan=False, allow_infinity=False, allow_subnormal=False),
                                       floats(min_value=0, max_value=1, allow_nan=False, allow_infinity=False, allow_subnormal=False))))

    def phits(self, val):
        if val in named_colors :
            return val
        elif isinstance(val, tuple) and len(val) == 3 and all(map(lambda x: 0 &lt;= x &lt;= 1, val)):
            return f&#34;{{ {val[0]:.5f} {val[1]:.5f} {val[2]:.5f} }}&#34;
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid color; got {va}.&#34;), val)

    def description(self):
        return &#34;a color&#34;


def _tup_to_def(tup):
    r = &#34;&#34;
    if not isinstance(tup, tuple):
        sense = &#34;-&#34; if tup.inside else &#34;&#34;
        return f&#34;({sense}{tup.index if tup.index is not None else 0})&#34;
    for el in tup:
        if not isinstance(el, tuple) and not isinstance(el, str):
            sense = &#34;-&#34; if el.inside else &#34;&#34;
            r += f&#34;({sense}{el.index}) &#34;
        elif isinstance(el, tuple):
            cont = _tup_to_def(el)
            r += &#34;(&#34; + (cont if cont[-1] != &#34;\n&#34; else cont[:-1]) + &#34;) &#34;
        elif el == &#34;~&#34;:
            r += &#34;#&#34;
        elif el == &#34;|&#34;:
            r += &#34;: &#34;
        else:
            raise ValueError(f&#34;Unrecognized token {el} in cell region definition.&#34;)

    return r

@composite
def tuplified_lists(draw, el):
    return tuple(draw(lists(el, min_size=1)))

def build(strat):
    return one_of(tuplified_lists(strat), tuples(just(&#34;~&#34;), strat), tuples(strat, just(&#34;|&#34;), strat))

class RegionTuple(ValSpec):
    def __init__(self, surfaces):
        super().__init__(recursive(surfaces.strat, build))

    def phits(self, val):
        # TODO: better parsing
        return _tup_to_def(tuple(val) if isinstance(val, list) else val)

    def description(self):
        return &#34;a recursive tuple of surfaces with set operation semantics: \&#34;~\&#34; negates what follows, infix \&#34;|\&#34; unions, &#34; \
            &#34;and juxtaposition intersects&#34;

@composite
def interval(draw, lbd, ubd):
    st = draw(floats(min_value=lbd, max_value=ubd, exclude_max=ubd is not None, allow_nan=False, allow_infinity=False, allow_subnormal=False,
                     width=16))
    end = draw(floats(min_value=st, max_value=ubd, exclude_min=lbd is not None, allow_nan=False, allow_infinity=False, allow_subnormal=False,
                      width=16))
    return (st, end)

class Interval(ValSpec):
    def __init__(self, lower_bound=float(&#34;-inf&#34;), upper_bound=float(&#34;inf&#34;)):
        super().__init__(interval(lower_bound if lower_bound != float(&#34;-inf&#34;) else None,
                                  upper_bound if upper_bound != float(&#34;inf&#34;) else None))
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound

    def phits(self, val):
        if isinstance(val, tuple) and isinstance(val[0], float) and isinstance(val[1], float) \
           and self.lower_bound &lt;= val[0] &lt;= self.upper_bound and self.lower_bound &lt;= val[1] &lt;= self.upper_bound:
            return f&#34;{val[0]} {val[1]}&#34;
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a well-formed interval contained in&#34;
                                                      f&#34;({self.lower_bound}, {self.upper_bound}); got {val}.&#34;), val)

    def description(self):
        return f&#34;a tuple of length 2 contained in ({self.lower_bound}, {self.upper_bound})&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyphits.valspec.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>strat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(strat):
    return one_of(tuplified_lists(strat), tuples(just(&#34;~&#34;), strat), tuples(strat, just(&#34;|&#34;), strat))</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.builds"><code class="name flex">
<span>def <span class="ident">builds</span></span>(<span>target:Callable[...,+Ex], /, *args:hypothesis.strategies.SearchStrategy[typing.Any], **kwargs:Union[hypothesis.strategies.SearchStrategy[Any],ellipsis])</span>
</code></dt>
<dd>
<div class="desc"><p>Generates values by drawing from <code>args</code> and <code>kwargs</code> and passing
them to the callable (provided as the first positional argument) in the
appropriate argument position.</p>
<p>e.g. <code>builds(target, integers(), flag=booleans())</code> would draw an
integer <code>i</code> and a boolean <code>b</code> and call <code>target(i, flag=b)</code>.</p>
<p>If the callable has type annotations, they will be used to infer a strategy
for required arguments that were not passed to builds.
You can also tell
builds to infer a strategy for an optional argument by passing <code>&hellip;</code>
(:obj:<code>python:Ellipsis</code>) as a keyword argument to builds, instead of a strategy for
that argument to the callable.</p>
<p>If the callable is a class defined with :pypi:<code>attrs</code>, missing required
arguments will be inferred from the attribute on a best-effort basis,
e.g. by checking :ref:<code>attrs standard validators &lt;attrs:api_validators&gt;</code>.
Dataclasses are handled natively by the inference from type hints.</p>
<p>Examples from this strategy shrink by shrinking the argument values to
the callable.</p></div>
</dd>
<dt id="pyphits.valspec.builds_right"><code class="name flex">
<span>def <span class="ident">builds_right</span></span>(<span>cls, omit=&lt;function &lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyphits.valspec.fake_kf_decode"><code class="name flex">
<span>def <span class="ident">fake_kf_decode</span></span>(<span>n:int) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Given a kf-code of a particle, return a human-readable string description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fake_kf_decode(n: int) -&gt; str:
    &#34;&#34;&#34;Given a kf-code of a particle, return a human-readable string description.&#34;&#34;&#34;
    if n in particles:
        return particles[n]
    elif n &gt;= 1000:
        a = int(str(n)[-3:])
        z = int(str(n)[:-3])
        return f&#34;{a}{elements[z][0]}&#34; if a != 0 else elements[z][0]
    else:
        raise ValueError(f&#34;Invalid fake kf-code {n}.&#34;)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.interval"><code class="name flex">
<span>def <span class="ident">interval</span></span>(<span>lbd, ubd)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyphits.valspec.kf_decode"><code class="name flex">
<span>def <span class="ident">kf_decode</span></span>(<span>n:int) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Given a kf-code of a particle, return a human-readable string description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kf_decode(n: int) -&gt; str:
    &#34;&#34;&#34;Given a kf-code of a particle, return a human-readable string description.&#34;&#34;&#34;
    if n in particles:
        return particles[n]
    elif n &gt; 1000000:
        a = int(str(n)[-5:])
        z = (n - a) / 1000000
        return f&#34;{a}{elements[z][0]}&#34;
    else:
        raise ValueError(f&#34;Invalid kf-code {n}.&#34;)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.kf_encode"><code class="name flex">
<span>def <span class="ident">kf_encode</span></span>(<span>part:str) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Given a particle name, return the fake kf-code that PHTIS uses only for inputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kf_encode(part: str) -&gt; int:
    &#34;&#34;&#34;Given a particle name, return the fake kf-code that PHTIS uses only for inputs.&#34;&#34;&#34;
    assert isinstance(part, str), f&#34;Invalid particle {part}; must be a string.&#34;
    if part in part_rev:
        return part_rev[part]

    elif part in elsymbol_rev:
        return int(elsymbol_rev[part]) * 1_000

    elif part in elname_rev:
        return int(elname_rev[part]) * 1_000

    elif len(re.split(&#34;-&#34;, part)) == 2: # element-weight
        pts = re.split(&#34;-&#34;, part)
        assert len(pts) == 2, f&#34;Invalid particle {part}; must be of the form 208Pb or Pb-208 (more than two components).&#34;
        capped = pts[0].title()
        if capped in elsymbol_rev:
            elt = elsymbol_rev[capped]
            weight = int(pts[1])
            assert weight in el_weights[elt], f&#34;Unsupported isotope {part}; acceptable values are {el_weights[elt]}.&#34;
            return f&#34;{elt}{weight:03d}&#34;
        elif capped in elname_rev:
            elt = elname_rev[capped]
            weight = int(pts[1])
            assert weight in el_weights[elt], f&#34;Unsupported isotope {part}; acceptable atomic weights are {el_weights[elt]}.&#34;
            return f&#34;{elt}{weight:03d}&#34;
        else:
            raise ValueError(f&#34;Invalid particle {part}; must be of the form 208Pb or Pb-208 (symbol or name not found).&#34;)

    elif m := re.match(r&#34;([1-9][0-9]{,2})([a-zA-Z]+)&#34;, part):
        capped = m[2].title()
        if capped in elsymbol_rev:
            elt = elsymbol_rev[capped]
            weight = int(m[1])
            return f&#34;{elt}{weight:03d}&#34;
        elif capped in elname_rev:
            elt = elname_rev[capped]
            weight = int(m[1])
            return f&#34;{elt}{weight:03d}&#34;
        else:
            raise ValueError(f&#34;Invalid particle {part}; must be of the form 208Pb or Pb-208 (symbol or name not found).&#34;)

    else:
        raise ValueError(f&#34;Invalid particle {part}.&#34;)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.slices"><code class="name flex">
<span>def <span class="ident">slices</span></span>(<span>size:int)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates slices that will select indices up to the supplied size</p>
<p>Generated slices will have start and stop indices that range from -size to size - 1
and will step in the appropriate direction. Slices should only produce an empty selection
if the start and end are the same.</p>
<p>Examples from this strategy shrink toward 0 and smaller values</p></div>
</dd>
<dt id="pyphits.valspec.tuplified_lists"><code class="name flex">
<span>def <span class="ident">tuplified_lists</span></span>(<span>el)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyphits.valspec.Between"><code class="flex name class">
<span>class <span class="ident">Between</span></span>
<span>(</span><span>start, stop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Between(ValSpec):
    def __init__(self, start, stop):
        super().__init__(integers(min_value=start, max_value=stop))
        self.start = start
        self.stop = stop

    def phits(self, val):
        if isinstance(val, int) and val &gt;= self.start and val &lt;= self.stop:
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be an integer between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)


    def python(self, val):
        if val &gt;= self.start and val &lt;= self.stop:
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be an integer between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)

    def description(self):
        return f&#34;integer between {self.start} and {self.stop}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Between.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;integer between {self.start} and {self.stop}&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Between.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, int) and val &gt;= self.start and val &lt;= self.stop:
        return val
    else:
        return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be an integer between {start} and {stop}; got {va}.&#34;),
                       val, self.start, self.stop)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Between.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val &gt;= self.start and val &lt;= self.stop:
        return val
    else:
        return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be an integer between {start} and {stop}; got {va}.&#34;),
                       val, self.start, self.stop)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Chemical"><code class="flex name class">
<span>class <span class="ident">Chemical</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chemical(ValSpec):
    def __init__(self):
        super().__init__(sampled_from(chemicals))

    def phits(self, val):
        if val in chemicals:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid chemical; got {va}.&#34;), val)

    def python(self, val):
        return val

    def description(self):
        return f&#34;one of the chemical symbols {chemicals}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Chemical.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;one of the chemical symbols {chemicals}&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Chemical.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val in chemicals:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid chemical; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Chemical.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Choice10"><code class="flex name class">
<span>class <span class="ident">Choice10</span></span>
<span>(</span><span>c_style=False, true=True, false=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Choice10(ValSpec):
    def __init__(self, c_style=False, true=True, false=False):
        super().__init__(one_of(just(false), just(true)))
        self.c_style = c_style
        self.true = true
        self.false = false

    def phits(self, val):
        if val == self.true:
            return 0 if self.c_style else 1
        elif val == self.false:
            return 1 if self.c_style else 0
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be either True or False; got {va}.&#34;), val)

    def python(self, val):
        if val == 0:
                return self.true if self.c_style else self.false
        elif val == 1:
            return self.false if self.c_style else self.true
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be either 0 or 1; got {va}.&#34;), val)

    def description(self):
        return f&#34;either {self.true} or {self.false}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Choice10.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;either {self.true} or {self.false}&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Choice10.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val == self.true:
        return 0 if self.c_style else 1
    elif val == self.false:
        return 1 if self.c_style else 0
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be either True or False; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Choice10.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val == 0:
            return self.true if self.c_style else self.false
    elif val == 1:
        return self.false if self.c_style else self.true
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be either 0 or 1; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Color"><code class="flex name class">
<span>class <span class="ident">Color</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Color(ValSpec):
    def __init__(self):
        super().__init__(one_of(sampled_from(named_colors),
                                tuples(floats(min_value=0, max_value=1, allow_nan=False, allow_infinity=False, allow_subnormal=False),
                                       floats(min_value=0, max_value=1, allow_nan=False, allow_infinity=False, allow_subnormal=False),
                                       floats(min_value=0, max_value=1, allow_nan=False, allow_infinity=False, allow_subnormal=False))))

    def phits(self, val):
        if val in named_colors :
            return val
        elif isinstance(val, tuple) and len(val) == 3 and all(map(lambda x: 0 &lt;= x &lt;= 1, val)):
            return f&#34;{{ {val[0]:.5f} {val[1]:.5f} {val[2]:.5f} }}&#34;
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid color; got {va}.&#34;), val)

    def description(self):
        return &#34;a color&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Color.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a color&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Color.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val in named_colors :
        return val
    elif isinstance(val, tuple) and len(val) == 3 and all(map(lambda x: 0 &lt;= x &lt;= 1, val)):
        return f&#34;{{ {val[0]:.5f} {val[1]:.5f} {val[2]:.5f} }}&#34;
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid color; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.FinBij"><code class="flex name class">
<span>class <span class="ident">FinBij</span></span>
<span>(</span><span>dic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinBij(ValSpec):
    def __init__(self, dic):
        super().__init__(sampled_from(list(dic.keys())))
        self.dic = dic

    def phits(self, val):
        if val in self.dic:
            return self.dic[val]
        else:
            return partial(lambda va, keys, var: ValueError(f&#34;`{var}` must be one of {keys}; got {va}.&#34;), val, list(self.dic.keys()))


    def python(self, val):
        rev = {v: k for k, v in self.dic.items()}
        if val in rev:
            return rev[val]
        else:
            return partial(lambda va, keys, var: ValueError(f&#34;`{var}` must be one of {keys}; got {va}.&#34;), val, list(rev.keys()))

    def description(self):
        return f&#34;one of the keys in {self.dic}, with the value being the corresponding PHITS value&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.FinBij.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;one of the keys in {self.dic}, with the value being the corresponding PHITS value&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.FinBij.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val in self.dic:
        return self.dic[val]
    else:
        return partial(lambda va, keys, var: ValueError(f&#34;`{var}` must be one of {keys}; got {va}.&#34;), val, list(self.dic.keys()))</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.FinBij.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    rev = {v: k for k, v in self.dic.items()}
    if val in rev:
        return rev[val]
    else:
        return partial(lambda va, keys, var: ValueError(f&#34;`{var}` must be one of {keys}; got {va}.&#34;), val, list(rev.keys()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Integer"><code class="flex name class">
<span>class <span class="ident">Integer</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Integer(ValSpec):
    def __init__(self):
        super().__init__(integers())
    def phits(self, val):
        if isinstance(val, int):
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be an integer; got {va}.&#34;), val)

    def python(self, val):
        if val % 1 == 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be an integer; got {va}.&#34;), val)
    def description(self):
        return &#34;int&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Integer.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;int&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Integer.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, int):
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be an integer; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Integer.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val % 1 == 0:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be an integer; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Interval"><code class="flex name class">
<span>class <span class="ident">Interval</span></span>
<span>(</span><span>lower_bound=-inf, upper_bound=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interval(ValSpec):
    def __init__(self, lower_bound=float(&#34;-inf&#34;), upper_bound=float(&#34;inf&#34;)):
        super().__init__(interval(lower_bound if lower_bound != float(&#34;-inf&#34;) else None,
                                  upper_bound if upper_bound != float(&#34;inf&#34;) else None))
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound

    def phits(self, val):
        if isinstance(val, tuple) and isinstance(val[0], float) and isinstance(val[1], float) \
           and self.lower_bound &lt;= val[0] &lt;= self.upper_bound and self.lower_bound &lt;= val[1] &lt;= self.upper_bound:
            return f&#34;{val[0]} {val[1]}&#34;
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a well-formed interval contained in&#34;
                                                      f&#34;({self.lower_bound}, {self.upper_bound}); got {val}.&#34;), val)

    def description(self):
        return f&#34;a tuple of length 2 contained in ({self.lower_bound}, {self.upper_bound})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Interval.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;a tuple of length 2 contained in ({self.lower_bound}, {self.upper_bound})&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Interval.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, tuple) and isinstance(val[0], float) and isinstance(val[1], float) \
       and self.lower_bound &lt;= val[0] &lt;= self.upper_bound and self.lower_bound &lt;= val[1] &lt;= self.upper_bound:
        return f&#34;{val[0]} {val[1]}&#34;
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a well-formed interval contained in&#34;
                                                  f&#34;({self.lower_bound}, {self.upper_bound}); got {val}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.IsA"><code class="flex name class">
<span>class <span class="ident">IsA</span></span>
<span>(</span><span>cls, index=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IsA(ValSpec):
    def __init__(self, cls, index=False):
        super().__init__(builds_right(cls))
        self.cls = cls
        self.index = index

    def phits(self, val):
        if not isinstance(val, self.cls):
            return partial(lambda va, cls, var: ValueError(f&#34;`{var}` must be an instance of {cls}; got {va}.&#34;), val, self.cls)

        if self.index:
            if self.index is None:
                breakpoint()
            return val.index
        else:
            return val.definition()

    def python(self, val):
        return val

    def description(self):
        return f&#34;an instance of {self.cls.__name__}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.IsA.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;an instance of {self.cls.__name__}&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.IsA.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if not isinstance(val, self.cls):
        return partial(lambda va, cls, var: ValueError(f&#34;`{var}` must be an instance of {cls}; got {va}.&#34;), val, self.cls)

    if self.index:
        if self.index is None:
            breakpoint()
        return val.index
    else:
        return val.definition()</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.IsA.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.JENDL4Nuclide"><code class="flex name class">
<span>class <span class="ident">JENDL4Nuclide</span></span>
<span>(</span><span>fake=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JENDL4Nuclide(ValSpec):
    def __init__(self, fake=False):
        @composite
        def symbol_hyphen_weight(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0) # TODO: necessary?
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{sym}-{weight}&#34;

        @composite
        def weight_then_symbol(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{sym}&#34;

        @composite
        def symbol_alone(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            assume(elsymbol_rev[sym] in j4_el_weights)
            assume(0 in map(lambda x: x[0], elements[elsymbol_rev[sym]][2])) # TODO: necessary?
            return f&#34;{sym}&#34;

        @composite
        def name_hyphen_weight(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{name}-{weight}&#34;

        @composite
        def weight_then_name(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))

            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{name}&#34;

        @composite
        def name_alone(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            assume(elname_rev[name] in j4_el_weights)
            assume(0 in map(lambda x: x[0], elements[elname_rev[name]][2])) # TODO: necessary?
            return f&#34;{name}&#34;




        super().__init__(one_of(symbol_hyphen_weight(), weight_then_symbol(), symbol_alone(),

                                name_hyphen_weight(), weight_then_name(), name_alone()))
        self.fake = fake
    def phits(self, val):
        try:
            assert val not in part_rev, f&#34;Particle {val} is not a nuclide.&#34;
            return fake_kf_decode(int(kf_encode(val))) if self.fake else kf_encode(val)
        except (AssertionError, ValueError) as e:

            return partial(lambda va, er, var: ValueError(f&#34;`{var}` must be a valid nuclide; {va} resulted in error:\n{er}&#34;),
                           val, e)


    def python(self, val):
        return val

    def description(self):
        return &#34;a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.JENDL4Nuclide.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.JENDL4Nuclide.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    try:
        assert val not in part_rev, f&#34;Particle {val} is not a nuclide.&#34;
        return fake_kf_decode(int(kf_encode(val))) if self.fake else kf_encode(val)
    except (AssertionError, ValueError) as e:

        return partial(lambda va, er, var: ValueError(f&#34;`{var}` must be a valid nuclide; {va} resulted in error:\n{er}&#34;),
                       val, e)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.JENDL4Nuclide.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.LibraryID"><code class="flex name class">
<span>class <span class="ident">LibraryID</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LibraryID(ValSpec):
    def __init__(self):
        # TODO: make sure I understand the libraries right
        self.ids = [&#34;50c&#34;, &#34;20t&#34;, &#34;21t&#34;, &#34;22t&#34;, &#34;23t&#34;, &#34;24t&#34;, &#34;25t&#34;, &#34;26t&#34;, &#34;27t&#34;, &#34;28t&#34;, &#34;29t&#34;, &#34;50t&#34;, &#34;50e&#34;, &#34;51c&#34;, &#34;51h&#34;, &#34;90p&#34;]
        super().__init__(sampled_from(self.ids))

    def phits(self, val):
        if val in self.ids:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;{var} must be a valid library ID (one of {self.ids}); got {va}.&#34;), val)

    def description(self):
        return f&#34;a library ID (one of {self.ids})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.LibraryID.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;a library ID (one of {self.ids})&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.LibraryID.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val in self.ids:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;{var} must be a valid library ID (one of {self.ids}); got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.List"><code class="flex name class">
<span>class <span class="ident">List</span></span>
<span>(</span><span>entr, max_len=None, unique=False, unique_by=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class List(ValSpec):
    def __init__(self, entr, max_len=None, unique=False, unique_by=None):
        super().__init__(lists(entr.strat, min_size=1, max_size=max_len, unique=unique, unique_by=unique_by))
        self.entr = entr
        self.max_len = max_len
        self.unique = unique
        self.unique_by = unique_by

    def phits(self, val):
        if self.unique or self.unique_by is not None:
            l = len(set(map(lambda x: self.unique_by(x), val))) if self.unique_by is not None else len(set(val))
            if l &lt; len(val):
                return partial(lambda va, var: ValueError(f&#34;`{var}` must be a list with distinct elements; got {va}.&#34;), val)

        if self.max_len is not None:
            if len(val) &gt; self.max_len:
                return partial(lambda va, var: ValueError(f&#34;`{var}` must be a list of length less than {self.max_len};&#34;
                                                          f&#34; got {va}.&#34;), val)
        if val == []:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a nonempty list; got {va}.&#34;), val)

        return &#34; &#34;.join(map(lambda v: str(self.entr.phits(v)), val))


    def python(self, val):
        return &#34; &#34;.join(map(lambda v: str(self.entr.python(v)), val))

    def description(self):
        return f&#34;a list of values, each of which is {self.entr.description()}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.List.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;a list of values, each of which is {self.entr.description()}&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.List.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if self.unique or self.unique_by is not None:
        l = len(set(map(lambda x: self.unique_by(x), val))) if self.unique_by is not None else len(set(val))
        if l &lt; len(val):
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a list with distinct elements; got {va}.&#34;), val)

    if self.max_len is not None:
        if len(val) &gt; self.max_len:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a list of length less than {self.max_len};&#34;
                                                      f&#34; got {va}.&#34;), val)
    if val == []:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a nonempty list; got {va}.&#34;), val)

    return &#34; &#34;.join(map(lambda v: str(self.entr.phits(v)), val))</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.List.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return &#34; &#34;.join(map(lambda v: str(self.entr.python(v)), val))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.NegDisable"><code class="flex name class">
<span>class <span class="ident">NegDisable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NegDisable(ValSpec):
    def __init__(self):
        super().__init__(one_of(none(), integers(min_value=0), floats(min_value=0, allow_nan=False, allow_infinity=False,
                                                                      allow_subnormal=False, width=16)))
    def phits(self, val):
        if isinstance(val, float) or isinstance(val, int) and val &gt;= 0:
            return val
        elif val is None:
            return -1.0
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive integer or None; got {va}.&#34;), val)

    def python(self, val):
        if val &gt; 0:
            return val
        else:
            return None

    def description(self):
        return &#34;either None or a number&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.NegDisable.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;either None or a number&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.NegDisable.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, float) or isinstance(val, int) and val &gt;= 0:
        return val
    elif val is None:
        return -1.0
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive integer or None; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.NegDisable.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val &gt; 0:
        return val
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Nuclide"><code class="flex name class">
<span>class <span class="ident">Nuclide</span></span>
<span>(</span><span>fake=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Nuclide(ValSpec):
    def __init__(self, fake=False):
        @composite
        def symbol_hyphen_weight(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{sym}-{weight}&#34;

        @composite
        def weight_then_symbol(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elsymbol_rev[sym]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{sym}&#34;

        @composite
        def symbol_alone(draw):
            sym = draw(sampled_from(list(map(lambda x: x[1][0], elements.items()))))
            assume(0 in map(lambda x: x[0], elements[elsymbol_rev[sym]][2]))
            return f&#34;{sym}&#34;

        @composite
        def name_hyphen_weight(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{name}-{weight}&#34;

        @composite
        def weight_then_name(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))

            wgts = list(filter(lambda x: x != 0,
                               map(lambda x: x[0], elements[elname_rev[name]][2])))
            assume(len(wgts) &gt; 0)
            weight = draw(sampled_from(list(wgts)))
            return f&#34;{weight}{name}&#34;

        @composite
        def name_alone(draw):
            name = draw(sampled_from(list(map(lambda x: x[1][1], elements.items()))))
            assume(0 in map(lambda x: x[0], elements[elname_rev[name]][2]))
            return f&#34;{name}&#34;




        super().__init__(one_of(symbol_hyphen_weight(), weight_then_symbol(), symbol_alone(),
                                name_hyphen_weight(), weight_then_name(), name_alone()))

        self.fake = fake

    def phits(self, val):
        try:
            assert val not in part_rev, f&#34;Particle {val} is not a nuclide.&#34;
            return fake_kf_decode(int(kf_encode(val))) if self.fake else kf_encode(val)
        except (AssertionError, ValueError) as e:

            return partial(lambda va, er, var: ValueError(f&#34;`{var}` must be a valid nuclide; {va} resulted in error:\n{er}&#34;),
                           val, e)


    def description(self):
        return &#34;a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Nuclide.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a nucleide in the form 208Pb, 208Lead, Pb-208, or Lead-208&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Nuclide.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    try:
        assert val not in part_rev, f&#34;Particle {val} is not a nuclide.&#34;
        return fake_kf_decode(int(kf_encode(val))) if self.fake else kf_encode(val)
    except (AssertionError, ValueError) as e:

        return partial(lambda va, er, var: ValueError(f&#34;`{var}` must be a valid nuclide; {va} resulted in error:\n{er}&#34;),
                       val, e)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.OneOf"><code class="flex name class">
<span>class <span class="ident">OneOf</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OneOf(ValSpec):
    def __init__(self, *args):
        assert all(map(lambda x: isinstance(x, ValSpec), args)), &#34;All arguments to OneOf must be value specifications.&#34;
        super().__init__(one_of(*[i.strat for i in args]))
        self.choices = args

    def phits(self, val):
        app = self.that_which_applies(val, &#34;phits&#34;)
        if callable(app):
            return app
        else:
            return app.phits(val)

    def that_which_applies(self, val, wh):
        def _applies(s, val, wh):
            if wh == &#34;phits&#34;:
                r = s.phits(val)
                if callable(r) or isinstance(r, Exception):
                    return False
                else:
                    return True
            else:
                r = s.python(val)
                if callable(r) or isinstance(r, Exception):
                    return False
                else:
                    return True

        applicable = list(filter(lambda x: _applies(x, val, wh), self.choices))
        if len(applicable) == 0:
            nice = &#34; &#34;.join(map(lambda x: x.description(), self.choices))
            return partial(lambda va, var: ValueError(f&#34;{var} must be one of {nice}; got {va}.&#34;), val)
        else:
            if len(applicable) != 1:
                breakpoint()
            assert len(applicable) == 1, f&#34;Ambiguous OneOf value specification {self.choices}&#34;
            return applicable[0]

    def description(self):
        return &#34;either &#34; + &#34;, &#34;.join(map(lambda x: x.description(), self.choices[:-1])) + &#34;, or &#34; + self.choices[-1].description()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.OneOf.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;either &#34; + &#34;, &#34;.join(map(lambda x: x.description(), self.choices[:-1])) + &#34;, or &#34; + self.choices[-1].description()</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.OneOf.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    app = self.that_which_applies(val, &#34;phits&#34;)
    if callable(app):
        return app
    else:
        return app.phits(val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.OneOf.that_which_applies"><code class="name flex">
<span>def <span class="ident">that_which_applies</span></span>(<span>self, val, wh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def that_which_applies(self, val, wh):
    def _applies(s, val, wh):
        if wh == &#34;phits&#34;:
            r = s.phits(val)
            if callable(r) or isinstance(r, Exception):
                return False
            else:
                return True
        else:
            r = s.python(val)
            if callable(r) or isinstance(r, Exception):
                return False
            else:
                return True

    applicable = list(filter(lambda x: _applies(x, val, wh), self.choices))
    if len(applicable) == 0:
        nice = &#34; &#34;.join(map(lambda x: x.description(), self.choices))
        return partial(lambda va, var: ValueError(f&#34;{var} must be one of {nice}; got {va}.&#34;), val)
    else:
        if len(applicable) != 1:
            breakpoint()
        assert len(applicable) == 1, f&#34;Ambiguous OneOf value specification {self.choices}&#34;
        return applicable[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Orientation"><code class="flex name class">
<span>class <span class="ident">Orientation</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orientation(ValSpec):
    def __init__(self):
        super().__init__(one_of(just(&#34;&lt;&#34;), just(&#34;&gt;&#34;)))

    def phits(self, val):
        if val in [&#34;&lt;&#34;, &#34;&gt;&#34;]:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be either `&lt;` or `&gt;`; got {va}.&#34;), val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Orientation.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val in [&#34;&lt;&#34;, &#34;&gt;&#34;]:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be either `&lt;` or `&gt;`; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.OrthogonalMatrix"><code class="flex name class">
<span>class <span class="ident">OrthogonalMatrix</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrthogonalMatrix(ValSpec):
    def __init__(self):
        listify = lambda x: list(map(tuple, ortho_group.rvs(x)))
        super().__init__(builds(listify, just(3)))

    def phits(self, val):
        if isinstance(val, np.ndarray):
            val = list(map(tuple, val))

        rounding = 2.0e-6
        if (np.array(val) @ np.transpose(val) - np.identity(3) &lt; rounding).all():
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;{var} must be a valid rotation matrix; got {va}.&#34;), val)

    def description(self):
        return &#34;an orthogonal matrix (AA^T = I) representing a rotation&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.OrthogonalMatrix.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;an orthogonal matrix (AA^T = I) representing a rotation&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.OrthogonalMatrix.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, np.ndarray):
        val = list(map(tuple, val))

    rounding = 2.0e-6
    if (np.array(val) @ np.transpose(val) - np.identity(3) &lt; rounding).all():
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;{var} must be a valid rotation matrix; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Particle"><code class="flex name class">
<span>class <span class="ident">Particle</span></span>
<span>(</span><span>fake=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Particle(ValSpec):
    def __init__(self, fake=False):
        super().__init__(sampled_from(list(particles.values())))
        self.fake = fake
    def phits(self, val):
        try:
            assert val in particles.values(), f&#34;Invalid particle {val}.&#34;
            return val if self.fake else kf_encode(val)
        except (AssertionError, ValueError):
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid particle; got {va}&#34;), val)

    def python(self, val):
        return val

    def description(self):
        return &#34;a particle name&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Particle.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a particle name&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Particle.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    try:
        assert val in particles.values(), f&#34;Invalid particle {val}.&#34;
        return val if self.fake else kf_encode(val)
    except (AssertionError, ValueError):
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid particle; got {va}&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Particle.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Path"><code class="flex name class">
<span>class <span class="ident">Path</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Path(ValSpec):
    def __init__(self):
        super().__init__(text(min_size=1, alphabet=characters(min_codepoint=0x0041, max_codepoint=0x007a)))

    def phits(self, val):
        if isinstance(val, str):
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a filename string; got {val}.&#34;), val)

    def description(self):
        return &#34;a valid file name&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Path.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a valid file name&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Path.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, str):
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a filename string; got {val}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.PosInt"><code class="flex name class">
<span>class <span class="ident">PosInt</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PosInt(ValSpec):
    def __init__(self):
        super().__init__(integers(min_value=1))

    def phits(self, val):
        if isinstance(val, int) and val &gt; 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive integer; got {va}.&#34;), val)

    def python(self, val):
        if val &gt; 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be positive; got {va}.&#34;), val)

    def description(self):
        return &#34;int &gt; zero&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.PosInt.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;int &gt; zero&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.PosInt.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, int) and val &gt; 0:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive integer; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.PosInt.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val &gt; 0:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be positive; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.PosReal"><code class="flex name class">
<span>class <span class="ident">PosReal</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PosReal(ValSpec):
    def __init__(self):
        super().__init__(floats(min_value=0, exclude_min=True, allow_nan=False, allow_infinity=False, allow_subnormal=False,
                                width=16))
    def phits(self, val):
        if (isinstance(val, float) or isinstance(val, int)) and val &gt; 0:
            return float(val)
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive float; got {va}.&#34;), val)

    def python(self, val):
        if val &gt; 0:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be positive; got {va}.&#34;), val)

    def description(self):
        return &#34;float &gt; 0&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.PosReal.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;float &gt; 0&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.PosReal.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if (isinstance(val, float) or isinstance(val, int)) and val &gt; 0:
        return float(val)
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a positive float; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.PosReal.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val &gt; 0:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be positive; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Real"><code class="flex name class">
<span>class <span class="ident">Real</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Real(ValSpec):
    def __init__(self):
        super().__init__(floats(allow_nan=False, allow_infinity=False, allow_subnormal=False, width=16))
    def phits(self, val):
        if isinstance(val, float) or isinstance(val, int):
            return float(val)
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a float; got {va}.&#34;), val)

    def python(self, val):
        return val

    def description(self):
        return &#34;float&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Real.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;float&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Real.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, float) or isinstance(val, int):
        return float(val)
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a float; got {va}.&#34;), val)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Real.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.RealBetween"><code class="flex name class">
<span>class <span class="ident">RealBetween</span></span>
<span>(</span><span>start, stop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RealBetween(ValSpec):
    def __init__(self, start, stop):
        super().__init__(floats(min_value=start, max_value=stop, allow_nan=False, allow_infinity=False, allow_subnormal=False,
                                width=16))
        self.start = start
        self.stop = stop

    def phits(self, val):
        if isinstance(val, float) and (self.start is None or val &gt;= self.start) and (self.stop is None or val &lt;= self.stop):
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be a float between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)


    def python(self, val):
        if val &gt;= self.start and val &lt;= self.stop:
            return val
        else:
            return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be a float between {start} and {stop}; got {va}.&#34;),
                           val, self.start, self.stop)

    def description(self):
        return f&#34;float between {self.start} and {self.stop}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.RealBetween.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;float between {self.start} and {self.stop}&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.RealBetween.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, float) and (self.start is None or val &gt;= self.start) and (self.stop is None or val &lt;= self.stop):
        return val
    else:
        return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be a float between {start} and {stop}; got {va}.&#34;),
                       val, self.start, self.stop)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.RealBetween.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val &gt;= self.start and val &lt;= self.stop:
        return val
    else:
        return partial(lambda va, start, stop, var: ValueError(f&#34;`{var}` must be a float between {start} and {stop}; got {va}.&#34;),
                       val, self.start, self.stop)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.RegionTuple"><code class="flex name class">
<span>class <span class="ident">RegionTuple</span></span>
<span>(</span><span>surfaces)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegionTuple(ValSpec):
    def __init__(self, surfaces):
        super().__init__(recursive(surfaces.strat, build))

    def phits(self, val):
        # TODO: better parsing
        return _tup_to_def(tuple(val) if isinstance(val, list) else val)

    def description(self):
        return &#34;a recursive tuple of surfaces with set operation semantics: \&#34;~\&#34; negates what follows, infix \&#34;|\&#34; unions, &#34; \
            &#34;and juxtaposition intersects&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.RegionTuple.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a recursive tuple of surfaces with set operation semantics: \&#34;~\&#34; negates what follows, infix \&#34;|\&#34; unions, &#34; \
        &#34;and juxtaposition intersects&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.RegionTuple.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    # TODO: better parsing
    return _tup_to_def(tuple(val) if isinstance(val, list) else val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text(ValSpec):
    def __init__(self):

        super().__init__(text(min_size=1, alphabet=characters(min_codepoint=0x0041, max_codepoint=0x007a))) # TODO: make more general

    def phits(self, val):
        if isinstance(val, str) and val != &#34;&#34;:
            return &#34;{ &#34; + val + &#34; }&#34; # TODO: un-specialize if unnecessary
        else:
            return partial(lambda va, var: ValueError(f&#34;`{va}` must be a string; got {val}.&#34;), val)

    def description(self):
        return &#34;a string&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Text.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a string&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Text.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, str) and val != &#34;&#34;:
        return &#34;{ &#34; + val + &#34; }&#34; # TODO: un-specialize if unnecessary
    else:
        return partial(lambda va, var: ValueError(f&#34;`{va}` must be a string; got {val}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.ThermalLib"><code class="flex name class">
<span>class <span class="ident">ThermalLib</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThermalLib(ValSpec):
    def __init__(self):
        super().__init__(sampled_from(material_libs))

    def phits(self, val):
        if val in material_libs:
            return val
        else:
            return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid material library; got {va}.&#34;), val)

    def description(self):
        return &#34;a material thermal neutron scattering law library identifier&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.ThermalLib.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return &#34;a material thermal neutron scattering law library identifier&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.ThermalLib.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if val in material_libs:
        return val
    else:
        return partial(lambda va, var: ValueError(f&#34;`{var}` must be a valid material library; got {va}.&#34;), val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.Tuple"><code class="flex name class">
<span>class <span class="ident">Tuple</span></span>
<span>(</span><span>*entr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tuple(ValSpec):
    def __init__(self, *entr):
        super().__init__(tuples(*[i.strat for i in entr]))
        self.entr = entr

    def phits(self, val):
        return &#34; &#34;.join(str(i) for i in tuple(map(lambda t: self.entr[t[0]].phits(t[1]), enumerate(val))))

    def python(self, val):
        return tuple(map(lambda t: self.entr[t[0]].python(t[1]), enumerate(val)))

    def description(self):
        j = &#34;, &#34;
        return f&#34;({j.join((i.description() for i in self.entr))})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.Tuple.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    j = &#34;, &#34;
    return f&#34;({j.join((i.description() for i in self.entr))})&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Tuple.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    return &#34; &#34;.join(str(i) for i in tuple(map(lambda t: self.entr[t[0]].phits(t[1]), enumerate(val))))</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.Tuple.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    return tuple(map(lambda t: self.entr[t[0]].python(t[1]), enumerate(val)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyphits.valspec.ValSpec"><code class="flex name class">
<span>class <span class="ident">ValSpec</span></span>
<span>(</span><span>strat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValSpec():
    # in principle, this&#39;d be cleaner were it a class attribute.
    def __init__(self, strat):
        self.strat = strat
    def __or__(self, other):
        # TODO: think about if copying is necessary
        if isinstance(self, OneOf) and isinstance(other, OneOf):
            self.choices.append(other.choices)
            return self
        elif isinstance(self, OneOf) and not isinstance(other, OneOf):
            self.choices.append(other)
            return self
        elif not isinstance(self, OneOf) and isinstance(other, OneOf):
            other.choices.append(self)
            return other
        elif not isinstance(self, OneOf) and not isinstance(other, OneOf):
            return OneOf(self, other)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.Between" href="#pyphits.valspec.Between">Between</a></li>
<li><a title="pyphits.valspec.Chemical" href="#pyphits.valspec.Chemical">Chemical</a></li>
<li><a title="pyphits.valspec.Choice10" href="#pyphits.valspec.Choice10">Choice10</a></li>
<li><a title="pyphits.valspec.Color" href="#pyphits.valspec.Color">Color</a></li>
<li><a title="pyphits.valspec.FinBij" href="#pyphits.valspec.FinBij">FinBij</a></li>
<li><a title="pyphits.valspec.Integer" href="#pyphits.valspec.Integer">Integer</a></li>
<li><a title="pyphits.valspec.Interval" href="#pyphits.valspec.Interval">Interval</a></li>
<li><a title="pyphits.valspec.IsA" href="#pyphits.valspec.IsA">IsA</a></li>
<li><a title="pyphits.valspec.JENDL4Nuclide" href="#pyphits.valspec.JENDL4Nuclide">JENDL4Nuclide</a></li>
<li><a title="pyphits.valspec.LibraryID" href="#pyphits.valspec.LibraryID">LibraryID</a></li>
<li><a title="pyphits.valspec.List" href="#pyphits.valspec.List">List</a></li>
<li><a title="pyphits.valspec.NegDisable" href="#pyphits.valspec.NegDisable">NegDisable</a></li>
<li><a title="pyphits.valspec.Nuclide" href="#pyphits.valspec.Nuclide">Nuclide</a></li>
<li><a title="pyphits.valspec.OneOf" href="#pyphits.valspec.OneOf">OneOf</a></li>
<li><a title="pyphits.valspec.Orientation" href="#pyphits.valspec.Orientation">Orientation</a></li>
<li><a title="pyphits.valspec.OrthogonalMatrix" href="#pyphits.valspec.OrthogonalMatrix">OrthogonalMatrix</a></li>
<li><a title="pyphits.valspec.Particle" href="#pyphits.valspec.Particle">Particle</a></li>
<li><a title="pyphits.valspec.Path" href="#pyphits.valspec.Path">Path</a></li>
<li><a title="pyphits.valspec.PosInt" href="#pyphits.valspec.PosInt">PosInt</a></li>
<li><a title="pyphits.valspec.PosReal" href="#pyphits.valspec.PosReal">PosReal</a></li>
<li><a title="pyphits.valspec.Real" href="#pyphits.valspec.Real">Real</a></li>
<li><a title="pyphits.valspec.RealBetween" href="#pyphits.valspec.RealBetween">RealBetween</a></li>
<li><a title="pyphits.valspec.RegionTuple" href="#pyphits.valspec.RegionTuple">RegionTuple</a></li>
<li><a title="pyphits.valspec.Text" href="#pyphits.valspec.Text">Text</a></li>
<li><a title="pyphits.valspec.ThermalLib" href="#pyphits.valspec.ThermalLib">ThermalLib</a></li>
<li><a title="pyphits.valspec.Tuple" href="#pyphits.valspec.Tuple">Tuple</a></li>
<li><a title="pyphits.valspec.ZeroSpecial" href="#pyphits.valspec.ZeroSpecial">ZeroSpecial</a></li>
</ul>
</dd>
<dt id="pyphits.valspec.ZeroSpecial"><code class="flex name class">
<span>class <span class="ident">ZeroSpecial</span></span>
<span>(</span><span>zero)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroSpecial(ValSpec):
    def __init__(self, zero):
        super().__init__(one_of(just(zero), integers()))
        self.zero = zero

    def phits(self, val):
        if isinstance(val, int):
            if val == self.zero:
                return 0
            else:
                return val
        else:
            return partial(lambda va, zero, var: ValueError(f&#34;`{var}` must be an integer or {zero}; got {va}.&#34;), val, self.zero)

    def python(self, val):
        if val == 0:
            return self.zero
        else:
            return val

    def description(self):
        return f&#34;either {self.zero} or an integer&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyphits.valspec.ZeroSpecial.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    return f&#34;either {self.zero} or an integer&#34;</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.ZeroSpecial.phits"><code class="name flex">
<span>def <span class="ident">phits</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phits(self, val):
    if isinstance(val, int):
        if val == self.zero:
            return 0
        else:
            return val
    else:
        return partial(lambda va, zero, var: ValueError(f&#34;`{var}` must be an integer or {zero}; got {va}.&#34;), val, self.zero)</code></pre>
</details>
</dd>
<dt id="pyphits.valspec.ZeroSpecial.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self, val):
    if val == 0:
        return self.zero
    else:
        return val</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyphits" href="index.html">pyphits</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyphits.valspec.build" href="#pyphits.valspec.build">build</a></code></li>
<li><code><a title="pyphits.valspec.builds" href="#pyphits.valspec.builds">builds</a></code></li>
<li><code><a title="pyphits.valspec.builds_right" href="#pyphits.valspec.builds_right">builds_right</a></code></li>
<li><code><a title="pyphits.valspec.fake_kf_decode" href="#pyphits.valspec.fake_kf_decode">fake_kf_decode</a></code></li>
<li><code><a title="pyphits.valspec.interval" href="#pyphits.valspec.interval">interval</a></code></li>
<li><code><a title="pyphits.valspec.kf_decode" href="#pyphits.valspec.kf_decode">kf_decode</a></code></li>
<li><code><a title="pyphits.valspec.kf_encode" href="#pyphits.valspec.kf_encode">kf_encode</a></code></li>
<li><code><a title="pyphits.valspec.slices" href="#pyphits.valspec.slices">slices</a></code></li>
<li><code><a title="pyphits.valspec.tuplified_lists" href="#pyphits.valspec.tuplified_lists">tuplified_lists</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyphits.valspec.Between" href="#pyphits.valspec.Between">Between</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Between.description" href="#pyphits.valspec.Between.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Between.phits" href="#pyphits.valspec.Between.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Between.python" href="#pyphits.valspec.Between.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Chemical" href="#pyphits.valspec.Chemical">Chemical</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Chemical.description" href="#pyphits.valspec.Chemical.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Chemical.phits" href="#pyphits.valspec.Chemical.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Chemical.python" href="#pyphits.valspec.Chemical.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Choice10" href="#pyphits.valspec.Choice10">Choice10</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Choice10.description" href="#pyphits.valspec.Choice10.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Choice10.phits" href="#pyphits.valspec.Choice10.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Choice10.python" href="#pyphits.valspec.Choice10.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Color" href="#pyphits.valspec.Color">Color</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Color.description" href="#pyphits.valspec.Color.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Color.phits" href="#pyphits.valspec.Color.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.FinBij" href="#pyphits.valspec.FinBij">FinBij</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.FinBij.description" href="#pyphits.valspec.FinBij.description">description</a></code></li>
<li><code><a title="pyphits.valspec.FinBij.phits" href="#pyphits.valspec.FinBij.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.FinBij.python" href="#pyphits.valspec.FinBij.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Integer" href="#pyphits.valspec.Integer">Integer</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Integer.description" href="#pyphits.valspec.Integer.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Integer.phits" href="#pyphits.valspec.Integer.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Integer.python" href="#pyphits.valspec.Integer.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Interval" href="#pyphits.valspec.Interval">Interval</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Interval.description" href="#pyphits.valspec.Interval.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Interval.phits" href="#pyphits.valspec.Interval.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.IsA" href="#pyphits.valspec.IsA">IsA</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.IsA.description" href="#pyphits.valspec.IsA.description">description</a></code></li>
<li><code><a title="pyphits.valspec.IsA.phits" href="#pyphits.valspec.IsA.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.IsA.python" href="#pyphits.valspec.IsA.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.JENDL4Nuclide" href="#pyphits.valspec.JENDL4Nuclide">JENDL4Nuclide</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.JENDL4Nuclide.description" href="#pyphits.valspec.JENDL4Nuclide.description">description</a></code></li>
<li><code><a title="pyphits.valspec.JENDL4Nuclide.phits" href="#pyphits.valspec.JENDL4Nuclide.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.JENDL4Nuclide.python" href="#pyphits.valspec.JENDL4Nuclide.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.LibraryID" href="#pyphits.valspec.LibraryID">LibraryID</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.LibraryID.description" href="#pyphits.valspec.LibraryID.description">description</a></code></li>
<li><code><a title="pyphits.valspec.LibraryID.phits" href="#pyphits.valspec.LibraryID.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.List" href="#pyphits.valspec.List">List</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.List.description" href="#pyphits.valspec.List.description">description</a></code></li>
<li><code><a title="pyphits.valspec.List.phits" href="#pyphits.valspec.List.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.List.python" href="#pyphits.valspec.List.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.NegDisable" href="#pyphits.valspec.NegDisable">NegDisable</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.NegDisable.description" href="#pyphits.valspec.NegDisable.description">description</a></code></li>
<li><code><a title="pyphits.valspec.NegDisable.phits" href="#pyphits.valspec.NegDisable.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.NegDisable.python" href="#pyphits.valspec.NegDisable.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Nuclide" href="#pyphits.valspec.Nuclide">Nuclide</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Nuclide.description" href="#pyphits.valspec.Nuclide.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Nuclide.phits" href="#pyphits.valspec.Nuclide.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.OneOf" href="#pyphits.valspec.OneOf">OneOf</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.OneOf.description" href="#pyphits.valspec.OneOf.description">description</a></code></li>
<li><code><a title="pyphits.valspec.OneOf.phits" href="#pyphits.valspec.OneOf.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.OneOf.that_which_applies" href="#pyphits.valspec.OneOf.that_which_applies">that_which_applies</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Orientation" href="#pyphits.valspec.Orientation">Orientation</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Orientation.phits" href="#pyphits.valspec.Orientation.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.OrthogonalMatrix" href="#pyphits.valspec.OrthogonalMatrix">OrthogonalMatrix</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.OrthogonalMatrix.description" href="#pyphits.valspec.OrthogonalMatrix.description">description</a></code></li>
<li><code><a title="pyphits.valspec.OrthogonalMatrix.phits" href="#pyphits.valspec.OrthogonalMatrix.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Particle" href="#pyphits.valspec.Particle">Particle</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Particle.description" href="#pyphits.valspec.Particle.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Particle.phits" href="#pyphits.valspec.Particle.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Particle.python" href="#pyphits.valspec.Particle.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Path" href="#pyphits.valspec.Path">Path</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Path.description" href="#pyphits.valspec.Path.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Path.phits" href="#pyphits.valspec.Path.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.PosInt" href="#pyphits.valspec.PosInt">PosInt</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.PosInt.description" href="#pyphits.valspec.PosInt.description">description</a></code></li>
<li><code><a title="pyphits.valspec.PosInt.phits" href="#pyphits.valspec.PosInt.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.PosInt.python" href="#pyphits.valspec.PosInt.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.PosReal" href="#pyphits.valspec.PosReal">PosReal</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.PosReal.description" href="#pyphits.valspec.PosReal.description">description</a></code></li>
<li><code><a title="pyphits.valspec.PosReal.phits" href="#pyphits.valspec.PosReal.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.PosReal.python" href="#pyphits.valspec.PosReal.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Real" href="#pyphits.valspec.Real">Real</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Real.description" href="#pyphits.valspec.Real.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Real.phits" href="#pyphits.valspec.Real.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Real.python" href="#pyphits.valspec.Real.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.RealBetween" href="#pyphits.valspec.RealBetween">RealBetween</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.RealBetween.description" href="#pyphits.valspec.RealBetween.description">description</a></code></li>
<li><code><a title="pyphits.valspec.RealBetween.phits" href="#pyphits.valspec.RealBetween.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.RealBetween.python" href="#pyphits.valspec.RealBetween.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.RegionTuple" href="#pyphits.valspec.RegionTuple">RegionTuple</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.RegionTuple.description" href="#pyphits.valspec.RegionTuple.description">description</a></code></li>
<li><code><a title="pyphits.valspec.RegionTuple.phits" href="#pyphits.valspec.RegionTuple.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Text" href="#pyphits.valspec.Text">Text</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Text.description" href="#pyphits.valspec.Text.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Text.phits" href="#pyphits.valspec.Text.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.ThermalLib" href="#pyphits.valspec.ThermalLib">ThermalLib</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.ThermalLib.description" href="#pyphits.valspec.ThermalLib.description">description</a></code></li>
<li><code><a title="pyphits.valspec.ThermalLib.phits" href="#pyphits.valspec.ThermalLib.phits">phits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.Tuple" href="#pyphits.valspec.Tuple">Tuple</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.Tuple.description" href="#pyphits.valspec.Tuple.description">description</a></code></li>
<li><code><a title="pyphits.valspec.Tuple.phits" href="#pyphits.valspec.Tuple.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.Tuple.python" href="#pyphits.valspec.Tuple.python">python</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyphits.valspec.ValSpec" href="#pyphits.valspec.ValSpec">ValSpec</a></code></h4>
</li>
<li>
<h4><code><a title="pyphits.valspec.ZeroSpecial" href="#pyphits.valspec.ZeroSpecial">ZeroSpecial</a></code></h4>
<ul class="">
<li><code><a title="pyphits.valspec.ZeroSpecial.description" href="#pyphits.valspec.ZeroSpecial.description">description</a></code></li>
<li><code><a title="pyphits.valspec.ZeroSpecial.phits" href="#pyphits.valspec.ZeroSpecial.phits">phits</a></code></li>
<li><code><a title="pyphits.valspec.ZeroSpecial.python" href="#pyphits.valspec.ZeroSpecial.python">python</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>